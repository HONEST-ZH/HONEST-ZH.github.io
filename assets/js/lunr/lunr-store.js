var store = [{
        "title": "随笔模板",
        "excerpt":"测试  测试默认标题头部图片 test the default title image (overlay_color) test the count of words（only chinese was conuted!）  ","categories": ["随笔"],
        "tags": ["模板"],
        "url": "/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94%E6%A8%A1%E6%9D%BF/",
        "teaser": null
      },{
        "title": "问题记录模板",
        "excerpt":"问题描述   解决方法  ","categories": ["问题"],
        "tags": ["模板"],
        "url": "/%E9%97%AE%E9%A2%98/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E6%A8%A1%E6%9D%BF/",
        "teaser": null
      },{
        "title": "Makefile和.config",
        "excerpt":"Makefile和config/kconfig   自动项目编译工具make   make是一种用于自动编译项目的构建工具，通过执行makefile中预先写好的命令保证按照依赖关系、避免重复编译。Make在实际的工作中依然是使用gnu gcc的工具进行编译的，只是提前指定了gcc的命令。   Makefile的编写：   1.基础语法：   目标：依赖 命令   为了方便缩写和编译，可以使用定义的变量进行缩写，使用时加上()即可解析为命令进行。除此以外，存在一些简略的写法代替目标和依赖，^: 依赖、$@: 目标文件。   2.伪目标：   .PHONY:用于标识一个不对应实际文件的伪目标，这些伪目标往往用来控制makefile   例如clean。   3.例子：   CC=gcc  OBJS=hello.c  CFLAGS=-c  RM=rm -f  hello.o:$(OBJS)  (CC) (CFLAGS) ^ -o @  .PHONY:clean  clean:  $(RM) *.o   4.Makefile的remake操作：   有如下的makefile脚本，先生成target对象再重编译remake整个makefile。   -include   目标     目标: 依赖                  正则表达式   .config配置文件   Linux内核图形编译工具.Kconfig   Kconfig详解 - 大海中的一粒沙 - 博客园 (cnblogs.com)   menuconfig 和 Kconfig 介绍-阿里云开发者社区 (aliyun.com)   Linux从模块化机制学到Kconfig，Makefile构建配置原理_linux kconfig makefile-CSDN博客   为了正确处理Linux操作系统繁杂的项目文件和复杂的依赖，简单的通过源码完成内核的配置和编译。 Kconfig是一种用于支持Linux内核图形化配置（menuconfig）的脚本语言。通过Kconfigs实现图形化界面的选项设置，便于用户交互。但Linux内核实际使用是通过顶层makefile根据menucofig得到的.conf文件逐级建立的。实质上是在操作系统配置中使用的、Makefile的一种图形化配置方法。   配置内核有几种方式：   make menuconfig:图像化配置。   先生成可执行文件mconf.o生成图像界面，选择结束后生成.config文件。   make XXX_defconfig：板卡适配的默认配置。   先生成可执行文件conf.o，直接把XXX_defconfig保存成.config文件（本质是一个东西）。编译时主Makefile会根据.config中的变量决定编译哪些部分。      *Linux内核源码的这棵树，通过Makefile文件来选择各个目录下的对应的文件是否被编译，.config文件就像是控制台，控制着Makefile文件去编译指定的程序代码文件（主要是C和汇编）。而这一切控制关系是由Kconfig文件建立起来的。   ","categories": ["笔记"],
        "tags": ["Linux","操作系统内核",".config","Makfile"],
        "url": "/%E7%AC%94%E8%AE%B0/Makefile%E5%92%8C.config/",
        "teaser": null
      },{
        "title": "Markdown",
        "excerpt":"MarkDown笔记   标题：若干# + 空格   加粗： ** 文本** 、__ 文本__或Ctrl +B `   倾斜：* 文本*、_ 文本_ 或Ctrl+I   加粗+倾斜：*** 文本***、___ 文本___ 或Ctrl+B  Ctrl+I   下划线：&lt;u&gt;文本&lt;/u&gt;或Ctrl+U   删除线：~~ 文本~~或Ctrl+D   引用：&gt; 文本 或Ctrl+shift+Q   无序列表：- 列表或* 列表   有序列表：1. 列表   代码：`代码`  或Ctrl + ` `   代码段： ```   分割线 ****   数学公式：Ctrl + Shift +M 或 $数学符号$   图片：![描述]（图片路径）或Ctrl+shift+I   链接：   \\`[文本](链接网址\"悬浮title\")\\`  \\`&lt;https://www.114514.com&gt;\\`   亦或   [链接文本][1]  [1]:www.1919810.com   注释：[//]:#(注释)   目录：[TOC]  ","categories": ["笔记"],
        "tags": ["MarkDown","标记语言"],
        "url": "/%E7%AC%94%E8%AE%B0/MarkDown/",
        "teaser": null
      },{
        "title": "Uboot",
        "excerpt":"Uboot介绍   Uboot是一个开源的嵌入式系统引导程序，支持多种不同架构的板卡通过内存、SD卡或者FTP的方式加载系统。Uboot对板上的资源进行初始化使其达到满足引导操作系统的最小化要求（相当于一个小的操作系统），类似于windows系统的BIOS。   一、Uboot工作目录：   目录结构和内容，见docs.u-boot.org/en/latest/develop/directories.html中的表格。   二、Uboot的工作流程：   1. 初始化硬件资源（RAM、网卡等）   2. 从flash搬运系统的内核到RAM中   2.1.  XIP:(eXcute in place，片内执行)   e.g.写在片内的falsh中 CPU可以直接在片上访问地址找到uboot程序，无需初始化。   2.2.  非XIP：   e.g.写在SD卡上（需要初始化emmc） CPU不可以直接在片上访问地址找到uboot程序，需额外的初始化片外的存储设备，以复制uboot的程序uboot.bin和设备树。相当于额外执行了一个加载uboot的加载程序(bootrom，这段程序是在片上固化的)。   3. 启动系统的内核   三、Uboot的代码执行过程：   根据架构的设置从一个汇编文件strat.s开始。然后执行lowlevel_init()、board_init_f()、board_init_r()。   四、Uboot的make编译流程：   Uboot的程序通过make指令生成一个名为uboot.bin的二进制文件，烧录到板卡的闪存之中。                        1. 若板卡厂商已经提供了u-boot的支持：   STEP1：make XXX_defconfig：   根据板卡预设的信息_defconfig，生成.config文件。首先建立一个conf工具，使用Kconfig解析_defconfig的配置，如果不存在依赖，直接写入.config，如果存在依赖，从Kconfig中写入_defconfig依赖的配置到.config文件，未设置的配置使用默认值。   .config决定了uboot项目编译的过程中需要对那些目录、哪些文件进行编译，makefile中使用obj-$(CONFIG_XXXX)+= xxx/ 命令实现。还有可能需要编译文件中的某一部分，因此在make的时候会根据.config文件生成一个名为config.h的头文件，其中包含了所有的config的宏定义。在c文件中使用宏指令#if#else#endif判断编译那一部分。   可以使用以下技巧观察make的具体依赖，分析源码。   make xx -p &gt;detail.txt               Vi  detail.txt            :g/^#/d   STEP2：make ARCH=OOO CROSS_COMPILE=XXX*   根据.config生成了config.h文件，用于编译c文件的部分。生成auto.conf（auto.conf.cmd、autoconf.h、），生成uboot.cfg，autoconf.mk。最后生成uboot.bin文件。   2. 若板卡厂商未提供u-boot的支持：   需要自己设置.config文件然后make u-boot.bin文件。最后下入板中的是uboot.bin + 设备树文件（DTB）。  ","categories": ["笔记"],
        "tags": ["Linux","Bootloader","U-Boot"],
        "url": "/%E7%AC%94%E8%AE%B0/Uboot/",
        "teaser": null
      },{
        "title": "Linux命令行 ",
        "excerpt":"Linux命令(bash Shell命令)：   freecodecamp.org/chinese/news/the-linux-commands-handbook/   man:查看命令手册的具体内容，帮助了解（很长很长）。建议使用tldr以更快的大致了解一个命令。   man [命令]/tldr [命令]   文件夹操作：      ls:查看文件夹的内容。 默认是当前目录。常用的属性是-l,可以查看文件的详细信息（l详细数据，a显示隐藏数据）。   ls [选项] &lt;文件路径&gt;      ls -l将显示文件夹的权限、所有者和用户组     例如：-rw-r--r-- 1 user group 1024 Jan  1 00:00 example.txt     文件权限（-rw-r–r–）     第 1 个字符：表示文件类型。第 2 - 4 个字符：表示文件所有者的权限。分别对应读（r）、写（w）、执行（x）权限。如果没有相应权限，则用 - 表示。第 5 - 7 个字符：表示文件所属用户组的权限。第 8 - 10 个字符：表示其他用户的权限。     硬链接数（1） 该数字表示文件或目录的硬链接数量。对于文件来说，硬链接数表示有多少个文件名指向同一个文件的物理数据；对于目录来说，硬链接数表示该目录下的子目录和 .（当前目录）、..（父目录）的总数。     文件所有者（user） 显示文件或目录的所有者用户名。所有者对文件有特殊的权限控制，可以修改文件权限、删除文件等。     文件所属用户组（group） 显示文件或目录所属的用户组名。用户组是具有相同权限的用户集合，文件所属用户组的成员可以根据用户组的权限对文件进行操作。     文件大小（1024） 以字节为单位显示文件或目录的大小。对于目录，显示的是目录本身的元数据大小，而不是目录下所有文件的总大小。如果要查看目录下所有文件的总大小，可以使用 du -sh 命令。     文件最后修改时间（Jan 1 00:00） 显示文件或目录最后一次被修改的时间，包括月份、日期和具体时间。如果文件是很久以前修改的，可能会显示年份而不是具体时间。     文件名（example.txt）            cd:打开文件夹。   cd [选项] &lt;文件路径&gt;   .. :上级文件夹、. :当前文件夹、/：根目录、~：root目录。            pwd:显示当前的工作文件夹。            du:显示目录大小。    -h单独计算每个文件大小。            mkdir:创建新的文件夹。    -p :创建嵌套的文件夹。   mkdir [选项] &lt;文件路径&gt;            rm -f:删除文件和其中内容（必须慎重操作）。-rf:递归的删除文件（也删除文件夹里的）            rmdir:删除文件夹（必须为空）。   rmdir [选项] &lt;文件路径&gt;            mv:移动文件、文件夹；也可用于重命名文件。    -t 目标目录   mv &lt;当前文件路径&gt; &lt;新的文件路径&gt;            cp：复制文件，-r复制文件夹。            find:查找文件,可以限定查找的类型、名称、大小、时间和附加操作。   find  [路径]  -type [类型：f/d]  -name [文件名]  -size [+大于的值/-小于的值]  -mtime [更新时间]  -delete/-exec [命令]       ln:链接文件,包括硬链接和软链接。保证同步更新？   硬链接：ln ，复制+同步   软链接：ln ，指针        gzip：压缩       ta：归档   文件操作：           touch :创建文件，以写入方式打开。            cat：打印文件的内容到标准输出。       cat常常与管道运算符，重定向输出符等连用       cat 文件名             | 是管道符号，标识把左边的内容的输出作为右边内容的输入。 &gt;是重定向输出符号，把内容输出到文件当中，会覆盖 &gt;&gt;是追加重定向输出符号，把内容追加在文件的末尾                 tail: 打开并监控文件的末尾。（用于日志监控）   tail -f [文件]            grep：全局正则表达式打印。 在指定的文件里寻找字符串（正则表达式）。 -n 显示匹配的行行号、- l 打印匹配的文件名、-i 忽略大小写匹配、-v 反向查找（打印不匹配的） 、-r 递归查找文件、-c 只打印匹配的行数、-C x 打印匹配的行前后x行的内容。   grep [选项] 表达式 [文件]            echo:打印输出。            sort:对文本进行排序 -r倒序 -u移除重复的（对中文不可用）            uniq：去除重复的行，-d显示重复行、-u显示不重复行、-c计数            diff:比对两个文档。-y逐行对比、-u git式的对比、-r 递归比较、-q显示不同的文件名       进程操作：           ps:检查进程，（静态）            top:动态监控进程 top 命令是 Linux 系统中用来查看系统当前资源使用情况（如 CPU、内存、进程等）和实时监控的工具。它显示的信息非常丰富，能够帮助管理员和用户了解系统的性能和负载。          1.top 命令的输出内容说明 默认情况下，top 显示的是一个动态更新的界面，内容分为几个主要部分：     (1) 头部信息 系统时间：当前时间、系统运行时间、系统负载等。 运行中的任务数：系统上正在运行的进程数量。 CPU 使用情况：显示不同 CPU 核心的使用情况。 内存使用情况：显示物理内存和交换空间（swap）的使用情况。 示例：    top - 15:25:34 up 3 days,  2:45,  2 users,  load average: 0.05, 0.03, 0.01 Tasks: 196 total,   1 running, 195 sleeping,   0 stopped,   0 zombie %Cpu(s):  3.2 us,  1.8 sy,  0.0 ni, 94.8 id,  0.0 wa,  0.0 hi,  0.2 si,  0.0 st MiB Mem :   8028.2 total,   1056.4 free,   5562.8 used,   1409.0 buff/cache MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   1569.5 avail Mem      (2) 进程信息 接下来是关于正在运行的进程的详细信息：     PID：进程 ID。 USER：进程所属的用户。 PR：进程的优先级。 NI：进程的 nice 值（调整进程优先级）。 VIRT：进程使用的虚拟内存总量。 RES：进程使用的物理内存量。 SHR：进程共享的内存量。 S：进程的状态（如 R 为运行中，S 为休眠中，Z 为僵尸进程等）。 %CPU：该进程占用的 CPU 百分比。 %MEM：该进程占用的内存百分比。 TIME+：进程占用的 CPU 时间（累计）。 COMMAND：进程执行的命令名称。 示例：    PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND 1234 root      20   0  164012   9324   5860 S  2.0  0.1   0:09.32 bash 5678 user      20   0  120400   7204   3200 S  1.0  0.1   0:07.28 python      2.常用命令选项 (1) 动态更新间隔 top 默认每 3 秒更新一次数据，你可以通过按 d 键来修改更新的间隔时间。例如，输入 d 后可以设定每 1 秒更新一次。     (2) 显示不同的排序方式 P：按 CPU 使用率排序。 M：按内存使用量排序。 T：按运行时间排序。 N：按进程 PID 排序。     (3) 切换显示模式 按 1 键切换显示每个 CPU 核心的使用情况。 按 c 键可以切换是否显示进程的完整命令行（默认只显示程序名称）。     (4) 过滤进程 按下 o 键可以过滤进程（类似 grep 的功能）。例如，输入 COMMAND=python 会只显示所有 python 相关的进程。     (5) 进程管理 按 k 键后，输入进程 PID 和信号（如 9 代表终止进程）可以终止某个进程。 按 r 键后，可以改变进程的优先级（调整 nice 值）。     (6) 显示内存、CPU 等统计信息 m：显示内存统计。 t：显示线程信息。 d：调整刷新频率（秒）。 q：退出 top 命令。         命令行选项 top -d ：指定更新的间隔时间（单位：秒），例如 top -d 1 每秒刷新一次。 top -n ：指定 top 刷新多少次后退出，例如 top -n 5 刷新 5 次后退出。 top -u ：显示某个用户的进程信息。 top -p ：只显示指定进程的状态。         kill：向进程发送信号（KILL和STOP先向内核发送，由内核操纵进程）。信号包括：HUP(1)挂起、INT(2)干扰、KILL(9)强制终结、TERM(15)正常终结、CONT(18)继续、STOP(19)停止   用户操作：     users:命令会显示当前登录到系统的所有用户            查看当前系统内的所有用户，使用文本编辑器打开文件        vi /etc/passwd              /etc/passwd 文件是一个重要的系统文件，它存储了系统中所有用户的基本信息。使用 vi /etc/passwd 命令打开该文件后，每一行代表一个用户的信息，各字段之间用冒号 : 分隔。        username:x:1001:1001:User Description:/home/username:/bin/bash               用户名（username）：这是用户登录系统时使用的名称，是用户在系统中的唯一标识，通常由字母、数字、下划线等字符组成，且不能包含冒号 :。         加密密码占位符（x）:在早期的 Linux 系统中，该字段存储用户的加密密码。但由于 /etc/passwd 文件的权限通常设置为所有用户可读，为了提高安全性，现在密码通常存储在 /etc/shadow 文件中，而 /etc/passwd 文件中的该字段统一显示为 x，表示密码被存储在其他地方。         用户 ID（UID，1001）:用户 ID 是一个唯一的整数，用于系统内部标识用户。系统通过 UID 来管理用户的权限和资源。在大多数 Linux 系统中，root 用户的 UID 为 0，系统保留用户（如 daemon、bin 等）的 UID 通常小于 1000，而普通用户的 UID 通常从 1000 或 1001 开始分配。         组 ID（GID，1001）:组 ID 是用户所属主要用户组的唯一标识。用户可以属于多个用户组，但每个用户都有一个主要用户组，记录在 /etc/passwd 文件中。与 UID 类似，系统通过 GID 来管理用户组的权限和资源。用户组的详细信息存储在 /etc/group 文件中。         用户描述信息（User Description） 该字段用于存储用户的描述信息，通常是用户的全名或其他相关说明。         用户主目录（/home/username）:用户主目录是用户登录系统后默认进入的目录，通常以 /home 为根目录，后面跟上用户名。         用户默认 shell（/bin/bash）:该字段指定用户登录系统后默认使用的 shell 程序。如果该字段设置为 /sbin/nologin，则表示该用户不能登录系统，通常用于系统服务账户。                 groups:查看当前用户所属的用户组            chown:改变所有者       chown newuser:newgroup example.txt            chmod:改变权限。       rwx分别对应了读4写2执行1,不操作的使用-替代。一个文件有三组rwx的值，对应所有者、关联的用户组和其他人的权限。       -R递归的改变文件夹下的所有文件的权限       chmod  owner/group/world  +/-  rwx            df:获取磁盘使用情况。-h            su -l :切换设备权限到root            alias:为命令创造别名。       ’’ 变量在调用时解析, ””变量在定义时解析。 alias [new_cmd]=’cmd’/”cmd”       ldconfig：更新系统共享库缓存   查看操作   sudo netstat -tulpn | grep &lt;port_number&gt;   Linux相关的快捷键           常用：              Ctrl L ：清屏       Ctrl C : 中断正在当前正在执行的程序       ctrl+alt+t：打开终端                历史命令：              Ctrl P : 上一条命令，可以一直按表示一直往前翻       Ctrl N : 下一条命令       Ctrl R，再按历史命令中出现过的字符串：按字符串寻找历史命令（重度推荐）                命令行编辑：              Tab : 自动补齐（重度推荐）       Ctrl A ： 移动光标到命令行首       Ctrl E : 移动光标到命令行尾       Alt F : 光标前进一个单词       Alt B : 光标后退一格单词       Ctrl ] : 从当前光标往后搜索字符串，用于快速移动到该字符串       Ctrl Alt ] : 从当前光标往前搜索字符串，用于快速移动到该字符串       Ctrl H : 删除光标的前一个字符       Ctrl D : 删除当前光标所在字符       Ctrl K ：删除光标之后所有字符       Ctrl U : 清空当前键入的命令       Ctrl W : 删除光标前的单词(Word, 不包含空格的字符串)       Ctrl \\ : 删除光标前的所有空白字符       Ctrl Y : 粘贴Ctrl W或Ctrl K删除的内容                其他：              Ctrl Z : 把当前进程放到后台（之后可用’‘fg’‘命令回到前台）       Shift Insert : 粘贴（相当于Windows的Ctrl V）       在命令行窗口选中即复制       在命令行窗口中键即粘贴，可用Shift Insert代替       Ctrl PageUp : 屏幕输出向上翻页       Ctrl PageDown : 屏幕输出向下翻页           Linux的包管理工具Apt   包管理工具apt   apt是linux上进行包管理的一种常用工具，调用dpkg管理已安装的包还能管理未安装的包（一定要确定包是否已经安装！）   apt install：安装软件包，从sourcelist中定义的源获取。   apt list   参数：–installed apt list --installed|grep -i [pakegename]列出已经下载的名字为pakegename的   apt search：寻找的是可以从所有软件源上下载到的包，并不是本地的包/已经安装的包。   apt-get   dpkg   dpkg 是Debian发行版中的包管理工具，只能用于已安装的包的管理   参数：-L ： dpkg -L [pakegename]查找pakegename的安装包路径  ","categories": ["笔记"],
        "tags": ["Linux","Shell"],
        "url": "/%E7%AC%94%E8%AE%B0/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/",
        "teaser": null
      },{
        "title": "编译器gcc和交叉编译工具链",
        "excerpt":"交叉编译工具链gcc：   gcc是GNU Compiler Collection的简写，是一款被广泛使用的c语言编译工具。      还有Clang等编译工具    一、gcc的一般流程：   Linux下的ELF文件、链接、加载与库（含大量图文解析及例程）_elf文件的动态链接库与静态链接库-CSDN博客   首先需要了解源代码的编译这个复杂的过程。编译的过程实际上是把高级语言转换为低级语言的过程，编译和汇编是他的核心步骤，对计算机有一定了解的朋友想必都能很顺利的理解这一点。但是出于具体工程的兼容性和复用性的需要，还需要额外具有预处理和链接这两个额外的步骤。   下面稍微介绍一下为什么需要进行预处理和链接。在实际使用中，一段源码为了支持不同的平台上，不同的设备需要设置一定的宏变量以描述在对应的平台上具有的软件或硬件的特性。对于不同的特性应该进行的不同的操作，这就是选择性编译和编译控制。通过这种方法我们保证了代码的兼容性。   除此以外，在复杂的工程中经常充斥着对一段基础性代码的反复调用。为了提高可用性和效率，我们并不是每次使用都编译他们，而是将他们都提前编译好形成一个二进制文件。在每次编译文件时需要调用这个函数的时候，编译器会预先挖好空，等到链接阶段的时候直接链接到这个二进制文件去执行。一般的，大量的提前编译好的文件被打包归档成为一个库文件（lib, library）。库文件分为动态库和静态库，他们的实现之间有着一定的不同，相关的知识可以参见链接。【C++】静态库和动态库文件的生成和使用_c++ .a文件-CSDN博客   总而言之，编译一段源码的过程是：           预处理(Preprocessing)：.c-&gt;.i  处理包含、宏定义（#标识）       gcc -e xxx.c -o yyy.i            编译(Compilation)：.i-&gt;.s  转换到特定汇编代码（不是机器码，取决于指令集）       gcc -s xxx.i -o yyy.s            汇编(Assemble)：.s-&gt;.o 转换到机器码（但并不是实际执行的代码）       gcc -c xxx.s -o yyy.o            链接(Linking):.o-&gt;可执行文件(.exe或者.elf)        目标文件.o和其他文件、库文件、启动文件链接起来       gcc [无] xxx.o -o yyy -l zzz.a            一般来说，使用gcc直接从.c文件编译到可执行文件       gcc [-选项] [目标文件] ，一般的缩写为：gcc xxx.c -o yyy       这个过程中具有的文件类型有：           源文件.c、头文件.h；            预处理得到的.i 预处理文件；            编译得到的.s 汇编文件；            汇编得到.o（可重定向）目标文件；            链接得到.out 或 .elf 可执行（目标）文件。            静态库文件.a实质上就是预先编译、汇编好的.o目标文件的集合。在运行前加载到代码段当中。            动态库文件.so又叫共享目标文件，在运行时加载到内存的共享库段          二、交叉编译   三、编译的头文件、库文件路径优先级：   gcc路径搜索是具有优先级的     LD_PRELOAD环境变量 LD_PRELOAD 环境变量允许你指定一个或多个共享库，这些共享库会在程序启动时被优先加载，覆盖掉原有的同名库。   export LD_PRELOAD=/path/to/my/preload/lib.so      gcc编译选项：   可以直接在编译命令中使用 -I 参数指定头文件目录，或使用 -L 参数指定链接时库文件路径(作用于gcc/g++),-Wl,-rpath 参数指定执行时库路径（作用于ld.so,-wl表示后面的参数传递给链接器）。当指定多个动态库搜索路径时，路径之间用冒号:分隔。   gcc -I/path/to/headers -L/path/to/libs myprogram.c -Wl,-rpath=path/to/libs  -o myprogram      通过.c文件的参数设置路径：   还可以使用环境变量来扩展搜索路径。需要注意的是这种方法添加的搜索路径是临时的，仅在当前终端有效。   C_INCLUDE_PATH：   通过设置环境变量来添加自定义的头文件目录。   export C_INCLUDE_PATH=/path/to/your/custom/headers   CPLUS_INCLUDE_PATH：   类似于 C_INCLUDE_PATH，但适用于 C++。   export CPLUS_INCLUDE_PATH=/path/to/your/custom/headers  LIBRARY_PATH：   用于指定库文件（主要是静态链接库）的搜索路径。如果你的程序依赖于自定义库，可以将库文件路径添加到此环境变量中。在链接时起效。   export LIBRARY_PATH=/path/to/your/custom/libs   LD_LIBRARY_PATH：   用于指定库文件（动态链接库）的搜索路径。如果你的程序依赖于自定义库，可以将动态库路径添加到此环境变量中。在运行时起效。   export LD_LIBRARY_PATH=/path/to/your/custom/libs      配置文件指定的库路径   配置文件/etc/ld.so.conf中指定的动态库搜索路径。这是一个系统级别的更改，通常需要运行ldconfig命令来更新系统的库缓存，使新添加的路径生效。      系统默认搜索路径：   gcc 默认会搜索一些标准的系统头文件和库文件路径。   例如库文件路径是：/lib、/usr/lib、/lib64、/usr/lib64。/usr/local/lib和/usr/local/lib64一般存放用户自定义的库，一般不在标准的搜索路径之中。同样的也有/include、/usr/local/include等设置头文件搜索路径的  ","categories": ["笔记"],
        "tags": ["GCC","交叉编译"],
        "url": "/%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%99%A8GCC%E5%92%8C%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/",
        "teaser": null
      },{
        "title": "Vim使用",
        "excerpt":"文本编辑器vim：   命令模式（：）和插入模式（i）,按ecs从插入到命令。命令模式下可以输入命令对文本进行控制。   w 保存   wq保存并退出   q! 退出不保存   u undo   crtl-r redo   x删除   dw删除单词   d$ 删除到行结束   d number w/number e 删除到下number个词的开头或者结束   dd删除整行   p把删除的放到指定位置   r取代当前的词   /向前搜索   ?向后搜索   %匹配对应的括号   s替换/old为/new   G移动到结尾   gg移动到开头   ctrl-G当前位置   o下方创建新的一行   O上方创建新的一行   a添加   A在后面的行添加。  ","categories": ["笔记"],
        "tags": ["Vim"],
        "url": "/%E7%AC%94%E8%AE%B0/Vim%E4%BD%BF%E7%94%A8/",
        "teaser": null
      },{
        "title": "Zero mq",
        "excerpt":"Zero MQ     We took a normal TCP socket, injected it with a mix of radioactive isotopes stolen from a secret Soviet atomic research project, bombarded it with 1950-era cosmic rays, and put it into the hands of a drug-addled comic book author with a badly-disguised fetish for bulging muscles clad in spandex.                                                                                                           —-Pieter Hintjens, CEO of iMatix   精简版：人们受够了套接字！他实在太混乱了！ZMQ就是这个混乱网络世界的救主。                                                                                                   —-笔者      ZMQ是一个高性能的异步消息传递库，提供了一个无需消息代理的消息队列（MQ）。ZMQ通过多种传输方式（TCP, in-process, inter-process, multicast, WebSocket and more）实现了常见的消息传递模式（pub/sub, request/reply, client/server and others）从而使进程间消息传递变得与线程间消息传递一样简单。这样可以保持代码清晰、模块化，并且非常易于扩展。   本质上ZMQ和Redis、RabbitMQ、RocketMQ、Kafka这类的消息中间件并不相同。ZMQ更类似于一个对socket的封装，包含了网络层协议。因此他更快速也无需消息代理（message broker)。当然，这也意味着更底层更复杂（这就是力量的代价：MQ +4/+4，当发生底层错误时消灭程序员）。   中文zguide   一、 ZMQ模型                  [1. Basics       ØMQ - The Guide](https://zguide.zeromq.org/docs/chapter1/#Why-We-Needed-ZeroMQ)           一文带你入门了解“零之禅“消息队列ZeroMQ-CSDN博客   重头戏！ZeroMQ的管道模式详解：ZMQ_PUSH、ZMQ_PULL_zmq push pull-CSDN博客   1 请求/应答模型(REQ/REP)–1v1   1.1 原理      REQ-REP 套接字的步调一致。客户端循环发出zmq_send()，然后发出 zmq_recv()（如果仅此而已，则只发出一次）。执行任何其他顺序（例如，连续发送两条消息）将导致 send或recv调用返回 -1 代码。同样，服务会根据需要按顺序发出zmq_recv()，然后发出 zmq_send() 。   1.2 服务器端   服务器创建一个响应类型的套接字（稍后您将了解有关请求-响应的更多信息），将其绑定到端口 5555，然后等待消息。您还可以看到我们没有任何配置，我们只是发送字符串。   //  Hello World server #include &lt;zmq.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;assert.h&gt;  int main (void) {     //  Socket to talk to clients     void *context = zmq_ctx_new ();     void *responder = zmq_socket (context, ZMQ_REP);     int rc = zmq_bind (responder, \"tcp://*:5555\");     assert (rc == 0);      while (1) {         char buffer [10];         zmq_recv (responder, buffer, 10, 0);         printf (\"Received Hello\\n\");         sleep (1);          //  Do some 'work'         zmq_send (responder, \"World\", 5, 0);    }     return 0; }   1.3 客户端   客户端创建一个请求类型的套接字，连接并开始发送消息。send和方法receive都是阻塞的（默认情况下）。对于接收来说很简单：如果没有消息，该方法将阻塞。对于发送来说，它更复杂，并且取决于套接字类型。对于请求套接字，如果达到高水位或没有连接对等点，该方法将阻塞。   //  Hello World client #include &lt;zmq.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt;  int main (void) {     printf (\"Connecting to hello world server…\\n\");     void *context = zmq_ctx_new ();     void *requester = zmq_socket (context, ZMQ_REQ);     zmq_connect (requester, \"tcp://localhost:5555\");      int request_nbr;     for (request_nbr = 0; request_nbr != 10; request_nbr++) {         char buffer [10];         printf (\"Sending Hello %d…\\n\", request_nbr);         zmq_send (requester, \"Hello\", 5, 0);         zmq_recv (requester, buffer, 10, 0);         printf (\"Received World %d\\n\", request_nbr);     }     zmq_close (requester);     zmq_ctx_destroy (context);     return 0; }   #注意:字符串安全性#      C语言中的字符串并不安全！     zmq_send只关注会发送的字符的数量，这意味着它是可以发送带有空字节的字符串的。这会导致不正确的字符串格式—没有安全的终止。如果接收方的buffer中剩余的位置不是空字符（尽管大部分情况下是这样），将会导致字符串读写的错误     zmq_send (requester, \"Hello\", 6, 0);       一般默认的我们认为zmq_send使用的字符串的长度是不带终止符的长度，也就是strlen得到的长度。也就是说，网络中传输的字符串不是C语言中的字符串，需要额外的格式化处理。     我们选择在接收端对接收的字符进行处理。在实际的使用之中，有两种方法：1.每次memset接收缓存为0；2.需要对接收缓存的字符串多读一位然后使用空字符截取，好消息是我们从0开始，所以recv的返回值就是那个多一位，该赋值为空字符的位置。两种方法的思路其实是一样的，为recv到的网络字符添加空字符结尾，使他结束在应该有的位置。     //  Receive ZeroMQ string from socket and convert into C string //  Chops string at 255 chars, if it's longer static char * s_recv (void *socket) {     char buffer [256];     int size = zmq_recv (socket, buffer, 255, 0);     if (size == -1)         return NULL;     if (size &gt; 255)         size = 255;     buffer [size] = '\\0';     /* use strndup(buffer, sizeof(buffer)-1) in *nix */     return strdup (buffer); }       可以使用zhelpers.h头文件对c语言进行安全的收发。点击此处查看具体源码。     ps. 不正确的使用send，在router中会导致身份识别的错误请务必注意！    2  发布/订阅模型(PUB/SUB)–1vN   2.1 原理      单向数据分发即服务器将更新流推送到一组客户端。这股更新流可以理解为无始无终永不结束的广播。   2.2 发布者（生产者）   //  Weather update server //  Binds PUB socket to tcp://*:5556 //  Publishes random weather updates  #include \"zhelpers.h\"  int main (void) {     //  Prepare our context and publisher     void *context = zmq_ctx_new ();     void *publisher = zmq_socket (context, ZMQ_PUB);     int rc = zmq_bind (publisher, \"tcp://*:5556\");     assert (rc == 0);      //  Initialize random number generator     srandom ((unsigned) time (NULL));     while (1) {         //  Get values that will fool the boss         int zipcode, temperature, relhumidity;         zipcode     = randof (100000);         temperature = randof (215) - 80;         relhumidity = randof (50) + 10;          //  Send message to all subscribers         char update [20];         sprintf (update, \"%05d %d %d\", zipcode, temperature, relhumidity);         s_send (publisher, update);     }     zmq_close (publisher);     zmq_ctx_destroy (context);     return 0; }   2.3 订阅者（消费者）   //  Weather update client //  Connects SUB socket to tcp://localhost:5556 //  Collects weather updates and finds avg temp in zipcode  #include \"zhelpers.h\"  int main (int argc, char *argv []) {     //  Socket to talk to server     printf (\"Collecting updates from weather server...\\n\");     void *context = zmq_ctx_new ();     void *subscriber = zmq_socket (context, ZMQ_SUB);     int rc = zmq_connect (subscriber, \"tcp://localhost:5556\");     assert (rc == 0);      //  Subscribe to zipcode, default is NYC, 10001     const char *filter = (argc &gt; 1)? argv [1]: \"10001 \";     rc = zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE,                          filter, strlen (filter));     assert (rc == 0);      //  Process 100 updates     int update_nbr;     long total_temp = 0;     for (update_nbr = 0; update_nbr &lt; 100; update_nbr++) {         char *string = s_recv (subscriber);          int zipcode, temperature, relhumidity;         sscanf (string, \"%d %d %d\",             &amp;zipcode, &amp;temperature, &amp;relhumidity);         total_temp += temperature;         free (string);     }     printf (\"Average temperature for zipcode '%s' was %dF\\n\",         filter, (int) (total_temp / update_nbr));      zmq_close (subscriber);     zmq_ctx_destroy (context);     return 0; }   关键在于 zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE,filter, strlen (filter)); 一步为subscriber设置订阅。PUB-SUB 套接字对是异步的。客户端循环执行zmq_recv()（如zmq_hello_world_client果仅此而已，则执行一次）。尝试向 SUB 套接字发送消息将导致错误。同样，服务会根据需要尽可能频繁地执行 zmq_send()，但不得在 PUB 套接字上执行zmq_recv() 。   理论上，对于 ZeroMQ 套接字，哪一端连接和哪一端绑定并不重要。然而，在实践中存在一些未记录的差异。一般的，在PUB端bind在SUB端connect。      在通常的套接字编程中，bind 和conect一般分别用于服务器端和客户端。bind用于服务器监听指定的地址和端口，connect用于客户端连接到指定地址的服务器。     在ZMQ中,在那一段bind或connect并无影响（为什么？）但实际上还是有差异的（毕竟底层的套接字不同）    #注意:缓慢加入问题#      ”缓慢加入“问题会导致SUB永远没办法接收到PUB发送的最开始的信息（建立连接需要时间，这段时间中PUB很可能已发出很多信息！）需要对发布者和订阅者的同步。    3 推拉模型（PUSH/PULL)–1vNv1   管道模式或者叫并行流水线(ventilator/worker/sink)   3.1 原理      可同时执行多项任务的发送者ventilator、一组处理任务的工作者worker、从工作进程收集结果的接收者sink。发送者将任务分配给工人并行的处理，工人将各自的成果交给接收者。实质上是push和pull两种套接字上的操作！!本质是单向的套接字接口。   3.2 发送者   //  Task ventilator //  Binds PUSH socket to tcp://localhost:5557 //  Sends batch of tasks to workers via that socket  #include \"zhelpers.h\"  int main (void)  {     void *context = zmq_ctx_new ();      //  Socket to send messages on     void *sender = zmq_socket (context, ZMQ_PUSH);     zmq_bind (sender, \"tcp://*:5557\");      //  Socket to send start of batch message on     void *sink = zmq_socket (context, ZMQ_PUSH);     zmq_connect (sink, \"tcp://localhost:5558\");      printf (\"Press Enter when the workers are ready: \");     getchar ();     printf (\"Sending tasks to workers...\\n\");      //  The first message is \"0\" and signals start of batch     s_send (sink, \"0\");      //  Initialize random number generator     srandom ((unsigned) time (NULL));      //  Send 100 tasks     int task_nbr;     int total_msec = 0;     //  Total expected cost in msecs     for (task_nbr = 0; task_nbr &lt; 100; task_nbr++) {         int workload;         //  Random workload from 1 to 100msecs         workload = randof (100) + 1;         total_msec += workload;         char string [10];         sprintf (string, \"%d\", workload);         s_send (sender, string);     }     printf (\"Total expected cost: %d msec\\n\", total_msec);      zmq_close (sink);     zmq_close (sender);     zmq_ctx_destroy (context);     return 0; }   当工作者准备好时，发送者发送一个开始标志给sink让其准备好接收工人的成果。这么做的原因是和发布订阅模型一样可能存在丢失的信息，所以必须的先让接收者做好接收的准备，再让其得到工作者发出的信息。   3.3 工作者   //  Task worker //  Connects PULL socket to tcp://localhost:5557 //  Collects workloads from ventilator via that socket //  Connects PUSH socket to tcp://localhost:5558 //  Sends results to sink via that socket  #include \"zhelpers.h\"  int main (void)  {     //  Socket to receive messages on     void *context = zmq_ctx_new ();     void *receiver = zmq_socket (context, ZMQ_PULL);     zmq_connect (receiver, \"tcp://localhost:5557\");      //  Socket to send messages to     void *sender = zmq_socket (context, ZMQ_PUSH);     zmq_connect (sender, \"tcp://localhost:5558\");      //  Process tasks forever     while (1) {         char *string = s_recv (receiver);         printf (\"%s.\", string);     //  Show progress         fflush (stdout);         s_sleep (atoi (string));    //  Do the work         free (string);         s_send (sender, \"\");        //  Send results to sink     }     zmq_close (receiver);     zmq_close (sender);     zmq_ctx_destroy (context);     return 0; }   工作者得到发送者的任务后停止一段时间然后发出成果给接收者。但这里隐含一个需求——所有的工作者需要同步的开始工作。也就是说我们需要额外的操作实现同步的并行处理。   同时，发送者需要均匀的为每一位工作者分配任务，称为**负载均衡**。   3.4 接收者   //  Task sink //  Binds PULL socket to tcp://localhost:5558 //  Collects results from workers via that socket  #include \"zhelpers.h\"  int main (void)  {     //  Prepare our context and socket     void *context = zmq_ctx_new ();     void *receiver = zmq_socket (context, ZMQ_PULL);     zmq_bind (receiver, \"tcp://*:5558\");      //  Wait for start of batch     char *string = s_recv (receiver);     free (string);      //  Start our clock now     int64_t start_time = s_clock ();      //  Process 100 confirmations     int task_nbr;     for (task_nbr = 0; task_nbr &lt; 100; task_nbr++) {         char *string = s_recv (receiver);         free (string);         if (task_nbr % 10 == 0)             printf (\":\");         else             printf (\".\");         fflush (stdout);     }     //  Calculate and report duration of batch     printf (\"Total elapsed time: %d msec\\n\",          (int) (s_clock () - start_time));      zmq_close (receiver);     zmq_ctx_destroy (context);     return 0; }**   接收者需要均匀的从工作者处接收成果，也就是**公平排队**的接收机制。   3.5  负载均衡和公平排队      注意:不完全的负载均衡#      和发布/订阅模型一样，流水线模式也有着很严重的同步问题需要研究。     PUSH 套接字无法正确实现负载平衡。如果您同时使用 PUSH 和 PULL，并且您的一个工作进程收到的消息比其他工作进程多得多，这是因为该 PULL 套接字比其他工作进程加入得更快，并且在其他工作进程设法连接之前就获取了大量消息。     如果您想要正确的负载平衡，您可能需要查看 第 3 章 - 高级请求-回复模式中的负载平衡模式。    4 独占套接字对（Exclusive pair)–线程间通信   —-todo:   5 路由模式（Router/Dealer)–NvN   Router/Dealer模式是异步版的的REQ/REP模式。在实际的高访问量高并发性应用当中，往往有者多个服务器共同完成请求任务，甚至承载着不同的任务（微服务？）。此时可以通过一个消息中间人（message broker）（类似于Nginx的反向代理服务器？作用于不同的层次）实现请求应答。   router实际上在使用中更多的起到的是消息中间人的效果！   zeromq中两个dealer 通过一个router进行通信 - fengbohello - 博客园   6 有代理的发布/订阅模型（XPUB/XSUB）   —-todo:   二、ZMQ套接字机制   1 ZMQ上下文的创建和销毁：   在ＺＭＱ中，使用ZMQ上下文管理所有的套接字。ZMQ使用一个称为上下文的结构体管理套接字——一个zmq::ctx_t类型的结构体,用于管理单个进程的所有套接字。一般的我们在一个进程开始时使用zmq_ctx_new()去创建上下文，在进程结束时使用zmq_ctx_term() / zmq_ctx_destroy()去销毁上下文,释放所有资源。如果使用fork，则是在fork之后和子线程的开头创建上下文。一般来说在子线程进行具体的zmq操作，在父线程进行线程管理。      在之前的zmq版本中使用的是zmq_init()和zmq_term()去创建和销毁上下文。但这样并没有表现出zmq上下文的作用，为了强调这是上下文的创建和销毁而修改了接口。更主要的，这为了提示你还需要释放zmq_msg结构体和套接字才能实现完整的释放，不导致资源泄露。换句话说，实际上ZMQ就是ZMQ上下文。    在ZMQ当中，一个完整的资源释放过程被分为了三个部分：释放zmq_msg_t、释放套接字、释放zmq_ctx_t。           释放zmq_msg_t： 在使用时尽量使用zmq_send()和zmq_recv()，而不是zmq_msg_send()和zmq_msg_recv()。通过这种方法来避免zmq_msg_t结构体的使用。如果非要使用的话，需要在每次使用之后立刻调用zmq_msg_close()来关闭消息结构体，避免内存泄漏。            释放套接字： 在连接的套接字使用完毕后，需要及时的使用zmq_close()关闭套接字，因为上下文的释放仅能在其拥有的所有套接字都释放完毕后进行。此时需要为未关闭的套接字设置一个较小的LINGER值（等待时间，比如1s），然后关闭所有的套接字。            释放zmq_ctx_t：zmq_ctx_destroy()的过程是一个复杂而痛苦的过程，因为上下文释放时可能仍有着悬挂的连接和进行的发送，也就是上下文对应的套接字没有完全释放。此时zmq_ctx_destroy()会一直被挂起。              释放zmq上下文的zmq_ctx_term()的流程是：                             任何当前在“context”内打开的套接字上正在进行的阻塞操作应立即以错误代码 ETERM 返回。除了zmq_close()之外，在“context”内打开的套接字上的任何进一步操作都应因错误代码 ETERM 而失败。                              中断所有阻塞调用后，zmq_ctx_term()应阻塞，直到：                                         所有在“context”内打开的套接字都已使用zmq_close()关闭                                          zmq_send()发送的所有消息要么已实际传输到网络对等方，要么套接字的延迟时间已过期（由ZMQ_LINGER套接字选项设置）。                                                    2 ＺＭＱ上下文对于套接字的管理：   ZMQ上下文对于套接字的管理主要包括：           创建和销毁套接字，它们共同构成套接字生命的循环（参见zmq_socket()、zmq_close()）。            通过设置选项并在必要时检查它们来配置套接字（参见zmq_setsockopt()、zmq_getsockopt()）。            通过创建 ZeroMQ 连接将套接字插入网络拓扑（参见zmq_bind()、zmq_connect()）。            通过在套接字上写入和接收消息来使用套接字传输数据（参见zmq_msg_send()、zmq_msg_recv()）。       2.1 ZMQ套接字的创建：   —-todo:   2.2 ZMQ 的套接字选项：   —-todo:   2.3 ZMQ套接字绑定和连接：   ZMQ允许不严格的区分bind和connect，这使得其使用更加简单。但是正如之前在ZMQ模式中提到的，他们实际上有着微妙不同，但我们只需要按照标准的方法来使用它就可以避免。一般来说，执行zmq_bind()的节点是***“服务器”***，位于***众所周知的网络地址***上，而执行zmq_connect()的节点是***“客户端”***，具有***未知或任意的网络地址***。因此，我们说“将套接字绑定到端点”和“将套接字连接到端点”，端点是众所周知的网络地址。   2.4 ZMQ的发送和接收：   ＺＭＱ与TCP套接字的区别：           可以使用任意传输方式进行传输（ inproc、ipc、tcp、pgm或epgm）。zmq_inproc()、zmq_ipc()、zmq_tcp()、zmq_pgm()和zmq_epgm()。            一个套接字可能有许多传出连接和许多传入连接。            没有zmq_accept () 方法。当套接字绑定到端点时，它会自动开始接受连接。            网络连接由ZMQ自动管理，你无法直接处理这些连接。如果网络连接中断（例如，如果对等方消失然后又回来），ZeroMQ 将自动重新连接。            ZMQ不是一个能承载协议的中间载体，只能使用ZMQ_ROUTER_RAW套接字选项支持正确的读写HTTP等协议。这意味着他不能兼容现有的协议（like:HTTP，因为它们基于socket而ZMQ对socket进行了封装）。尽管可以使用ZMQ实现类似的协议但他们本质不同（取决于对端的协议，更广泛的设备使用的是普通的协议）。。            ZMQ使用一个I/O线程来处理所有的网络连接，处于不断轮询的poll/select之中。       三、ZMQ程序接口   void *zmq_ctx_new ();           返回值：                       成功: 返回ZMQ上下文content，是一个zmq_ctx_t的结构体                        失败: 返回NULL, 并设置errno                   void *zmq_ctx_term ();           返回值:                       成功: 返回0                        失败: 返回-1, 并设置errno                   三、ZMQ源码结构   https://www.iteye.com/blog/watter1985-1736023   zeromq源码分析笔记之架构（1） - zengzy - 博客园   zmq源代码分析 - mailbox_t_zmq代码-CSDN博客   ZMQ API reference   The Architecture of Open Source Applications (Volume 2)ZeroMQ  ","categories": ["笔记"],
        "tags": ["中间件","消息队列","ZMQ"],
        "url": "/%E7%AC%94%E8%AE%B0/Zero-MQ/",
        "teaser": null
      },{
        "title": "锐华嵌入式操作系统",
        "excerpt":"锐华嵌入式操作系统   CH 1—ReDE   一、 ReDE介绍   ReDe是基于Eclipse开发的集成嵌入式系统开发平台。构建和项目管理依赖于GCC交叉编译工具链和make工具（但会操作简单点，自动生成Makefile）   二、ReDe使用   1. 建立工程   Reworks的项目是建立在一个拥有系统镜像的自引导工程之上的。   一般的，在项目文件中建立一个自引导工程和多个可下载工程和库工程。通过自引导工程引用别的工程的内容，将所有的文件写入elf的系统镜像之中。   也可以在运行好的Reworks系统上通过库工程L和可下载工程D动态的加卸载.o和.a文件。           自引导工程B： 生成可以直接在目标机上运行的目标代码。编译生成.bin和.elf文件。            库工程L: 生成可以被其他库引用的库文件。编译生成.a文件。            可下载工程D: 生成可以下载到目标机运行的文件。编译生成.o和.out文件。            BSP工程: 该工程提供了BSP工程建立、代码模板自动导入、BSP库构建与ReWorks自引导工程一体化调试、BSP资源组建配置与发布等功能。            自定义工程： 允许用户自定义包括makefile的工程。            资源组件工程： 对工程的一系列属性进行了配置。可在自引导工程、库工程、可下载工程的资源配置模块中应用。（资源配置模块就是资源组件工程？是的）            目标板资源工程：定义在目标系统上运行所需的最低资源集合       2. 配置系统资源   出于嵌入式系统的特性考虑（功耗、资源、性能、价格等…），需要对完整的系统根据需求进行定制裁剪。根据具体的调试和应用需要，各异的设置开发板上所需的系统资源。   ReDe中可以直接在.syscfg中勾选保存所需的功能。具体功能需要那些系统资源请看各自功能的文档。   常用的资源配置：   板级支持包–网卡驱动、控制台配置   开发和运行支持–运行时工具–任务调试支持   3. 构建工程   对工程中的文件进行编译，自引导工程、库工程、可下载工程具有默认的构建配置（自动生成的makefile) 。可以在工程属性中管理自动生成的makefile和make指令。   连接可下载/库工程到自引导工程（系统调试）：   右键–属性–C++构建–设置–GCC C++ linker–杂项–附加对象文件–选择   为项目添加依赖（先构建依赖）：   右键–属性–项目引用–选择   为make all 添加选项：   右键–属性–C/C++构建–构建器设置–去除勾选使用默认构建命令–添加选项。   例如：make -j10 all开启多线程编译。   4. 连接目标板   ReDe和开发板的Uboot通过USB串口和RJ45以太网接口连接。串口用于和开发板直接沟通配置Uboot。以太网接口用于进行FTP通信。   此时还没有拷贝镜像！更没有启动系统！和系统资源配置没关系！只是在和U-Boot交互   FTP方式下载系统镜像：      注意：网卡需要设置的IP地址。这次用的192.168.1.110，取决于板上写入的服务器地址（uboot tftp配置的地址，可以更改）     setenv ipaddr 192.168.1.1 setenv serverip 192.168.1.31 saveenv            更改前本机的ip地址，软件平台室服务器。    USB串口设置：左上角选择终端打开设备管理器选择对应的COM号，设置端口速度为115200。（这是USB连接的线用来和uboot的引导程序命令行进行交互）运行过程中不断敲击回车键（保证能中断他的自动引导，其实一下好像就行）   TFTP服务器设置：   右键存在需下载文件的项目目录–设置TFTP路径   或   打开窗口–显示视图–TFTP服务–启动TFTP 服务（依然是上次设置的路径）   5. Uboot启动系统镜像   在串口界面输入命令： tftpboot 0x80100000 reworks 使用TFTP服务从服务器获得reworks.elf放到地址0x80100000   go 0x80100000 从地址运行系统，进行uboot，启动reworks系统镜像      地址是根据不同开发板而不同的。    6. 调试   6.1 系统调试（本地调试）：   .o文件跟随系统镜像写入开发板。参见在自引导工程中引用可下载工程的.o文件部分。直接烧入镜像进行测试。      在自引导工程中引用可下载工程的.o文件：     右键属性–c++构建–设置–c++linker–杂项–附加对象文件–输入命令“${workspace_loc:/projectName/gnuXXX/boardName/projectName.out}”    6.2 任务调试（远程调试）：   .o文件在系统启动以后在写入并加载。首先需要通过TFTP等方式拷贝系统镜像，使用Uboot启动系统。使用的是GNU GDB工具进行测试。   0、系统资源配置：   运行时工具–任务调试支持、协同总线组件、远程接卸载 和 板级支持包–网卡驱动   1、运行系统镜像：   勾选任务调试支持后系统会暂停于usrInit处。   2、连接目标机：   左下角目标机系统管理器，第一个图标：添加连接。   目标机名填写系统资源配置中网卡的IP(和TFTP中的IP并不一定相同)      U-boot和Reworks是两个不同的系统。U-boot是引导系统的系统。     有bug，必须更改一次ip地址才可以使用！    3、调试配置：   右键项目–调试–调试配置–自引导应用程序–程序   右键项目–调试–调试配置–自引导应用程序–目标机   4、开始调试：   等同于GNU GDB，略   6.3 远程加卸载：   对非核心的.o文件在系统中动态的加载或者卸载。实质是把.out文件下载到 /clb/dynamicModuleFolder/路径下，然后运行ld unld指令,然后删除可执行文件。等价于TFTP获取文件+加载模块+删除文件。   与直接镜像link然后构建写入镜像不同。直接写入镜像的模块无法卸载，在/clb/dynamicModuleFolder/路径下没有.out文件      TFTP命令     tftp (\"ip\", \"path/remotefile\", \"get/put\",“ascii/netascii/binary/image/octet”, \"path/localfile\")     符号表命令     ld 加载.out/.o文件     unld 卸载已加载的.out/.o文件     unld_by_module_name 通过模块名称卸载已加载的.out/.o文件     unld_by_module_id 通过模块ID卸载已加载的.out/.o文件     reld 重新加载.out/.o文件     module_info 显示已加载的.out/.o文件     symbol_lkup 查找指定的符号信息     lkup 显示包括指定名称的所有符号信息    0、系统资源配置： 远程加卸载、符号表、网卡   1、目标及启动系统： 略   2、连接目标机： 略   3、加卸载： 左上角加载–加载配置–设置目标机、动态加载   4、符号表同步： 何意？   6.4 仿真调试：Qumu   CH 2—系统命令行Shell   一、Shell介绍   1.1 Reworks Shell命令   i   oi   stackuse   cpuuse   1.2 反汇编   在软件运行过程中只要有shell线程工作就可以使用pthread_show_stackframe命令获得任务运行的堆栈，再使用arrch64-objdump-elf -C -x -S可以查看反汇编的.elf源码，方便进行调试。   任务堆栈：   pthread_show_stackframe   objdump反汇编工具：  ","categories": ["笔记"],
        "tags": ["Reworks","RTOS"],
        "url": "/%E7%AC%94%E8%AE%B0/%E9%94%90%E5%8D%8E%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",
        "teaser": null
      },{
        "title": "Cmake笔记",
        "excerpt":"Cmake笔记   一、 Cmake介绍   Cmake是一种与平台无关的自动控制项目编译过程的工具（自动生成makefile文档）。只需要配置CMakeList.txt就可以自动的根据平台生成Makefile，方便的跨越多个平台进行编译。      CMakeList.txt注意大小写和s不然识别不成功    Cmake说明文档   cmake是什么？cmake的特性和编译原理（cmake原理和cmake编译过程）   【C++】Cmake使用教程（看这一篇就够了）-CSDN博客      不是已经有了makefile去实现编译控制，为什么还需要Cmake?     Maybe:控制编译的对象范围不同？     Answer:Cmake为了方便的自动生成可以跨平台的makefile，直接写makefile可以实现但是复杂。最重要的，Makefile不像人读的。    二、 Cmake的常用语法   一般的，Cmake的编写分为几个部分：初始化、   1. 初始化：   添加cmake版本要求, 添加project名称和版本号   cmake_minimum_required (VERSION 2.8) project (project_name VERSION 1.0)   2. 设置头文件路径：   指定头文件搜索路径：   include_directories (test_func test_func1)   3. 添加编译选项：   add_compile_options(-std=c++11 -Wall)    或者使用set设置变量CMAKE_CXX_FLAGS或CMAKE_C_FLAGS   set(CMAKE_CXX_FLAGS \"-Wall\")   4. 编译可执行文件：   4.1 直接编译.c文件   add_executable(main main.c testFunc.c)   4.2 将目录中的所有源文件存在变量中      一般的，Cmake中变量名称使用大写字符表示，${VAR}取出变量的值    aux_source_directory(. SRC_LIST) add_executable(main ${SRC_LIST})   4.3 设置二进制文件的输出位置：   set (EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)      还可以使用SET_TARGET_PROPERTIES设置单个编译对象的输出路径，路径更精细。设置输出路径的颗粒度可以精细到每个编译的对象    5. 编译库文件：   5.1 编译源代码归档成动态库（SHARED）或静态库(STATIC)   add_library (libname SHARED ${SRC_LIST}) add_library (libname STATIC ${SRC_LIST})   5.2 设置最终生成的库的名字   set_target_properties (libname PROPERTIES OUTPUT_NAME \"libname \")   5.3 设置库的输出路径   set (LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)      同样可以使用SET_TARGET_PROPERTIES设置输出路径    6. 链接库：   6.1 在路径下查找库并把绝对路径存放在变量中   find_library(LIB_PATH libname HINTS ${PROJECT_SOURCE_DIR}/lib)   6.2 链接目标文件和库文件   target_link_libraries (target_file ${LIB_PATH})   7. 添加编译子目录（可选）：   add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])           source_dir 源代码目录 指定一个具有cmakelist和源代码的目录，将其作为编译的子目录            binary_dir 二进制代码目录 指定cmake输出的二进制文件所在的目录            EXCLUDE_FROM_ALL标记 指定将添加的子目录从make all 中移除          添加编译子目录是为了让源码的编译结构更加清晰，可以更好的使用选项管理编译过程。新的目录路径下建立一个新的CMakeLists。    8. 安装规则（可选）：   在编译完成之后，可以使用以下命令将编译好的源文件、头文件、测试用例等资源安装到Cmake指定的位置。   make install   8.1 安装动态库   install(TARGETS mylib     LIBRARY DESTINATION lib )   8.2 安装可执行文件   install(TARGETS test_mylib     RUNTIME DESTINATION bin )   8.3 安装头文件   install(FILES myheader.h     DESTINATION include )   9. 测试（可选）   CMake 提供了内建的测试功能，可以帮助开发者验证项目是否正确构建以及是否通过了各种测试。CMake 的测试功能依赖于 CTest，这是一个 CMake 的测试驱动工具，通常用于执行项目中的单元测试、集成测试等。以下是关于 CMake 测试的主要概念和使用方法。   9.1 启用测试   要启用 CMake 测试功能，首先需要在 CMakeLists.txt 文件中调用 enable_testing()。这将启用 ctest 测试命令。一旦启用测试，您就可以通过 add_test() 命令定义具体的测试。   enable_testing()   9.2 添加测试   使用 add_test() 命令来定义测试。该命令接受两个参数：测试名称和要执行的命令。   add_test(NAME MyTest COMMAND MyExecutable)   这个命令将会添加一个名为 MyTest 的测试，它会运行 MyExecutable 可执行文件。如果 MyExecutable 执行成功，测试将通过。   9.3 测试命令的参数   在 add_test() 命令中，您可以传递多个参数，供测试命令使用。例如，如果您的程序需要一些命令行参数，您可以这样做：   add_test(NAME TestWithArguments COMMAND MyExecutable arg1 arg2)   这样在运行测试时，MyExecutable 将以 arg1 和 arg2 作为参数执行。   9.4 测试期望的返回值   默认情况下，CMake 假定测试程序成功执行时返回 0，如果返回非 0 值，则认为测试失败。如果您的测试需要特定的返回值来表示成功，可以使用 add_test() 的第三个参数指定期望的返回值：   add_test(NAME TestWithExpectedReturnValue COMMAND MyExecutable) set_tests_properties(TestWithExpectedReturnValue PROPERTIES WILL_FAIL TRUE)   9.5 测试输出   CTest 会捕获测试的标准输出（stdout）和标准错误（stderr）。如果您希望在测试中检查输出内容，可以使用 add_test() 的 –output-on-failure 标志来显示失败的输出。   ctest --output-on-failure   这样，如果测试失败，你将看到每个失败测试的详细输出。   9.6 测试属性   使用 set_tests_properties() 可以设置测试的额外属性。例如，您可以将某个测试标记为“预期失败”（WILL_FAIL），或者设置测试的超时时间（TIMEOUT）等。   set_tests_properties(MyTest PROPERTIES TIMEOUT 30) set_tests_properties(MyTest PROPERTIES WILL_FAIL TRUE)      TIMEOUT：指定测试的超时时间（以秒为单位）。如果测试在此时间内没有结束，将被视为失败。   WILL_FAIL：标记该测试为预期失败。   10.Cmake其他操作   10.1 文件操作file   file MAKE_DIRECTORY path/to/directory)   10.2 判断语句 if   10.3 循环语句 foreach   foreach(ITEM ${LIST})     dosomething endforeach()   10.4 设置目标属性 SET_TARGET_PROPERTIES   SET_TARGET_PROPERTIES是 CMake 中的一个重要指令，用于设置目标（target）的各种属性，这里的目标可以是库（静态库、动态库），也可以是可执行文件。其基本语法如下：   SET_TARGET_PROPERTIES(target1 target2... PROPERTIES     property1 value1     property2 value2    ... )   常见属性及用途：           ARCHIVE_OUTPUT_DIRECTORY： 设置静态库的输出目录。例如：       SET_TARGET_PROPERTIES(mylib PROPERTIES ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib )           这会将名为 mylib 的静态库输出到${CMAKE_BINARY_DIR}/lib目录下。            LIBRARY_OUTPUT_DIRECTORY： 用于指定动态库的输出目录，用法和静态库类似：       SET_TARGET_PROPERTIES(mylib PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib )                RUNTIME_OUTPUT_DIRECTORY： 设定可执行文件的输出目录。比如：       SET_TARGET_PROPERTIES(myapp PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin )                POSITION_INDEPENDENT_CODE： 对于生成动态库或者希望被动态链接的目标很有用，设置为 ON 表示生成位置无关代码（PIC）。这是共享库编译时的常见需求，因为共享库需要能被加载到内存的不同位置，代码必须是位置无关的：       SET_TARGET_PROPERTIES(mylib PROPERTIES POSITION_INDEPENDENT_CODE ON )                INSTALL_RPATH： 正如前面提到的，和运行时库路径相关，用于设置安装后的可执行文件搜索动态库的路径。”$ORIGIN” 是一个常用值，表示可执行文件所在目录：       SET_TARGET_PROPERTIES(test_mylib PROPERTIES INSTALL_RPATH \"$ORIGIN\" )                INTERFACE_INCLUDE_DIRECTORIES： 在创建库时，用于指定库的使用者需要包含的头文件目录，方便其他项目链接该库时能正确找到头文件：       SET_TARGET_PROPERTIES(mylib PROPERTIES INTERFACE_INCLUDE_DIRECTORIES ${CMAKE_CURRENT_SOURCE_DIR}/include )           三、Cmake使用   使用cmakelist宏变量和make的命令选项显示make的详细内容   cmake -DCMAKE_VERBOSE_MAKEFILE=ON .. make VERBOSE=1  ","categories": ["笔记"],
        "tags": ["Cmake"],
        "url": "/%E7%AC%94%E8%AE%B0/Cmake%E7%AC%94%E8%AE%B0/",
        "teaser": null
      },{
        "title": "Gdb",
        "excerpt":"GDB（GNU Debugger）是一款强大的调试工具，主要用于调试 C、C++ 和其他编程语言编写的程序。以下是 GDB 的使用方法：   一、启动 GDB           编译程序时加上调试信息              在编译程序时，使用 -g 选项可以让编译器生成调试信息，以便 GDB 能够更好地进行调试。例如，对于 C 程序，可以使用以下命令进行编译：gcc -g program.c -o program。对于 C++ 程序，可以使用：g++ -g program.cpp -o program。                启动 GDB              启动 GDB 并加载要调试的程序。在命令行中输入 gdb program，其中 program 是要调试的程序的名称。           二、基本命令           run（或 r）              运行程序。在 GDB 中输入 run 命令后，程序将开始执行。如果程序需要命令行参数，可以在 run 命令后面加上参数，例如：run arg1 arg2。                break（或 b）              设置断点。可以在程序的特定行号、函数名或地址处设置断点。例如，要在第 10 行设置断点，可以输入 break 10。要在名为 main 的函数处设置断点，可以输入 break main。                next（或 n）              执行下一行代码，但不进入函数内部。                step（或 s）              执行下一行代码，如果是函数调用，则进入函数内部。                continue（或 c）              继续执行程序，直到遇到下一个断点或程序结束。                print（或 p）              打印变量的值。例如，要打印变量 x 的值，可以输入 print x。                backtrace（或 bt）              打印调用栈信息，显示当前程序的执行路径。                quit（或 q）              退出 GDB。           三、查看变量和内存           info locals              显示当前函数的局部变量及其值。                info args              显示当前函数的参数及其值。                x /&lt;format&gt; &lt;address&gt;              检查内存地址处的值。&lt;format&gt; 可以是不同的格式说明符，例如 x/d 表示以十进制格式显示整数，x/s 表示以字符串格式显示内存内容。           四、条件断点   可以设置条件断点，只有当满足特定条件时，断点才会生效。例如，要在变量 x 等于 10 时才中断程序，可以输入 break 10 if x == 10。   五、多线程调试           info threads              显示当前程序中的所有线程。                thread &lt;thread-id&gt;              切换到指定的线程进行调试。           六、远程调试   可以使用 GDB 进行远程调试，例如调试在另一台机器上运行的程序。这通常需要在目标机器上运行一个调试服务器，并在本地使用 GDB 连接到该服务器。  ","categories": ["笔记"],
        "tags": ["GDB"],
        "url": "/%E7%AC%94%E8%AE%B0/GDB/",
        "teaser": null
      },{
        "title": "基于jekyll和github page的个人主页搭建经验",
        "excerpt":"基于Jekyll和Github Page的个人主页搭建经验   一、方案选择   大体上讲，搭建个人网站有几种常见的方案技术路线。一种是分为前端和后端，使用web服务器处理web请求的通用网页方案；另一种是使用静态网页生成器将所有网页内容预先生成为静态文件（如 HTML、CSS、JavaScript），然后部署到静态网页托管平台上。   前者是web网页的一般方法，由前端和后端两部分组成。前端负责提供网页的结构、布局和交互等可视化的直接和用户接触的部分，后端负责处理请求的业务逻辑、数据存储和安全性等涉及服务器端的部分。           前端的核心是HTML、CSS、JavaScript三个部分，分别对应了网页的结构、布局和交互处理。除此以外，还有其他基于JavaScript的前端的框架（如 React、Vue.js、Angular）用来简化网页交互的编写。            后端的核心是Web服务器、后端框架和数据库。              Web服务器主要用于连接用户的网页请求和用于处理请求的服务器。具体来说：主要负责处理用户HTTP/HTTPS请求、对后端的服务器进行反向代理和负载均衡。       后端框架则主要用于处理业务逻辑，负责对web服务器代理后的请求进行处理。常见的后端框架有：Python的Django,和Flask、JavaScript的Node.js、Java的Spring等。       数据库则是十分明了的用于存储和管理数据。常见的数据库包括：MySQL、Oracle（关系型数据库）、MongoDB、Redis（非关系型数据库）。           后者是用于生成静态网页的方法，即使用静态网页生成器（如Jekyll、Hugo、Hexo等）预先生成好网页，将之存为不需要服务器端处理的文件（如HTML、CSS、JavaScript）。静态网页可以直接使用静态网页托管平台直接进行部署，如Github Pages、Vercel、Netlify等。   动态网页的灵活性更高，可以处理更多的交互需求，但是需要服务器端的支持，部署较为复杂，需要额外的服务器;静态网页的灵活性较差，但是部署简单，可以直接使用Github Page进行部署（还省去了配置公网IP和网页备案的麻烦）。对比两种方案，静态网页的方案适合个人主页低更新频率，交互性较弱的应用需求。   因此，我最后选择了静态网页的方案，使用Jekyll的Minimal Mistakes主题和Github Pages静态网页托管平台组合的方案搭建了自己的个人主页。   首先，我在运行了ubuntu的虚拟机上下载Jekyll和其所需要的环境。然后，根据自己的使用需要，按照MInimal Mistakes的文档说明修改了_config.yml配置文件，调整了个人主页的一些常用设置。最后使用Github Page的部署功能来部署整个网页。      PS.除了使用模板以外，也可以根据自己需要的格式修改_layout文件夹中的模板。添加自己想要的内容。    二、Jekyll和Minimal Mistakes主题   Jekyll是一个基于 Ruby 语言开发的开源静态网页生成器。其核心原理是将包含文本内容（如 Markdown 文件）、布局模板（如 HTML 模板）和配置文件（如_config.yml）的源文件目录，通过一系列的转换和处理，生成最终的静态网站（HTML、CSS、JavaScript 等文件的集合）。Minimal Mistakes是一个Jekyll的主题，提供了丰富的功能和灵活的配置选项，可以方便地设置美观的网页的布局和样式。   1.部署Jekyll环境   这一步其实来说并不是必要的，只是在本地拥有可以使用Jekyll构建网页的环境对于修改个人主页的一些功能来说会更加的方便。你也不想每次对网页布局之类的细微修改的尝试都要push到github上然后重新等待他慢慢的生成网页吧，这实在是太麻烦了。   首先你需要确保的是你拥有一个Linux的虚拟机环境，不管是VMware或者WSL都可以。我使用的是WSL，可以直接在VScode中使用。非常的方便，用过都说豪用。具体怎么弄我这里就不赘述了，网上有很多教程。           安装 Ruby：       Jekyll 是基于 Ruby 构建的，所以首先需要安装 Ruby。通过以下命令安装 Ruby：       sudo apt - get update     sudo apt - get install ruby - full                安装 Jekyll 和 Bundler（RubyGems 包管理器）：       在安装好 Ruby 后，可以使用 RubyGems 来安装 Jekyll 和 Bundler。在终端（命令提示符或 PowerShell）中输入以下命令：       gem install jekyll bundler                创建项目       a. 新创建项目       jekyll new .           b. 从原有的模板复制一个项目       最简单的方法就是直接使用git clone直接复制这个项目的文件下来。        git clone https://github.com/HONEST-ZH/HONEST-ZH.github.io.git                修改网页       修改_config.yml或者_layout里的布局文件来达到你满意的网页效果。            本地运行尝试       执行以下命令来运行本地运行jekyll网页的服务器，工作的ip地址是127.0.0.1:4000       bundle install bundle exec jekyll serve                重复4-5直到网页满足你的需求。       三、设置Github Page   对于一般的静态网页而言，我们只需要将jekyll项目提交到名为username.github.io的仓库中（名字需要和github的账户名字一致，否则会无效），然后再选择Settings-Pages-Deploy From a Branch，branch-main。完成设置以后，就可以实现静态网页的部署了，Github会在Action中自动新建一个名为pages-build-deployment的工作流，每次选定的分支（main）上发生推送时会自动地构建和部署网页。      但是这里因为我使用了Minimal Mistakes模板的原因，网页是没有办法使用这种方法的直接生成的。网页在编译时会报错，找不到模板的Gem包。         这是因为默认的pages-build-deployment工作流没有去下载所需要的依赖，而缺少了Jekyll模板。解决这个问题的方法也很简单，就是自己创建一个工作流保证每一次都能把所需要的依赖装好。   1. 创建gh-pages.yml工作流文件   在项目的根目录下创建.github/workflows文件夹然后添加gh-pages.yml文件。   mkdir -p .github/workflows touch .github/workflows/gh-pages.yml   2. 编写gh-pages.yml   在gh-pages.yml文件中写入：   name: GitHub Pages on:   push:     branches:       - main  # 监听的分支 jobs:   build:     runs-on: ubuntu-latest     steps:     - uses: actions/checkout@v2     - name: Set up Ruby       uses: actions/setup-ruby@v1       with:         ruby-version: '3.2'  # 确保使用正确的 Ruby 版本     - name: Install dependencies       run: bundle install     - name: Build the site       run: bundle exec jekyll build     - name: Deploy to GitHub Pages       uses: peaceiris/actions-gh-pages@v3       with:         github_token: $         publish_dir: ./_site   这个工作流在每次检测到main分支上有推送时：下载所需要的Gem包依赖，构建静态网页，将静态网页的文件推送到一个专门用于存储静态网页的分支gh-pages。   3. Github pages从gh-pages分支部署   gh-pages分支被更新后，还没有完成网页的部署。此时需要把github page关注的分支换为gh-pages，根据每次推送到gh-pages上的文件部署静态网页。工作流的结果显示如下图所示，此时就可以在username.github.io中访问个人主页的页面了。      四、网页的使用   1.基本FrontMatter   ---  title: \"文章标题\"  date: 2023-10-20  last_modified_at: 2023-10-21    # 最后修改时间  categories:    - 技术    - ZMQ  tags:    - 消息队列    - 网络编程  toc: true                       # 显示目录  toc_sticky: true               # 固定目录  toc_label: \"目录\"              # 目录标题  toc_icon: \"cog\"               # 目录图标  #图片  header:    image: /assets/images/header.jpg           # 头部大图    teaser: /assets/images/teaser-image.jpg    # 预览图    overlay_image: /assets/images/banner.jpg   # 覆盖图    overlay_color: \"#333\"                      # 覆盖颜色    caption: \"图片来源: [**网站**](链接)\"      # 图片说明    excerpt: \"这是文章摘要，将显示在文章列表中\"    # 文章摘要  # 作者相关  author: Your Name  author_profile: true    # 显示作者信息  # 布局相关  layout: single  classes: wide          # 宽屏显示  # 评论相关  comments: true        # 启用评论  share: true           # 显示分享按钮  # 相关文章  related: true         # 显示相关文章  # 阅读时间  read_time: true       # 显示预计阅读时间  # 导航  sidebar:    nav: \"main\"        # 侧边栏导航  # SEO相关  description: \"这是一段用于SEO的描述\"  keywords: \"关键词1, 关键词2\"  ---   2.AI工具生成顶部配图   使用ChatGPT生成提示词，然后使用DALLE-3生成图片     提示词应该具有的结构：         主题描述 描述主要场景或元素，让 AI 理解你想要生成的内容是什么。     细节补充 包括场景的颜色、灯光、材质等信息，增加细节丰富度。 *情感与氛围 指定图像的情感和氛围，如“宁静”、“温暖”、“科幻感”等。     视觉风格 选择一种视觉呈现方式，如“水彩画风格”、“数字艺术”、“摄影级真实感”等。     构图与比例 提到图像的布局与比例，如“宽屏横向构图”、“16:9比例”。     特定要求（可选） 如果需要特别的元素，比如“背景模糊”或“有特定的道具”，也可以写明。      例如： 提示词为  A breathtaking sunset over a calm ocean,  with soft waves reflecting the warm orange and pink hues of the sky, a few scattered clouds, and silhouetted palm trees framing the scene. Cinematic wide-angle composition, 16:9 aspect ratio, high detail, serene and peaceful mood, digital painting style，1200px width  生成的图像为    3.Markdown文档编写   使用Marktext以方便的编写MarkDown笔记，可以直接粘贴图片。图片可能被以网络链接的方式引用，也可能保存在本地的C:\\Users\\HONEST\\AppData\\Roaming\\marktext\\images\\路径下，需要把图片的路径改成/assets/images/blog_header或者/assets/images/blog     linux路径使用/，windows路径使用  要在使用jekyll构建好的网页之间进行链接的跳转，需要使用网页的永久链接跳转。手动输入[](/url)或者使用liquid的link标识获得文件的路径[](\\{\\% link path/to/file \\%\\}) 手动输入URL时需要注意：1. 空格使用-代替 2.跳转的博客最后不带文件名,不带开头的日期 最简单的方法，从想要链接到的博客的浏览器抬头处复制URL 使用link标识时需要注意 1.开头的第一个文件没有 / 2. 使用空格取代%20 最简单的方法，复制想要链接到的博客的文件路径然后修改（大部分博客名称应该没有空格，注意\\和/）   ","categories": ["笔记"],
        "tags": ["Github","Github Pages","Jekyll","个人主页"],
        "url": "/%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EJekyll%E5%92%8CGithub-Page%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E6%90%AD%E5%BB%BA%E7%BB%8F%E9%AA%8C/",
        "teaser": null
      },{
        "title": "白色相簿2",
        "excerpt":"  白色相簿什么的已经无所谓了， 因为已经不再有歌，值得去唱了。 传达不了的恋情已经不需要了， 因为已经不再有人，值得去爱了。   前言            Your browser does not support the audio element.   不知不觉间，又到了白色相簿的季节。在第一次看动画，因为冬马雪菜春希三人的纠结关系胃疼时，我就早已有所耳闻了——游戏的CC和Coda部分才是白色相簿2的精华。但是直到多年后的今天，在通关了这款被称为“脱宅神作”的Galgame以后的此时此刻，我才明白我曾经错过了怎样优秀的作品，我才后悔为何没能更早的玩到他。   白色相簿整个故事的悲剧性就来源于IC时三人在青春期犯下的错误。相对的，CC讲述了春雪两人挣扎而痛苦的成长，到了Coda则是两种不同恋爱观念的选择。   -Introductory Chapter-     命运的开始,无法挽回的青春   为自己循规蹈矩的人生而不甘的，如同教科书一般的努力、负责、热心肠的模范三好学生北原春希，想为自己的青春留下最后的回忆。至少要任性一次、至少要装帅一次，这样想着的春希加入了好兄弟饭冢武也的轻音乐部，期望着能在学院祭的舞台上大展手脚。尽管只是一个作为吉他候补的拙劣新手，春希也对能够真正参与到“青春”之中而满足。然而，轻音乐部因为坏女人主唱柳原朋而人际关系破裂，整个社团分崩离析，只剩下了武也和春希。仅有两个吉他手无疑是无法构成乐队的，武也自然的放弃了在学院祭上演出的计划。只剩下不甘心的北原春希在第三音乐室里独自弹着吉他，为了无谓的目标而努力。   非要压抑的度过这一段人生了吗？只能把压抑了17年的情感继续压抑下去了吗？只能继续做一个古板、婆婆妈妈的前班长和兢兢业业的做题家了吗？在人生中本该最绚丽的、最青春的时间段…   伴着隔壁第二音乐室里与他共奏的钢琴，春希这样想着，依然盲目而执拗的练习。命运本该就这样结束——他将不得不放弃让自己最后闪耀的机会，徒劳的看着青春从琴头的指尖逝去。直到那一天到来、直到改变了一切的合奏开始、直到《White Album》命运的歌声响起，实现他愿望的天使降临了——小木曾雪菜。      春希听到了天籁，更看到了天使——啊，我的青春就该是这样的！让她加入轻音乐部吧！为了我贫瘠了17年的青春，为了我压抑了17年的心，为了学院祭最后的绽放，稍微任性一些也无妨吧！   此时的春希不知道的是，在隔壁的音乐教室与他合奏钢琴的正是他早已暗生情愫的同桌——冬马和纱。他更不会知道的是，和纱也早就喜欢上了他     梦里不觉秋意深，余情岂是为他人       从这一首共演的《White Album》开始，三人命定一般的故事开始了。     白色相簿2的IC章节是没有选项的，在我的理解里这是丸户刻意制造的局面。在故事的早期，只要做出一点很小的选择就足以改变春冬雪三人这种复杂的感情局面。但是从故事的角度来说，这样子无疑会让整个故事变得乏善可陈，落入寻常的Galgame的窠臼。丸户在IC想要体现的其实是无法挽回的、伤害和被伤害已经成为既定事实的青春。   在青春里，你因为不懂女人心而错过了你最喜欢也最喜欢你的人；在青春里，你因为自卑和傲娇永远无法把心中的话说给最希望听的人；在青春里，你因为慌乱和懵懂的喜欢而抢先出手拿下了挚友也喜欢的男孩；在青春里，并不成熟三人笨拙的相处、青涩的相恋，然后又因为这份笨拙和青涩相互伤害——直到一人逃避远走，三人的故事变为两人与一人。   北原春希   春希的本质实际上是一个善良的努力者，通俗一点的说是好心的做题家。他对于条条框框的规矩格外遵守，坚信努力就有回报，在过去的人生里一直压抑自己的青春换来秀才的名声，近乎偏执的执着于帮助他人，让人怀疑是否是具有白骑士情节。但是在另一面被这些形象所隐藏的，春希是一个无比渴望精彩热烈的校园生活，也无比渴望爱情的人。他是古板的班长，是兢兢业业努力的好学生，是乐于助人的里之委员长；他更是普通的高中生，是血气方刚的男孩，是懵懂的青春期少年。这种想法春希其实并不是到了临近毕业的高三才突然出现的，而是一直伴随在他尽力压抑的校园生活中的（实际上春希的欲望十分强烈，此事在雪菜TE亦有记载）。   加入轻音乐部、练习吉他、想要参加校园祭留下完美的青春回忆，这是春希最开始也最强烈的心愿。最开始他不曾幻想也不敢幻想自己竟然能拥有这样热烈而跌宕的青春。他只是执拗的坚持自己的梦想，不断地向前努力，命运的巧合和作弄就将春冬雪三人的线团紧紧的纠缠在一起。   他喜欢冬马，也喜欢雪菜（应该没有人能够不喜欢）。如果非要权衡，因为喜欢冬马的时间更长一些、所以更喜欢冬马一些。但是他不知道冬马也喜欢着自己，而且时哪样的喜欢自己，更觉得自己不配冬马喜欢但是冬马也是这么想的。所以在心满意足的学院祭后，面对雪菜的热情表白，他毫无抵抗能力的接受了。   在表白后的第一时间里，春希就找到了冬马和她说明了情况——自己和雪菜交往了，是我告白的。我曾经喜欢你，但是我选择了雪菜，抱歉——春希心中一定是这么想的吧。在之后的故事里，三人一起日常相处，和谐的背后隐藏着酝酿的爆发。冬马努力扮演夹在中间的好友身份却又痛苦不已。春希逐渐知道自己心中还喜欢着冬马，并努力地想要忘却她。他尽力地想扮演好雪菜地男友的角色，想要在雪菜的生日用带有雪菜名字的戒指推进关系，将两人紧紧绑在一起。雪菜尽力克制自己和春希在冬马面前的互动，想要维护三人共同好友的情景一直持续下去。   然而这种做法本身就是不对的，三人之间的话依然和最开始一样没有说开；春冬二人的心意没能相通；雪菜也因为自己的所作所为而陷入了深深的自责。如果春希在找冬马的时候就能大方的好好告诉她自己喜欢她，如果在三人相处逐渐意识到自己仍有对冬马的喜欢之后春希就和雪菜坦白一切，或许三人都会更幸福吧。   当春希知道冬马刚刚通过考验回国，即将远走欧洲留学时，努力压抑的感情爆发了。他爽约了雪菜的生日派对，跑到了机场迎接冬马。这是最重要的，最大的背叛，代表着春希的心向着与雪菜相反的方向前进。雪菜其实也和春希一样，为了推进二人的关系早已做好了准备，在圣诞夜这天支开了家人。此时如果两人能够心意相通知道对方想法的话，结果或许会不一样吧。只要春希叫上雪菜一起寻找冬马，见面的两人一定会互相吐露内心吧。但是春希鸽掉生日的原因其实是两部分组成的，一部分是对于自己和雪菜关系推进太快的惶恐，对关系进一步发展的巨大责任的逃避，另一部分是竭力让自己忘记冬马然后突然得知以后无法相见的痛苦和这么重要的事情冬马却一直不告诉自己的不甘。   落雪纷纷而下，冻结的心相互碰撞，在熟练街上，春希和冬马互相吐露了心声。春希终于意识到了自己是多么不懂女人心的愚钝的男人、冬马也终于意识到春希也喜欢着自己只是因为自卑而退缩了。如火山爆发般压抑不住的情绪让春希强吻了冬马，但是就连熟练的亲吻本身都是春雪二人关系的铁证——冬马再次崩溃选择了逃离。   无助的春希想雪菜求助，却又没有勇气说出实话，只能对雪菜撒谎。  小木曾雪菜   在IC的故事中，小木曾雪菜从未掩饰自己对春希的喜欢。最开始总是拒绝，然后总是被春希打动改变主意。春希为在天台上高歌的小木曾雪菜而倾倒，按捺不住心中的躁动，主动邀请了雪菜参加学院祭的演出。然而早就因为自己超群的名声而深深苦恼的雪菜，并不想在大众面前抛头颅面，拒绝了春希的请求——一如之前一开始拒绝参与峰城大附属小姐一样。为了让雪菜加入，春希直接找到了雪菜打工的地方，见识到了雪菜高岭之花外表下亲切、平易近人、有些虚荣又逞强的一面。      这样一来，小木曾雪菜的秘密，就一个不剩了呢。因为，全部都被你知道了呢。       在春希的努力之下，雪菜改变了之前的想法——一如之前后来又改变主意决定参与峰城大附属小姐一样。而这两次转变的原因毫无疑问就是雪菜对春希的好感和喜欢。   冬马和纱  冬马一开始很好的扮演了恋人的好友的角色，但是她实在是按捺不住对春希的喜欢，在这样的三人行游戏里倍感痛苦。  -Closing Chapter-    背叛的刺深植，无法前进更无法后退的二人    为什么，为什么会变成现在这样子呢？你无数次的想，但是伤害已经造成，青春已经过去。或许比起那时现在的你有了更多成长，再来一次或许会有不同的选择，但事实的伤口早已横亘在心间，时针永不回转。现在能做的事情只有拼命的补救，纵然身心俱疲、纵然遍体鳞伤，这也是弥补过去的错误的唯一的方法。逃避或者心照不宣的隐瞒或许能得到一时的轻松，但是背叛的利刺将一直插在二人的心间——无论进退都只会带来更大的痛苦。唯一的方法是咬着牙坚强的面对它，无论多么痛苦也要携手将其拔除。当二人痛苦而幸福的紧紧相拥时，结痂的血液才会将二人相连，彼此的血才能愈合对方的伤口。   -Coda-  ","categories": ["随笔"],
        "tags": ["Galgame"],
        "url": "/%E9%9A%8F%E7%AC%94/%E7%99%BD%E8%89%B2%E7%9B%B8%E7%B0%BF2/",
        "teaser": null
      },{
        "title": "Cmake出来的可执行文件找不到库文件",
        "excerpt":"问题描述   项目中使用Cmake自动化构建，首先将源码生成动态库，然后编译测试用例，最后把编译好的动态库和测试例都转移到输出目录中方便部署。 出现的问题是输出目录中的测试用例可执行文件在运行时提示找不到对应的动态库，需要手动设置LD_LIBRARY_PATH   解决方法  使用 rpath 选项和make install   在 CMakeLists.txt 中添加链接选项：在生成可执行文件（测试用例）的 add_executable 和 target_link_libraries 部分，通过 SET_TARGET_PROPERTIES 来设置 rpath。   示例如下：  # 生成动态库 add_library(mylib SHARED mylib.cpp)  # 生成测试用例可执行文件 add_executable(test_mylib test_mylib.cpp) target_link_libraries(test_mylib mylib)  # 设置 RPATH，假设动态库和可执行文件最终在同一输出目录下 SET_TARGET_PROPERTIES(test_mylib PROPERTIES     INSTALL_RPATH \"Path/of/mylib\" )  # 安装动态库 install(TARGETS mylib     LIBRARY DESTINATION lib )  # 安装可执行文件 install(TARGETS test_mylib     RUNTIME DESTINATION bin )  # 安装头文件 install(FILES myheader.h     DESTINATION include )  ","categories": ["问题"],
        "tags": ["Cmake"],
        "url": "/%E9%97%AE%E9%A2%98/Cmake%E5%87%BA%E6%9D%A5%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%BA%93%E6%96%87%E4%BB%B6/",
        "teaser": null
      },{
        "title": "Bash脚本win Linux之间的换行符问题",
        "excerpt":"问题描述   在嵌入式开发的过程当中，经常需要使用bash脚本进行批量的操作。编写bash脚本时，有时会出现报错，未找到xxx。使用Vi打开bash脚本以后发现在每行命令的行尾出现了^M这样的符号，导致指令未能被正确的识别和执行。   导致这种问题的原因是Windows和Linux系统下的换行符的不同。这种不同来源于传统电控打字机的兼容性带来的历史遗留问题。      \\r（Carriage Return，ASCII 码值为 13 ）：意思是 “回车”，起源于老式的打字机机械结构。打字机打印头在一行末尾打完字后，需要将整个打印托架移回本行开头的位置，为下一行的打字做准备，这个动作就叫 “回车” 。在电传打字机、早期计算机终端设备等场景下，当接收到\\r字符时，设备的光标或者打印头就会回到本行起始坐标处，准备后续输入或者输出。       \\n（Line Feed，ASCII 码值为 10）：意思是 “换行”，当电传打字机等设备接收到该字符时，会将纸张向上滚动一行，让打印位置垂直下移一行，这样后续内容就会打印到新的一行。Windows使用的换行符是\\r\\n,由两部分组成。    windows为了更好的兼容性同时使用了\\r\\n一起作为换行符，称为CRLF换行符。   Linux（等类unix系统）则秉持着最小化的哲学仅使用\\n，称为LF换行符。   Windows 风格换行符（CRLF，\\r\\n ）中的 “回车符（Carriage Return，ASCII 码值 13，对应 Ctrl + M，在文本显示中就呈现为^M ）” 。   解决方法          最简单直接的做法就是在IDE中直接设置好文件的换行符格式。例如，在vscode的右下角蓝色底部边框中可以修改文件的编码格式、换行符和缩进方式。            在linux系统下,一种方法是使用对应的工具包unix2dos或dos2unix,但是需要下载。       另一种方法是使用tr命令和管道相结合的方式修改文件中的换行符。  RF –&gt; CRLF      cat input.txt | tr '\\n' '\\t' | tr '\\t' '\\r\\n' &gt; output.txt          CRLF –&gt; LF       cat input.txt | tr '\\r\\n' '\\t' | tr '\\t' '\\n' &gt; output.txt           还有一种方法是使用vim的set fileformat命令进行设置  RF –&gt; CRLF      :set fileformat=dos  :wq          CRLF –&gt; LF       :set fileformat=unix  :wq          ","categories": ["问题"],
        "tags": ["Shell","Git","Vim"],
        "url": "/%E9%97%AE%E9%A2%98/bash%E8%84%9A%E6%9C%ACwin-linux%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98/",
        "teaser": null
      },{
        "title": "Git自动切换文件的换行符格式",
        "excerpt":"问题描述  在进行嵌入式编程的时候，首先在vscode上将已经写好的测试脚本shell提交到gitlab上，然后在测试的电脑上使用git clone获得测试例源码。使用scp/ftp等方式传输文件到运行了linux系统的开发板上，运行shell的测试脚本，依然出现了换行符的报错。第一时间想到的是bash换行符问题。   但是已经明确确认过vscode上向gitlab提交的源码使用的是LF的换行方式的情况下，依然有这个问题那么问题仅能出在git上。   答案是git上存在一个默认的设置选项autocrlf，pull拉取文件的时候会将文件的换行符自动切换为当前设备的换行符。这种方法一般而言是十分方便的，但是对于嵌入式开发来说带来了额外的问题。      本质上问题还是偷懒了，开发板一定会接win的电脑，需要xterm之类的串口，还需要通过网口和电脑测试。所以就没有连开发板和gitlab的服务器，结果出现了这种和平台相关的问题。    解决方法     嵌入式设备允许的情况下，在设备的linux CLI使用git clone获得测试源码   设置仓库中的autocrlf变量  设置全局（在本地创建和克隆的都受到影响）      git config --global core.autocrlf true          设置当前仓库       git config core.autocrlf false          ","categories": ["问题"],
        "tags": ["Git","Shell"],
        "url": "/%E9%97%AE%E9%A2%98/git%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E6%96%87%E4%BB%B6%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E6%A0%BC%E5%BC%8F/",
        "teaser": null
      },{
        "title": "Systemd和systemctl",
        "excerpt":"systemctl是一个在基于 systemd 的 Linux 系统中用于控制 systemd 系统和服务管理器的命令行工具。systemd 是一个系统和服务管理器，它提供了系统启动、服务管理、日志记录等一系列功能。systemctl命令是与 systemd 进行交互的主要方式，它非常强大且功能丰富。  1. 管理服务（Unit）  1.1 启动服务：  sudo systemctl start [服务名称]  例如，启动httpd服务（假设已安装）：  bash sudo systemctl start httpd  1.2 停止服务：  sudo systemctl stop [服务名称]  例如，停止httpd服务：  sudo systemctl stop httpd  1.3 重启服务：  sudo systemctl restart [服务名称]  例如，重启httpd服务，常用于在修改服务配置文件后使其生效：  sudo systemctl restart httpd  1.4 重新加载服务配置：  sudo systemctl reload [服务名称]  此命令在不重启服务的情况下重新加载服务的配置文件，适用于某些服务可以在运行时重新加载配置而无需完全重启的情况，如nginx：  sudo systemctl reload nginx  1.5 查看服务状态：  sudo systemctl status [服务名称]  该命令显示服务当前的运行状态，包括是否正在运行、启动时间、最近一次启动或停止的结果等信息。例如查看vsftpd服务状态：  sudo systemctl status vsftpd  输出类似如下内容：  plaintext ● vsftpd.service - vsftpd FTP server    Loaded: loaded (/lib/systemd/system/vsftpd.service; enabled; vendor preset: enabled)    Active: active (running) since Mon 2024 - 01 - 01 10:00:00 UTC; 1h ago   Process: 1234 ExecStart=/usr/sbin/vsftpd /etc/vsftpd.conf (code = exited, status = 0/SUCCESS)  Main PID: 1234 (vsftpd)     Tasks: 1 (limit: 4915)    Memory: 1.2M    CGroup: /system.slice/vsftpd.service            └─1234 /usr/sbin/vsftpd /etc/vsftpd.conf  其中 “Active: active (running)” 表明服务正在运行。  2. 服务开机自启管理  2.1 设置服务开机自启：  sudo systemctl enable [服务名称]  例如，设置httpd服务开机自启：  sudo systemctl enable httpd  执行后会创建或修改符号链接，将服务单元文件链接到系统启动相关的目录。  2.2 取消服务开机自启：  sudo systemctl disable [服务名称]  例如，取消httpd服务开机自启：  sudo systemctl disable httpd  此命令会删除相关的符号链接，使服务在系统启动时不再自动启动。  2.3 查看服务是否开机自启：  sudo systemctl is - enabled [服务名称]  例如，查看httpd服务是否开机自启，若输出为enabled则表示开机自启，若为disabled则表示未设置开机自启：  sudo systemctl is - enabled httpd  3. 系统管理相关  3.1 启动进入指定运行级别（target）：  运行级别在 systemd 中被称为 target。例如，要启动到图形化界面（通常是graphical.target）：  sudo systemctl start graphical.target  若要启动到多用户文本界面（multi - user.target）：  sudo systemctl start multi - user.target  3.2 查看当前运行级别（target）：  systemctl get - default  输出结果会显示当前默认的启动目标，例如graphical.target或multi - user.target。  3.3 设置默认运行级别（target）：  例如，将默认运行级别设置为多用户文本界面：  sudo systemctl set - default multi - user.target  若要恢复为图形化界面为默认：  sudo systemctl set - default graphical.target  3.4 重启系统：  sudo systemctl reboot  3.5 关闭系统：  sudo systemctl poweroff  3.6 挂起系统（进入睡眠状态）：  sudo systemctl suspend  3.7 使系统进入休眠状态：  sudo systemctl hibernate  4. 管理服务依赖关系  4.1 查看服务依赖关系：  sudo systemctl list - dependencies [服务名称]  例如，查看httpd服务的依赖关系，会显示该服务所依赖的其他服务以及依赖它的服务：  sudo systemctl list - dependencies httpd  ","categories": ["笔记"],
        "tags": ["Linux","systemd"],
        "url": "/%E7%AC%94%E8%AE%B0/systemd%E5%92%8Csystemctl/",
        "teaser": null
      },{
        "title": "使用vsftpd在阿里云ecs上建立一个ftp服务器",
        "excerpt":"首先要做的就是在服务器上运行一个FTP server。现在已经十分的成熟了，可以直接使用apt工具下载一些常用的ftp工具软件包，例如vsftpd和ProFTPD等。这里我使用的是vsftpd。   apt update apt install vsftpd systemctl start vsftpd     “vsftpd” 中，最后的 “d” 代表 “daemon”，即守护进程。守护进程是一种在后台持续运行的进程，它独立于控制终端，通常在系统启动时自动启动，并一直运行直至系统关闭，用于执行特定的系统任务或提供某种服务。 systemctl是一个在基于 systemd 的 Linux 系统中用于控制 systemd 系统和服务管理器的命令行工具。systemd 是一个系统和服务管理器，它提供了系统启动、服务管理、日志记录等一系列功能。systemctl命令是与systemd 进行交互的主要方式，具体参见systemctl。    接下来要做的是对vsftpd的一些配置，最主要的是添加用户和用户组，设置用户的权限和工作目录。   adduser honest   完成了配置以后，还需要再阿里云的控制台里配置服务器的安全组，让ftp的端口开放出来。   登录阿里云控制台，找到对应的 ECS 实例，进入安全组设置页面。添加安全组规则，允许 FTP 服务相关端口的访问。如果是主动模式，需开放 21 端口（控制连接）；如果使用被动模式，除了 21 端口，还需开放配置的被动模式端口范围（例如 40000 - 40100）。方便起见，这里我把入方向和出方向都配置成了所有端口。      很有可能不安全，小孩子不要学       在想要连接FTP server的设备上运行FileZilla client这样的软件。建立连接时有如下提示，也就是没有做加密。      FTPS 一种方法是使用FTPS（FTP over SSL/TLS）的协议，使用SSl/tsl来实现安全传输。这需要依赖openssl这个软件包，一般的Linux发行版都会下载这个包，所以仅需要我们配置ssl的公钥然后让Vsftpd 支持 FTPS。 打开vsftpd.conf文件  vi /etc/vsftpd.conf  添加或修改以下配置参数：  ssl_enable=YES write_enable=YES  重启vsftpd服务  systemctl restart vsftpd  SFTP 另一种方法是使用SFTP（SSH FTP），SFTP 是基于 SSH 协议的文件传输协议，使用 SSH 的安全通道来传输文件。SFTP将文件传输作为 SSH 协议的子系统，所以只需要支持ssh的设备就可以使用这种方式传输文件。因为使用 SSH 协议，所以继承了 SSH 的安全性，包括加密和用户认证。     更简单的情况下，我们可以直接使用SCP来复制文件。   ","categories": ["笔记"],
        "tags": ["ECS","FTP","vsftpd"],
        "url": "/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8vsftpd%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E4%B8%8A%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8/",
        "teaser": null
      },{
        "title": "2024年终总结",
        "excerpt":"序   当我缓过神来，望向窗外旧屋屋檐上的皑皑白雪时，时间已经早就到了2025年。在带着弥散的火药味的寒风里，在农历的旧年的最后一天，拖延症晚期的我也不得不升起一定要将这一年迟来的总结终结在甲辰年的决心。“至少是在新年前完成了过去一年的总结——虽然是农历”自欺欺人的想着，我敲起了键盘。   实际上我已经好久没有像这样写年终总结了。重新开始写点东西梳理梳理思绪，记录下自己的想法也只不过是不久前的事情——这都多亏了我自己搞了一个个人网站。有了个人网站之后，不由自主的就想着不能让它总是一片尴尬的空白，这反过来倒逼着自己去输出一些东西。   一开始是普通的技术总结和工作记录，然后是自己在游戏、动画等作品之后的一些感悟和体会，再之后是像高中那样对自己和过去进行总结和分析——五年之后的今天，我又开始了和自己的长谈。   转   要用一个字总结2024年，那应该是“转”。2024年是我生活中的一个重要转折点——在2024年的上半年我还是一个普通的学生，在2024年的下半年我实际上已经成了一个朝九晚五的社畜。   研一的生活说实话和本科相比实际上没有什么区别，重复着上课、笔记、作业、考试的古旧循环。   #   ","categories": ["随笔"],
        "tags": ["年终总结"],
        "url": "/%E9%9A%8F%E7%AC%94/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/",
        "teaser": null
      },{
        "title": "使用ghpage分支配置jekyll网页的自定义域名问题",
        "excerpt":"问题描述  最近在阿里云上为我的个人网页购买了一个域名honest-zh.me,我将www.honest-zh.me的链接重定向到了我之前在github page上托管的个人主页。并在github的设置中的page选项的Custom domain里设置为了我的域名。很顺利的，域名可以跳转到我在github page上托管的个人网页网址honest-zh.github.io上。但当我更新我的博客，ghpage分支重新部署文件后，域名的重定向就失效了！  解决方法  github page使用CNAME的文件管理自定义域名，观察到检测ghpage分支更新并进行部署的Github action工作流里面没有CNAME的设置项，添加cname: www.honest-zh.me 添加后的文件大致为：      - name: Deploy to GitHub Pages       uses: peaceiris/actions-gh-pages@v3       with:         github_token: $         publish_dir: ./_site         cname: www.honest-zh.me  # 自定义域名www.honest-zh.me  ","categories": ["问题"],
        "tags": ["Git","Jekyll","个人主页"],
        "url": "/%E9%97%AE%E9%A2%98/%E4%BD%BF%E7%94%A8ghpage%E5%88%86%E6%94%AF%E9%85%8D%E7%BD%AEjekyll%E7%BD%91%E9%A1%B5%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E9%97%AE%E9%A2%98/",
        "teaser": null
      },{
        "title": "Wsl2突然无法使用",
        "excerpt":"问题描述  之前一直可以使用的wsl突然抽风无法使用。powershell运行wsl报错：      PS C:\\WINDOWS\\system32&gt; wsl 当前计算机配置不支持 WSL2。 请启用“虚拟机平台”可选组件，并确保在 BIOS 中启用虚拟化。 通过运行以下命令启用“虚拟机平台”: wsl.exe –install –no-distribution 有关信息，请访问 https://aka.ms/enablevirtualization 错误代码: Wsl/Service/CreateInstance/CreateVm/HCS/HCS_E_HYPERV_NOT_INSTALLED    解决方法  确保在启动配置中启用了虚拟机监控程序启动。 可以通过运行（提升的 PowerShell）来对此进行验证：    bcdedit /enum | findstr -i hypervisorlaunchtype   如果看到 hypervisorlaunchtype Off，则会禁用虚拟机监控程序。 使其在提升的 PowerShell 中运行：    bcdedit /set hypervisorlaunchtype Auto   设置完成以后重新启动wsl,wsl就工作正常了。      猜想：设置的 hypervisorlaunchtype 属性是 Auto,有时会自动关掉？是的，尤其是在windows对wsl进行了更新的情况下。（沟槽的微软阿三程序员#￥%@。。。以下略）   ","categories": ["问题"],
        "tags": ["wsl"],
        "url": "/%E9%97%AE%E9%A2%98/wsl2%E7%AA%81%E7%84%B6%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8/",
        "teaser": null
      },{
        "title": "Ftp二进制文件传输问题",
        "excerpt":"问题描述  使用在ECS上通过vsftpd建立的FTPserver，出现传输可执行文件时发生段错误的报错。   完整的流程是这样：我在ARM64的笔记本上build了一个项目，然后为了方便传输，直接将整个编译结果的文件夹传上了FTP server。在x86架构的Windows的设备上，我从FTP server上下载了编译结果，部署到了rk3588的开发板上（开发板的指令架构和ARM64的笔记本一致，出于嵌入式系统的最小化考虑，裁剪的linux上没有安装构建所需的工具包）。执行可执行文件时报错：segmentation fault ，段错误。   首先想的是不是编译的平台的问题，但是这种情况的报错一般不是这个，而是不适合的架构 Exec format error。 第二部考虑的就是ftp传输的问题。  解决方法  查阅资料以后发现，ftp具有两种文件传输的模式，一种是ASCII 模式、另一种是二进制模式来传输文件。ASCII 模式会对文件进行换行符转换（如将 \\n 替换为 \\r\\n，LF和CRLF的问题），这对文本文件的处理有一定好处，但是会损坏二进制文件。可执行文件应该在二进制模式下传输。   FTP的server一般会自动的处理文件传输模式，也就是说问题取决于FTP客户端的设置，需要设置为二进制传输模式。   FileZella默认的是自动模式，偶尔会出现问题。 右上角-编辑-设置，在弹出窗口中选择 传输-FTP类型-二进制模式传输文件   ","categories": ["问题"],
        "tags": ["FTP","vsftpd"],
        "url": "/%E9%97%AE%E9%A2%98/FTP%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E9%97%AE%E9%A2%98/",
        "teaser": null
      },{
        "title": "Jekyll Admin使用的包依赖问题",
        "excerpt":"问题描述  我希望找到一个在线编辑jekyll的文档的方式，这样我们可以使用不同的设备在网页进行编辑。好消息是jekyll有一个专门用于实现的插件叫做jekyll-admin,可以比较方便的进行管理。   正常来说，在Gemfile和_config里添加jekyll-admin，然后再执行bundle install命令即可使用这个插件。但是这次却在静态网页bulid之后发生了问题。   问题报错如下：  jekyll_admin_monkey_patch': uninitialized constant Rack::Handler (NameError)            @server.mount \"/admin\", Rack::Handler::WEBrick, JekyllAdmin::StaticServer                                                ^^^^^^^^^  未找到rack里对于webrick的定义   然而我使用bundle list出现的结果确实有的，怀疑是出现了包依赖问题   解决方法  尝试了bundle update等方法更新rack, 但是到了最新版本问题依然存在。进一步怀疑是包依赖发生了冲突？使用bundle check并没有找到冲突的依赖项，让人更是摸不着头脑。   最后我去jekyll-admin的Github Issue上看了一下才发现了问题。这个问题是jekyll-admin 的依赖项sinatra的更新导致的——sinatra 版本更新到 4.0之后放弃了对 rack 2 的支持。   只需在 gemfile 中添加此内容将sinatra版本回退到4.0之前即可。  gem \"sinatra\", \"&gt;= 3\", \"&lt; 4\"。  ","categories": ["问题"],
        "tags": ["Jekyll"],
        "url": "/%E9%97%AE%E9%A2%98/jekyll-admin%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8C%85%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/",
        "teaser": null
      },{
        "title": "Twin Theives",
        "excerpt":"It is not burdens of today that drive men mad.   It is the regrets over yesterday and the fear of tomorrow.   Regret and fear are twin thieves who rob us of today.  ","categories": ["随笔"],
        "tags": [],
        "url": "/%E9%9A%8F%E7%AC%94/twin-theives/",
        "teaser": null
      },{
        "title": "在服务器上使用Jekyll和Nginx实现SSL和用户登录",
        "excerpt":"需求描述  在jekyll上编译了一个静态网页用来作为我的个人网页。但是每次编辑网页存在着比较大的问题——我需要先在本地编写MarkDown文本然后push到github上，等待他的自动构建。   于是我在jekyll上使用了jekyll-admin来进行后台管理我的个人主页的博客，每次更改博客时自动进行增量式的静态页面构建。但是此时我还是遇到了一些问题，使得我需要重构我的个人网页结构。   第一点是拓展性问题。   github page托管的终究只是一个简单的页面。想要满足不同的需求，解决各种的问题，为其添加其他的功能，就需要在具有更高自主权的linux主机上运行服务才方便。   第二点是Jekyll的跳转问题。   jekyll默认的ip和端口是127.0.0.1:4000。运行在ECS云服务器上时，你需要让服务器监听所有的ip的接入，需要配置为0.0.0.0:4000.但是此时jekyll-admin页面的跳转存在着问题，预览界面时他会尝试在0.0.0.0上进行跳转。   第三点是安全性问题。   登陆问题jekyll-admin插件提供的后台管理界面 /admin是任何人都可以登录进行修改的，这非常的不安全。我需要一个用户登录管理的功能。   SSL/TLS加密问题。jekyll编译和提供的服务是没有进行SSL加密的，是以HTTP的方式进行的访问，应该对其添加加密使其以HTTPS方式访问。   解决方案分析  正好我有一个阿里云的ECS云服务器（之前用来搭建FTP server），可以比较容易的把Jekyll的服务器转移到linux的云服务器上运行。这样第一个问题就解决了。   对于第二和第三个问题，有一个成熟的方案可以同时解决这两个问题——Web代理服务器。   Web服务器为服务器提供反向的代理，可以把向云服务器的公网的某个IP的端口上访问的链接转移到其他的IP的端口，当然也包括本地的IP。Web服务器也可以和其他的方法相结合提供网页的SSL加密和用户登录管理。   这里使用Nginx作为Web服务器，使用certbot从Let’s Encrypt这一机构获得免费的SSL/TLS证书，使用apache2-utils中的htpasswd工具进行用户的加密。   实现   一、下载所需的工具包   sudo apt update sudo apt upgrade  sudo apt install certbot python3-certbot-nginx sudo apt install apache2-utils  二、获得SSL/TLS证书   1.初步设置Nginx  确保 Nginx 已经配置了正确的服务器块，并且可以通过 HTTP（端口 80）访问你的域名。   打开Nignx的设置文件   sudo vi /etc/nginx/sites-available/default   清空，重新写入以下内容   server {     server_name www.honest-zh.me;  # 确保配置了正确的域名      root /home/honest/honestblog/_site;  # 根据实际路径调整      index index.html index.htm;      # 可选：配置特定路径     location / {         try_files $uri $uri/ =404;     }   运行sudo nginx -t,保证Nginx设置的正确。   2.使用certbot   想要使用certbot为域名生成SSL证书需要确保以下的两个前提。   域名已经指向你的服务器：确保 honest-zh.me 域名的 DNS 记录已经正确指向你的服务器的公共 IP 地址。如果你还没有配置 DNS，请在域名注册商的管理面板中设置 A 记录，指向你的服务器 IP 地址。   Nginx配置正常：确保你的服务器上已经安装并配置了 Nginx。   那之后执行命令sudo certbot --nginx -d www.honest-zh.me获得SSL证书，保存的证书在路径/etc/letsencrypt/live/www.honest-zh.me/下。这个命令会执行以下的操作：      获取证书：它会向 Let’s Encrypt 服务器请求一个 SSL 证书。   修改 Nginx 配置：它会自动为你的域名配置 SSL，更新 Nginx 配置文件，添加 SSL 相关的配置（例如 ssl_certificate 和 ssl_certificate_key）。   重载 Nginx：它会重新加载 Nginx，使得新证书和配置立即生效。   certbot从Let’s Encrypt获取的证书有效期为 90 天，因此需要定期续期。为了确保证书能够自动续期，可以设置一个 cron 任务，每天检查并续期证书。   sudo crontab -e   0 */12 * * * certbot renew --quiet &amp;&amp; systemctl reload nginx  三、设置用户名密码   执行命令   sudo htpasswd -c /etc/nginx/.htpasswd honest   用户文件将储存在.htpasswd中   四、设置Ngnix（HTTP重定向、服务器反向代理、用户验证）   打开Nignx的设置文件   sudo vi /etc/nginx/sites-available/default   清空，重新写入以下内容   server {     listen 80;     server_name www.honest-zh.me;  # 替换为你的域名     # HTTP -&gt; HTTPS 重定向     return 301 https://$host$request_uri; }  server {     listen 443 ssl;     server_name www.honest-zh.me;  # 替换为你的域名     # SSL 配置（Certbot 自动配置的证书路径）     ssl_certificate /etc/letsencrypt/live/www.honest-zh.me/fullchain.pem;     ssl_certificate_key /etc/letsencrypt/live/www.honest-zh.me/privkey.pem;     ssl_protocols TLSv1.2 TLSv1.3;     ssl_ciphers 'TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384';     ssl_prefer_server_ciphers off;     # 反向代理 Jekyll 服务     location / {         proxy_pass http://127.0.0.1:4000;  # 将请求转发到 Jekyll 本地服务         proxy_set_header Host $host;         proxy_set_header X-Real-IP $remote_addr;         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;         proxy_set_header X-Forwarded-Proto $scheme;     }     location /admin {     auth_basic \"Restricted Access\";     auth_basic_user_file /etc/nginx/.htpasswd;      proxy_pass http://127.0.0.1:4000;     proxy_set_header Host $host;     proxy_set_header X-Real-IP $remote_addr;     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;     proxy_set_header X-Forwarded-Proto $scheme;     } }   运行sudo nginx -t,保证Nginx设置的正确。      启动sudo systemctl start nginx     停止  sudo systemctl stop nginx     重启  sudo systemctl restart nginx     重新加载 sudo systemctl reload nginx     禁用启动时自动启动 sudo systemctl disable nginx     启用启动时自动启动 sudo systemctl enable nginx     查看服务状态 sudo systemctl status nginx   ","categories": ["笔记"],
        "tags": ["Jekyll","个人主页","ECS"],
        "url": "/%E7%AC%94%E8%AE%B0/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8Jekyll%E5%92%8CNginx%E5%AE%9E%E7%8E%B0SSL%E5%92%8C%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/",
        "teaser": null
      },{
    "title": "按时间归档",
    "excerpt":"","url": "http://47.95.215.1:4000/posts/"
  },{
    "title": "按分类归档",
    "excerpt":"","url": "http://47.95.215.1:4000/categories/"
  },{
    "title": "按时间归档",
    "excerpt":"","url": "http://47.95.215.1:4000/tags/"
  },{
    "title": "HONEST的个人主页",
    "excerpt":"","url": "http://47.95.215.1:4000/index.html"
  },{
    "title": "HONEST的个人主页 - 第2页",
    "excerpt":"","url": "http://47.95.215.1:4000/page/2/index.html"
  },{
    "title": "HONEST的个人主页 - 第3页",
    "excerpt":"","url": "http://47.95.215.1:4000/page/3/index.html"
  },{
    "title": "HONEST的个人主页 - 第4页",
    "excerpt":"","url": "http://47.95.215.1:4000/page/4/index.html"
  },{
    "title": "HONEST的个人主页 - 第5页",
    "excerpt":"","url": "http://47.95.215.1:4000/page/5/index.html"
  },{
    "title": "HONEST的个人主页 - 第6页",
    "excerpt":"","url": "http://47.95.215.1:4000/page/6/index.html"
  }]
