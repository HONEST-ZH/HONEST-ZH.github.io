var store = [{
        "title": "Kconfig",
        "excerpt":"Makefile和config/kconfig   自动项目编译工具make   make是一种用于自动编译项目的构建工具，通过执行makefile中预先写好的命令保证按照依赖关系、避免重复编译。Make在实际的工作中依然是使用gnu gcc的工具进行编译的，只是提前指定了gcc的命令。   Makefile的编写：   1.基础语法：   目标：依赖 命令   为了方便缩写和编译，可以使用定义的变量进行缩写，使用时加上()即可解析为命令进行。除此以外，存在一些简略的写法代替目标和依赖，^: 依赖、$@: 目标文件。   2.伪目标：   .PHONY:用于标识一个不对应实际文件的伪目标，这些伪目标往往用来控制makefile   例如clean。   3.例子：   CC=gcc  OBJS=hello.c  CFLAGS=-c  RM=rm -f  hello.o:$(OBJS)  (CC) (CFLAGS) ^ -o @  .PHONY:clean  clean:  $(RM) *.o   4.Makefile的remake操作：   有如下的makefile脚本，先生成target对象再重编译remake整个makefile。   -include   目标     目标: 依赖                  正则表达式   .config配置文件   Linux内核图形编译工具.Kconfig   Kconfig详解 - 大海中的一粒沙 - 博客园 (cnblogs.com)   menuconfig 和 Kconfig 介绍-阿里云开发者社区 (aliyun.com)   Linux从模块化机制学到Kconfig，Makefile构建配置原理_linux kconfig makefile-CSDN博客   为了正确处理Linux操作系统繁杂的项目文件和复杂的依赖，简单的通过源码完成内核的配置和编译。 Kconfig是一种用于支持Linux内核图形化配置（menuconfig）的脚本语言。通过Kconfigs实现图形化界面的选项设置，便于用户交互。但Linux内核实际使用是通过顶层makefile根据menucofig得到的.conf文件逐级建立的。实质上是在操作系统配置中使用的、Makefile的一种图形化配置方法。   配置内核有几种方式：   make menuconfig:图像化配置。   先生成可执行文件mconf.o生成图像界面，选择结束后生成.config文件。   make XXX_defconfig：板卡适配的默认配置。   先生成可执行文件conf.o，直接把XXX_defconfig保存成.config文件（本质是一个东西）。编译时主Makefile会根据.config中的变量决定编译哪些部分。      *Linux内核源码的这棵树，通过Makefile文件来选择各个目录下的对应的文件是否被编译，.config文件就像是控制台，控制着Makefile文件去编译指定的程序代码文件（主要是C和汇编）。而这一切控制关系是由Kconfig文件建立起来的。   ","categories": ["笔记"],
        "tags": [],
        "url": "/%E7%AC%94%E8%AE%B0/kconfig/",
        "teaser": null
      },{
        "title": "中间件",
        "excerpt":"中间件：       中间件是位于操作系统和应用之间的系统软件。核心目标是实现分布式系统的资源共享和共同通信，相当于用额外抽象层来应对实际情况中异构的操作系统和复杂的网络情况。   中间件       中间件技术与具体的应用需要强相关，不同的需要对应的架构以及使用的中间件技术都大不相同。网络架构和中间件。       常见的网络中间件有：           web服务器nginx（服务器反向代理）            RPC框架grpc(protobuf)、jrpc(json)            消息中间件（消息队列）kafka、rabbitMQ、rocketMQ、ZMQ                      [消息队列基础知识总结       JavaGuide](https://javaguide.cn/high-performance/message-queue/message-queue.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)                   分布式缓存redis            任务调度框架      ","categories": ["笔记"],
        "tags": [],
        "url": "/%E7%AC%94%E8%AE%B0/%E4%B8%AD%E9%97%B4%E4%BB%B6/",
        "teaser": null
      },{
        "title": "Markdown",
        "excerpt":"MarkDown笔记   标题：若干# + 空格   加粗： ** 文本** 、__ 文本__或Ctrl +B `   倾斜：* 文本*、_ 文本_ 或Ctrl+I   加粗+倾斜：*** 文本***、___ 文本___ 或Ctrl+B  Ctrl+I   下划线：&lt;u&gt;文本&lt;/u&gt;或Ctrl+U   删除线：~~ 文本~~或Ctrl+D   引用：&gt; 文本 或Ctrl+shift+Q   无序列表：- 列表或* 列表   有序列表：1. 列表   代码：`代码`  或Ctrl + ` `   代码段： ```   分割线 ****   数学公式：Ctrl + Shift +M 或 $数学符号$   图片：![描述]（图片路径）或Ctrl+shift+I   链接：   \\`[文本](链接网址\"悬浮title\")\\`  \\`&lt;https://www.114514.com&gt;\\`   亦或   [链接文本][1]  [1]:www.1919810.com   注释：[//]:#(注释)   目录：[TOC]  ","categories": ["笔记"],
        "tags": [],
        "url": "/%E7%AC%94%E8%AE%B0/MarkDown/",
        "teaser": null
      },{
        "title": "Uboot",
        "excerpt":"Uboot介绍   Uboot是一个开源的嵌入式系统引导程序，支持多种不同架构的板卡通过内存、SD卡或者FTP的方式加载系统。Uboot对板上的资源进行初始化使其达到满足引导操作系统的最小化要求（相当于一个小的操作系统），类似于windows系统的BIOS。   Uboot工作目录：   目录结构和内容，见docs.u-boot.org/en/latest/develop/directories.html中的表格。   Uboot的工作流程：   1.        初始化硬件资源（RAM、网卡等）   2.        从flash搬运系统的内核到RAM中   (1)     XIP:(eXcute in place**，片内执行)   e.g.写在片内的falsh中   CPU可以直接在片上访问地址找到uboot程序，无需初始化。   (2)     非XIP**：   e.g.写在SD卡上（需要初始化emmc）   CPU不可以直接在片上访问地址找到uboot程序，需额外的初始化片外的存储设备，以复制uboot的程序uboot.bin和设备树。相当于额外执行了一个加载uboot的加载程序(bootrom，在片上固化的)。   3.        启动系统的内核   Uboot的代码执行过程：   根据架构的设置从一个汇编文件strat.s开始。然后执行lowlevel_init()、board_init_f()、board_init_r()。   Uboot的make编译流程：   Uboot的程序通过make指令生成一个名为uboot.bin的二进制文件，烧录到板卡的闪存之中。                        若板卡厂商已经提供了u-boot的支持：   STEP1：      make XXX_defconfig：   根据板卡预设的信息_defconfig，生成.config文件。首先建立一个conf工具，使用Kconfig解析_defconfig的配置，如果不存在依赖，直接写入.config，如果存在依赖，从Kconfig中写入_defconfig依赖的配置到.config文件，未设置的配置使用默认值。   .config决定了uboot项目编译的过程中需要对那些目录、哪些文件进行编译，makefile中使用obj-$(CONFIG_XXXX)+= xxx/ 命令实现。还有可能需要编译文件中的某一部分，因此在make的时候会根据.config文件生成一个名为config.h的头文件，其中包含了所有的config的宏定义。在c文件中使用宏指令#if#else#endif判断编译那一部分。   可以使用以下技巧观察make的具体依赖，分析源码。   make xx -p &gt;detail.txt               Vi  detail.txt            :g/^#/d   STEP2.      make ARCH=OOO CROSS_COMPILE=XXX*   根据.config生成了config.h文件，用于编译c文件的部分。生成auto.conf（auto.conf.cmd、autoconf.h、），生成uboot.cfg，autoconf.mk。最后生成uboot.bin文件。   若板卡厂商未提供u-boot的支持：   需要自己设置.config文件然后make u-boot.bin文件。最后下入板中的是uboot.bin + 设备树文件（DTB）。  ","categories": ["笔记"],
        "tags": [],
        "url": "/%E7%AC%94%E8%AE%B0/Uboot/",
        "teaser": null
      },{
        "title": "Linux命令行 ",
        "excerpt":"Linux命令(bash Shell命令)：   freecodecamp.org/chinese/news/the-linux-commands-handbook/   man:查看命令手册的具体内容，帮助了解（很长很长）。建议使用tldr以更快的大致了解一个命令。   man [命令]/tldr [命令]   文件夹操作：      ls:查看文件夹的内容，默认是当前目录。常用的属性是-al,可以查看文件的详细信息（l详细数据，a显示隐藏数据）。           ls [选项] &lt;文件路径&gt;      cd:打开文件夹。.. :上级文件夹、. :当前文件夹、/：根目录、~：root目录。           cd [选项] &lt;文件路径&gt;           pwd:显示当前的工作文件夹。            du:显示目录大小。 -h单独计算每个文件大小。            mkdir:创建新的文件夹。-p :创建嵌套的文件夹。               mkdir [选项] &lt;文件路径&gt;           rm -f:删除文件和其中内容（必须慎重操作）。-rf:递归的删除文件（也删除文件夹里的）            rmdir:删除文件夹（必须为空）。               rmdir [选项] &lt;文件路径&gt;      mv:移动文件、文件夹；也可用于重命名文件。 -t 目标目录           mv             cp：复制文件，-r复制文件夹。            find:查找文件,可以限定查找的类型、名称、大小、时间和附加操作。               find  [路径]  -type [类型：f/d]  -name [文件名]  -size [+大于的值/-小于的值]  -mtime [更新时间]  -delete/-exec [命令]      ln:链接文件,包括硬链接和软链接。保证同步更新？           硬链接：ln ，复制+同步           软链接：ln ，指针           gzip：压缩            ta：归档       文件操作：           touch :创建文件，以写入方式打开。            cat：打印文件的内容到标准输出。       cat常常与管道运算符，重定向输出符等连用       cat 文件名              | 是管道符号，标识把左边的内容的输出作为右边内容的输入。         &gt;是重定向输出符号，把内容输出到文件当中，会覆盖         &gt;&gt;是追加重定向输出符号，把内容追加在文件的末尾                 tail: 打开并监控文件的末尾。（用于日志监控）               tail -f [文件]           grep：全局正则表达式打印。在指定的文件里寻找字符串（正则表达式）。-n 显示匹配的行行号、- l 打印匹配的文件名、-i 忽略大小写匹配、-v 反向查找（打印不匹配的） 、-r 递归查找文件、-c 只打印匹配的行数、-C x 打印匹配的行前后x行的内容。       grep [选项] 表达式 [文件]            echo:打印输出。            sort:对文本进行排序 -r倒序 -u移除重复的（对中文不可用）            uniq：去除重复的行，-d显示重复行、-u显示不重复行、-c计数            diff:比对两个文档。-y逐行对比、-u git式的对比、-r 递归比较、-q显示不同的文件名       进程操作：           ps:检查进程，（静态）            top:动态监控进程            kill：向进程发送信号（KILL和STOP先向内核发送，由内核操纵进程）。信号包括：HUP(1)挂起、INT(2)干扰、KILL(9)强制终结、TERM(15)正常终结、CONT(18)继续、STOP(19)停止       用户操作：           alias:为命令创造别名。’’ 变量在调用时解析, ””变量在定义时解析。       alias [new_cmd]=’cmd’/”cmd”            chown:改变所有者            chmod:改变权限。rwx分别对应了读4写2执行1,不操作的使用-替代。一个文件有三组rwx的值，对应所有者、关联的用户组和其他人的权限。       chmod  owner/group/world  +/-  rwx       chmod  777            df:获取磁盘使用情况。-h            su -l :切换设备权限到root            ldconfig：更新系统共享库缓存       查看操作   sudo netstat -tulpn | grep &lt;port_number&gt;   Linux相关的快捷键           常用：              Ctrl L ：清屏       Ctrl M ：等效于回车       Ctrl C : 中断正在当前正在执行的程序       ctrl+alt+t：打开终端                历史命令：              Ctrl P : 上一条命令，可以一直按表示一直往前翻       Ctrl N : 下一条命令       Ctrl R，再按历史命令中出现过的字符串：按字符串寻找历史命令（重度推荐）                命令行编辑：              Tab : 自动补齐（重度推荐）       Ctrl A ： 移动光标到命令行首       Ctrl E : 移动光标到命令行尾       Alt F : 光标前进一个单词       Alt B : 光标后退一格单词       Ctrl ] : 从当前光标往后搜索字符串，用于快速移动到该字符串       Ctrl Alt ] : 从当前光标往前搜索字符串，用于快速移动到该字符串       Ctrl H : 删除光标的前一个字符       Ctrl D : 删除当前光标所在字符       Ctrl K ：删除光标之后所有字符       Ctrl U : 清空当前键入的命令       Ctrl W : 删除光标前的单词(Word, 不包含空格的字符串)       Ctrl \\ : 删除光标前的所有空白字符       Ctrl Y : 粘贴Ctrl W或Ctrl K删除的内容       Ctrl X Ctrl E : 调出系统默认编辑器编辑当前输入的命令，退出编辑器时，命令执行                其他：                       Ctrl Z : 把当前进程放到后台（之后可用’‘fg’‘命令回到前台）                        Shift Insert : 粘贴（相当于Windows的Ctrl V）                        在命令行窗口选中即复制                        在命令行窗口中键即粘贴，可用Shift Insert代替                        Ctrl PageUp : 屏幕输出向上翻页                        Ctrl PageDown : 屏幕输出向下翻页           Linux的包管理工具Apt                   包管理工具apt   apt是linux上进行包管理的一种常用工具，调用dpkg管理已安装的包还能管理未安装的包（一定要确定包是否已经安装！）   apt install：安装软件包，从sourcelist中定义的源获取。   apt list   参数：–installed apt list --installed|grep -i [pakegename]列出已经下载的名字为pakegename的   apt search：寻找的是可以从所有软件源上下载到的包，并不是本地的包/已经安装的包。   apt-get   dpkg   dpkg 是Debian发行版中的包管理工具，只能用于已安装的包的管理   参数：-L ： dpkg -L [pakegename]查找pakegename的安装包路径  ","categories": ["笔记"],
        "tags": [],
        "url": "/%E7%AC%94%E8%AE%B0/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/",
        "teaser": null
      },{
        "title": "Linux操作系统",
        "excerpt":"Linux操作系统学习笔记   一、系统内核（kernal）介绍:   是一个建立在硬件和应用之间的中间软件，向上为应用提供调动硬件的接口服务，向下提供对各类硬件的兼容性支持（各种架构的CPU、各种不同原理、不同厂商的内存和设备）。   系统内核可以分为三层：系统调用接口（POXIS）、内核代码（不依赖架构，通用）、BSP板级支持包（依赖架构，具体配置）。   系统的主要组件有：系统调用接口、进程管理、内存管理、虚拟文件系统、网络堆栈、设备驱动程序和架构相关的内核代码（BSP）。   https://zhuanlan.zhihu.com/p/342056802   https://www.cnblogs.com/dy2903/p/8453660.html   1.1 系统调用接口：   系统调用接口是操作系统提供给内核的一组函数，用于对操作系统进行管理（后面的内容）。系统调用接口屏蔽了底层硬件的差异性、向上提供了系统内统一的用户接口，但是不同系统之间的借口是不统一的。POSIX是可移植系统接口，规定了通用的系统调用接口，使得应用程序能在兼容POSIX的不同操作系统中正常运行。   1.2 进程管理：   进程、线程、任务：   进程是一个在执行的程序（执行实例），他由一个或多个线程来实现（e.g.PI的计算）。进程是划分资源的基本单位，一个程序开始运行以后就为其开启了一个独立的空间，包括堆（heap进程期间动态分配的malloc/realloc）、缓冲、栈（stack、存放局部变量）、BSS段、数据段data segment、代码段text segment。   线程是进程执行的实体，是真正在运行的执行实体。线程是CPU调度的基本单位。同一个进程的线程之间共享资源（全局变量相同），又保留有自己的程序计数器、堆、栈（局部变量不同）。   任务笼统的表述为某一目的而执行的程序，在Linux和RTOS中任务指的就是线程。   Linux中不明确的区分进程和线程（使用了相同的结构体task_struct），区别只在于是否拥有资源。因此，线程又叫轻量级进程。   进程建立的过程：   进程间通信:   进程优先级和进程调度：   进程的数据结构：   https://blog.csdn.net/weixin_42462202/article/details/102768721   Linux中的进程由结构体task_struct表示，又叫进程描述符。结构体成员如下：   tasks是一个双向的循环链表，连接了所有的进程。   pid是进程号，不论进程还是线程都拥有内核中唯一的进程号（只是习惯的称为进程号，或许线程号的叫法更加合理）。   tgid是线程组号，可以把进程看做一个主线程，由主线程创建的其他子线程和主线程构成一个线程组。线程组中的子线程的线程组号就是主线程的pid。   group_leader是一个指向主线程的进程描述符（task_struct）。   /信号相关的数据结构/   1.3 内存管理：   虚拟内存：利用cache机制联系内存和硬盘，   分页机制：   1.4 文件系统：   虚拟文件系统VFS：   建立了一个文件系统的抽象层，实现对于不同的文件系统的兼容支持：网络文件系统NFS,AFS,GFS等等。   1.5 网络协议栈：   1.6 驱动：   1.7 BSP:   参考文献：   https://zhuanlan.zhihu.com/p/342056802   【计算机原理】程序执行过程 - dy2903 - 博客园   设备树：   Kconfig:   是一种图形化的配置.config文件的工具语言，被广泛的应用于Linux内核。使用一个名为Kconfig的配置脚本，设置了各种配置选项和之间的依赖关系。这样，开发者可以通过make  menuconfig的命令实现图形化的.config文件生成（需要已经安装好了uboot）。   Kconfig的语法为：   config [name] [“option name”] default     [default_value] depends on [dependency_config _name] select [select_config _name] help [help information]   #  ","categories": ["笔记"],
        "tags": [],
        "url": "/%E7%AC%94%E8%AE%B0/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",
        "teaser": null
      },{
        "title": "编译器gcc和交叉编译工具链",
        "excerpt":"交叉编译工具链gcc：   gcc是GNU Compiler Collection的简写，是一款被广泛使用的c语言编译工具。      还有Clang等编译工具    一、gcc的一般流程：   Linux下的ELF文件、链接、加载与库（含大量图文解析及例程）_elf文件的动态链接库与静态链接库-CSDN博客   首先需要了解源代码的编译这个复杂的过程。编译的过程实际上是把高级语言转换为低级语言的过程，编译和汇编是他的核心步骤，对计算机有一定了解的朋友想必都能很顺利的理解这一点。但是出于具体工程的兼容性和复用性的需要，还需要额外具有预处理和链接这两个额外的步骤。   下面稍微介绍一下为什么需要进行预处理和链接。在实际使用中，一段源码为了支持不同的平台上，不同的设备需要设置一定的宏变量以描述在对应的平台上具有的软件或硬件的特性。对于不同的特性应该进行的不同的操作，这就是选择性编译和编译控制。通过这种方法我们保证了代码的兼容性。   除此以外，在复杂的工程中经常充斥着对一段基础性代码的反复调用。为了提高可用性和效率，我们并不是每次使用都编译他们，而是将他们都提前编译好形成一个二进制文件。在每次编译文件时需要调用这个函数的时候，编译器会预先挖好空，等到链接阶段的时候直接链接到这个二进制文件去执行。一般的，大量的提前编译好的文件被打包归档成为一个库文件（lib, library）。库文件分为动态库和静态库，他们的实现之间有着一定的不同，相关的知识可以参见链接。【C++】静态库和动态库文件的生成和使用_c++ .a文件-CSDN博客   总而言之，编译一段源码的过程是：           预处理(Preprocessing)：.c-&gt;.i  处理包含、宏定义（#标识）       gcc -e xxx.c -o yyy.i            编译(Compilation)：.i-&gt;.s  转换到特定汇编代码（不是机器码，取决于指令集）       gcc -s xxx.i -o yyy.s            汇编(Assemble)：.s-&gt;.o 转换到机器码（但并不是实际执行的代码）       gcc -c xxx.s -o yyy.o            链接(Linking):.o-&gt;可执行文件(.exe或者.elf)        目标文件.o和其他文件、库文件、启动文件链接起来       gcc [无] xxx.o -o yyy -l zzz.a            一般来说，使用gcc直接从.c文件编译到可执行文件       gcc [-选项] [目标文件] ，一般的缩写为：gcc xxx.c -o yyy       这个过程中具有的文件类型有：           源文件.c、头文件.h；            预处理得到的.i 预处理文件；            编译得到的.s 汇编文件；            汇编得到.o（可重定向）目标文件；            链接得到.out 或 .elf 可执行（目标）文件。            静态库文件.a实质上就是预先编译、汇编好的.o目标文件的集合。在运行前加载到代码段当中。            动态库文件.so又叫共享目标文件，在运行时加载到内存的共享库段          gcc的头文件、库文件管理：   gcc路径搜索是具有优先级的      gcc编译选项：   可以直接在编译命令中使用 -I 参数指定头文件目录，或使用 -L 参数指定编译时库文件目录,-Wl,-rpath 参数指定执行库搜索路径（当指定多个动态库搜索路径时，路径之间用冒号”:”分隔。）   gcc -I/path/to/headers -L/path/to/libs myprogram.c -Wl,-rpath=path/to/libs  -o myprogram      通过.c文件的参数设置路径：   还可以使用环境变量来扩展搜索路径。需要注意的是这种方法添加的搜索路径是临时的，仅在当前终端有效。   C_INCLUDE_PATH：   通过设置环境变量来添加自定义的头文件目录。   export C_INCLUDE_PATH=/path/to/your/custom/headers   CPLUS_INCLUDE_PATH：   类似于 C_INCLUDE_PATH，但适用于 C++。   export CPLUS_INCLUDE_PATH=/path/to/your/custom/headers   LD_LIBRARY_PATH：   用于指定库文件（动态链接库）的搜索路径。如果你的程序依赖于自定义库，可以将库文件路径添加到此环境变量中。   export LD_LIBRARY_PATH=/path/to/your/custom/libs      配置文件指定的库路径   配置文件/etc/ld.so.conf中指定的动态库搜索路径。这是一个系统级别的更改，通常需要运行ldconfig命令来更新系统的库缓存，使新添加的路径生效。      系统默认搜索路径：   gcc 默认会搜索一些标准的系统头文件和库文件路径。   例如库文件路径是：/lib、/usr/lib、/lib64、/usr/lib64。/usr/local/lib和/usr/local/lib64一般存放用户自定义的库，一般不在标准的搜索路径之中。/usr/local/include  ","categories": ["笔记"],
        "tags": [],
        "url": "/%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%99%A8GCC%E5%92%8C%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/",
        "teaser": null
      },{
        "title": "Vim使用",
        "excerpt":"文本编辑器vim：   命令模式（：）和插入模式（i）,按ecs从插入到命令。命令模式下可以输入命令对文本进行控制。   w 保存   wq保存并退出   q! 退出不保存   u undo   crtl-r redo   x删除   dw删除单词   d$ 删除到行结束   d number w/number e 删除到下number个词的开头或者结束   dd删除整行   p把删除的放到指定位置   r取代当前的词   /向前搜索   ?向后搜索   %匹配对应的括号   s替换/old为/new   G移动到结尾   gg移动到开头   ctrl-G当前位置   o下方创建新的一行   O上方创建新的一行   a添加   A在后面的行添加。  ","categories": ["笔记"],
        "tags": [],
        "url": "/%E7%AC%94%E8%AE%B0/Vim%E4%BD%BF%E7%94%A8/",
        "teaser": null
      },{
        "title": "多线程编程",
        "excerpt":"多线程编程   多线程编程一般使用的是基于POSIX标准的系统接口pthread实现的。不同的操作系统可能有不同的接口，但是POSIX（Portable Operating System Interface, 可移植操作系统接口）是一个统一的标准和要求。在所有符合POSIX标准的系统上，（无论是linux、windows-WSL还是其他类unix系统）都可以使用。   多线程编程的核心难点在于线程安全性和进程间通信。   线程安全需要程序员对于共享资源的访问和线程的时序加以更多的考虑，以避免内存泄露和分布式系统的一致性等问题。   进程之下的线程资源是共享的，但是多个进程之间的资源是不共享的，需要使用合适的方法在不同的进程之间进行通信，   pthread_create   最常用的函数是pthread_create，这个函数会根据attr这一属性，向start_routine这一函数入口传递arg结构体作为参数，运行一个新的线程。这个线程的接口是pthread_t结构体。   int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void*), void *arg);      thread：这是一个输出参数，用于接收新创建线程的标识符。   attr：用于指定新线程的属性，如线程的堆栈大小、调度策略等。如果设置为 NULL，则使用默认属性。   start_routine：这是一个函数指针，指向新线程将执行的函数。这个函数必须有一个 void* 类型的参数，并返回一个 void* 类型的值。   arg：是传递给新线程执行函数的参数，是一个指向存放有函数所需参数的结构体的指针。如果不需要传递参数，可以设置为 NULL。   1. 线程安全   线程安全主要需要考虑的是对线程间共享资源（临界区资源）的管理和调度，以及线程资源的回收防止内存泄漏的问题。   1.1 共享资源管理   对共享资源的管理最主要的方法就是互斥锁。   1.2 资源回收   资源回收主要包括：           回收自由分配的结构体数据（malloc、alloc等等），通过自由分配的数据空间不会在函数结束时自动释放需要手动free防止资源泄露。            回收套接字资源。            回收线程防止僵尸线程的出现（自然return、主线程设置信号、pthread_cancel + pthread_join、pthread_detach）。       2. 进程间通信：   信号量、共享内存、管道、AF_UNIX族套接字  ","categories": ["笔记"],
        "tags": [],
        "url": "/%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/",
        "teaser": null
      },{
        "title": "套接字编程",
        "excerpt":"套接字编程笔记   1、套接字网络通信   socket函数的domain、type、protocol解析 - 远洪 - 博客园 (cnblogs.com)   socket编程主要的API函数介绍(某马） - 简书 (jianshu.com)   套接字编程-CSDN博客   套接字本质上是内核借助缓冲区形成的伪文件，用于表示进程间网络通信的特殊文件类型。在Linux环境下，套接字被视为一种特殊的文件描述符，它允许应用程序通过网络与其它计算机上的程序进行通信。一方面为了向上方的应用层屏蔽网络通信的协议的诸多细节，另一方面是为了统一接口。   然而在这屏蔽协议这点套接字做的并不好，甚至说是混乱不堪。封装了但是没有完全封装，而且还没有封装好（当然这和网络通信的复杂性不可分割），导致使用套接字的每个程序员都如坠云里雾里。最后还是要用户好好了解套接字的机制，背离了设计的本意。   但是长期以来在应用领域的巨大影响力早已让socket成为了事实上的标准，我们只能学习并了解它。对套接字的不满和分布式的应用需求催生了一系列的网络中间件（eg RabitMQ、Nginx、gRPC等），用于弥补套接字在功能和易用性上的空白，当然这是后话不谈。   2、 地址   在套接字编程当中，网络的地址五元组（发送方IP地址、端口号、网络协议、接收方端口号、地址）和套接字标识符（句柄）是解耦的。由系统对套接字标识符进行管理。IP地址和端口号构成了一个套接字地址socket，欲建立连接的两方构成了一个套接字对（满足五元组），唯一确定了连接。   2.1 地址转换系列函数：   问题的本质是网络字节序和主机字节序。这来源于历史遗留问题，不同系统的数据存放方式有所不同（大端和小端）。相关内容网上很多就不再赘述。解决方法就是规定统一的网络字节序，然后在不同存放方式的主机上进行字节序的转换。   除此以外就是一些转换字符串、点分十进制转换到地址结构体中实际保存的long int中的函数。   htonl/ntohl: 本地序转网络序，网络序转本地序（长，32位，四个8bit的点分十进制数）   htons/ntohs: 本地序转网络序，网络序转本地序（短，16位，）   忘了：   2.2 地址结构体：      struct sockaddr / struck sockaddr_in: 用来存放套接字地址的结构体，保证上层应用仅需知道套接字标识符就能进行通信（如同套接字socket的本意一样，像一个插座)。   设置三个成员：地址族、地址、端口号。例如：   sockAdd.sin_family = AF_INET; sockAdd.sin_addr.s_addr = INADDR_ANY; sockAdd.sin_port = htons(8888);   注意记得加stuct      私以为翻译成网络插口之类的名字更好。但是和鲁棒性一样，这一类的莫名的名称误导了了太多人。    3、TCP和UDP:   4、套接字函数：   socket():   int socket(int domain, int type, int protocol);           domain: 协议版本                       AF_INET： IPV4                        AF_INET6： IPV6                        AF_UNIX &amp; AF_LOCAL：本地通信                        AF_PACKET:链路层通信                        type:协议类型                       SOCK_STREAM 流式, 默认使用的协议是TCP协议                        SOCK_DGRAM 报式, 默认使用的是UDP协议                          也就是说流式不一定是TCP，报式也不一定是UDP。                 protocal:              一般填0, 表示使用对应类型的默认协议.                返回值:                       成功: 返回一个大于0的文件描述符                        失败: 返回-1, 并设置errno                   套接字socket实际上是对内核中网络相关的代码的抽象。套接字的三个参数domain、type、protocol实质上都是用于从抽象的套接字到具体的网络代码的分类。domain参数决定了图中所示的第二层通信域，type决定了第三层的通信模式，protocol决定了第四层真正的通信协议。      setsockopt   int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);      sockfd：套接字描述符。   level：选项级别，这里使用IPPROTO_TCP表示 TCP 协议级别。   optname：具体的选项名称。   optval：指向包含选项值的缓冲区。   optlen：选项值的长度。   bind:   int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);      sockfd：            参数说明：由 socket() 函数返回的套接字描述符。           addr：            参数说明：指向一个特定地址结构的指针，该结构包含要绑定的地址和端口信息。具体结构类型取决于 domain 参数，如 struct sockaddr_in（IPv4）或 struct sockaddr_in6（IPv6）。           addrlen：            参数说明：地址结构的长度。           bind用于把被系统当作文件标识符的套接字标识符和套接字地址绑定起来。上层只需要知道套接字的标识符（当作文件的标识符来使用），不用在意通信中的细节（两端的地址，通信协议等）。   getsockname:   int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);      sockfd：            参数说明：套接字描述符。           addr：            参数说明：指向一个地址结构的指针，用于存储获取到的本地地址信息。           addrlen：            参数说明：一个指向 socklen_t 类型变量的指针，输入时表示 addr 所指向的地址结构的长度，输出时被修改为实际存储的地址长度。           listen   int listen(int sockfd, int backlog);      sockfd：            参数说明：由 socket() 函数返回且已绑定地址的套接字描述符。           backlog：            参数说明：指定在拒绝连接之前，可以排队等待的最大连接数。           connnect:   int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);      sockfd：            参数说明：由 socket() 函数返回的套接字描述符。           addr：            参数说明：指向一个地址结构的指针，包含了要连接的服务器的地址和端口信息。           addrlen：            参数说明：地址结构的长度。              accept:   int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);      sockfd：            参数说明：由 socket() 和 listen() 函数设置为监听状态的套接字描述符。           addr：            参数说明：指向一个地址结构的指针，用于存储客户端的地址信息。           addrlen：            参数说明：一个指向 socklen_t 类型变量的指针，输入时表示 addr 所指向的地址结构的长度，输出时被修改为实际存储的地址长度。           recv   send   select:   int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);      nfds：            参数说明：要监视的文件描述符的最大值加 1。           readfds：            参数说明：指向一个文件描述符集合的指针，用于监视可读的文件描述符。           writefds：            参数说明：指向一个文件描述符集合的指针，用于监视可写的文件描述符。           exceptfds：            参数说明：指向一个文件描述符集合的指针，用于监视异常情况的文件描述符。           timeout：            参数说明：指定等待的时间限制。如果为 NULL，则表示无限等待。是一个指向 struct timeval 结构的指针，该结构定义了等待的时间（秒和微秒）。           Linux Poll 使用方法和实现_linux poll怎么写-CSDN博客   进程间通信–socketpair   socketpair 用于在进程之间创建两个套接字使两个线程可以跨进程通信。   #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int socketpair(int domain, int type, int protocol, int sv[2]);   domain:协议族。例如，AF_UNIX用于本地通信，AF_INET用于IPV4，AF_INET6于IPV6   type:套接字类型，对应TCP和UDP。例如，SOCK_STREAM、SOCK_DGRAM和SOCK_RAW      SOCK_CLOEXEC:执行exec时自动关闭,用于多线程使用中避免内存泄漏，避免竞态。socketpair中使用这个类别的套接字保证父子进程的套接字同时关闭。    protocol：用于确定协议，一般为0   sv[2]：用于储存套接字的标识符，这两个套接字是socketpair创建出的用于全双工跨进程线程间通信的。  ","categories": ["笔记"],
        "tags": [],
        "url": "/%E7%AC%94%E8%AE%B0/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/",
        "teaser": null
      },{
        "title": "Zero mq",
        "excerpt":"Zero MQ      We took a normal TCP socket, injected it with a mix of radioactive isotopes stolen from a secret Soviet atomic research project, bombarded it with 1950-era cosmic rays, and put it into the hands of a drug-addled comic book author with a badly-disguised fetish for bulging muscles clad in spandex.                                                                                                           —-Pieter Hintjens, CEO of iMatix   精简版：人们受够了套接字！他实在太混乱了！ZMQ就是这个混乱网络世界的救主。                                                                                                   —-笔者      ZMQ是一个高性能的异步消息传递库，提供了一个无需消息代理的消息队列（MQ）。ZMQ通过多种传输方式（TCP, in-process, inter-process, multicast, WebSocket and more）实现了常见的消息传递模式（pub/sub, request/reply, client/server and others）从而使进程间消息传递变得与线程间消息传递一样简单。这样可以保持代码清晰、模块化，并且非常易于扩展。   本质上ZMQ和Redis、RabbitMQ、RocketMQ、Kafka这类的消息中间件并不相同。ZMQ更类似于一个对socket的封装，包含了网络层协议。因此他更快速也无需消息代理（message broker)。当然，这也意味着更底层更复杂（这就是力量的代价：MQ +4/+4，当发生底层错误时消灭程序员）。   中文zguide   一、 ZMQ模型                  [1. Basics       ØMQ - The Guide](https://zguide.zeromq.org/docs/chapter1/#Why-We-Needed-ZeroMQ)           一文带你入门了解“零之禅“消息队列ZeroMQ-CSDN博客   重头戏！ZeroMQ的管道模式详解：ZMQ_PUSH、ZMQ_PULL_zmq push pull-CSDN博客   1 请求/应答模型(REQ/REP)–1v1   1.1 原理      REQ-REP 套接字的步调一致。客户端循环发出zmq_send()，然后发出 zmq_recv()（如果仅此而已，则只发出一次）。执行任何其他顺序（例如，连续发送两条消息）将导致 send或recv调用返回 -1 代码。同样，服务会根据需要按顺序发出zmq_recv()，然后发出 zmq_send() 。   1.2 服务器端   服务器创建一个响应类型的套接字（稍后您将了解有关请求-响应的更多信息），将其绑定到端口 5555，然后等待消息。您还可以看到我们没有任何配置，我们只是发送字符串。   //  Hello World server #include &lt;zmq.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;assert.h&gt;  int main (void) {     //  Socket to talk to clients     void *context = zmq_ctx_new ();     void *responder = zmq_socket (context, ZMQ_REP);     int rc = zmq_bind (responder, \"tcp://*:5555\");     assert (rc == 0);      while (1) {         char buffer [10];         zmq_recv (responder, buffer, 10, 0);         printf (\"Received Hello\\n\");         sleep (1);          //  Do some 'work'         zmq_send (responder, \"World\", 5, 0);    }     return 0; }   1.3 客户端   客户端创建一个请求类型的套接字，连接并开始发送消息。send和方法receive都是阻塞的（默认情况下）。对于接收来说很简单：如果没有消息，该方法将阻塞。对于发送来说，它更复杂，并且取决于套接字类型。对于请求套接字，如果达到高水位或没有连接对等点，该方法将阻塞。   //  Hello World client #include &lt;zmq.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt;  int main (void) {     printf (\"Connecting to hello world server…\\n\");     void *context = zmq_ctx_new ();     void *requester = zmq_socket (context, ZMQ_REQ);     zmq_connect (requester, \"tcp://localhost:5555\");      int request_nbr;     for (request_nbr = 0; request_nbr != 10; request_nbr++) {         char buffer [10];         printf (\"Sending Hello %d…\\n\", request_nbr);         zmq_send (requester, \"Hello\", 5, 0);         zmq_recv (requester, buffer, 10, 0);         printf (\"Received World %d\\n\", request_nbr);     }     zmq_close (requester);     zmq_ctx_destroy (context);     return 0; }   #注意:字符串安全性#      C语言中的字符串并不安全！     zmq_send只关注会发送的字符的数量，这意味着它是可以发送带有空字节的字符串的。这会导致不正确的字符串格式—没有安全的终止。如果接收方的buffer中剩余的位置不是空字符（尽管大部分情况下是这样），将会导致字符串读写的错误     zmq_send (requester, \"Hello\", 6, 0);       一般默认的我们认为zmq_send使用的字符串的长度是不带终止符的长度，也就是strlen得到的长度。也就是说，网络中传输的字符串不是C语言中的字符串，需要额外的格式化处理。     我们选择在接收端对接收的字符进行处理。在实际的使用之中，有两种方法：1.每次memset接收缓存为0；2.需要对接收缓存的字符串多读一位然后使用空字符截取，好消息是我们从0开始，所以recv的返回值就是那个多一位，该赋值为空字符的位置。两种方法的思路其实是一样的，为recv到的网络字符添加空字符结尾，使他结束在应该有的位置。     //  Receive ZeroMQ string from socket and convert into C string //  Chops string at 255 chars, if it's longer static char * s_recv (void *socket) {     char buffer [256];     int size = zmq_recv (socket, buffer, 255, 0);     if (size == -1)         return NULL;     if (size &gt; 255)         size = 255;     buffer [size] = '\\0';     /* use strndup(buffer, sizeof(buffer)-1) in *nix */     return strdup (buffer); }       可以使用zhelpers.h头文件对c语言进行安全的收发。点击此处查看具体源码。     ps. 不正确的使用send，在router中会导致身份识别的错误请务必注意！    2  发布/订阅模型(PUB/SUB)–1vN   2.1 原理      单向数据分发即服务器将更新流推送到一组客户端。这股更新流可以理解为无始无终永不结束的广播。   2.2 发布者（生产者）   //  Weather update server //  Binds PUB socket to tcp://*:5556 //  Publishes random weather updates  #include \"zhelpers.h\"  int main (void) {     //  Prepare our context and publisher     void *context = zmq_ctx_new ();     void *publisher = zmq_socket (context, ZMQ_PUB);     int rc = zmq_bind (publisher, \"tcp://*:5556\");     assert (rc == 0);      //  Initialize random number generator     srandom ((unsigned) time (NULL));     while (1) {         //  Get values that will fool the boss         int zipcode, temperature, relhumidity;         zipcode     = randof (100000);         temperature = randof (215) - 80;         relhumidity = randof (50) + 10;          //  Send message to all subscribers         char update [20];         sprintf (update, \"%05d %d %d\", zipcode, temperature, relhumidity);         s_send (publisher, update);     }     zmq_close (publisher);     zmq_ctx_destroy (context);     return 0; }   2.3 订阅者（消费者）   //  Weather update client //  Connects SUB socket to tcp://localhost:5556 //  Collects weather updates and finds avg temp in zipcode  #include \"zhelpers.h\"  int main (int argc, char *argv []) {     //  Socket to talk to server     printf (\"Collecting updates from weather server...\\n\");     void *context = zmq_ctx_new ();     void *subscriber = zmq_socket (context, ZMQ_SUB);     int rc = zmq_connect (subscriber, \"tcp://localhost:5556\");     assert (rc == 0);      //  Subscribe to zipcode, default is NYC, 10001     const char *filter = (argc &gt; 1)? argv [1]: \"10001 \";     rc = zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE,                          filter, strlen (filter));     assert (rc == 0);      //  Process 100 updates     int update_nbr;     long total_temp = 0;     for (update_nbr = 0; update_nbr &lt; 100; update_nbr++) {         char *string = s_recv (subscriber);          int zipcode, temperature, relhumidity;         sscanf (string, \"%d %d %d\",             &amp;zipcode, &amp;temperature, &amp;relhumidity);         total_temp += temperature;         free (string);     }     printf (\"Average temperature for zipcode '%s' was %dF\\n\",         filter, (int) (total_temp / update_nbr));      zmq_close (subscriber);     zmq_ctx_destroy (context);     return 0; }   关键在于 zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE,filter, strlen (filter)); 一步为subscriber设置订阅。PUB-SUB 套接字对是异步的。客户端循环执行zmq_recv()（如zmq_hello_world_client果仅此而已，则执行一次）。尝试向 SUB 套接字发送消息将导致错误。同样，服务会根据需要尽可能频繁地执行 zmq_send()，但不得在 PUB 套接字上执行zmq_recv() 。   理论上，对于 ZeroMQ 套接字，哪一端连接和哪一端绑定并不重要。然而，在实践中存在一些未记录的差异。一般的，在PUB端bind在SUB端connect。      在通常的套接字编程中，bind 和conect一般分别用于服务器端和客户端。bind用于服务器监听指定的地址和端口，connect用于客户端连接到指定地址的服务器。     在ZMQ中,在那一段bind或connect并无影响（为什么？）但实际上还是有差异的（毕竟底层的套接字不同）    #注意:缓慢加入问题#      ”缓慢加入“问题会导致SUB永远没办法接收到PUB发送的最开始的信息（建立连接需要时间，这段时间中PUB很可能已发出很多信息！）需要对发布者和订阅者的同步。    3 推拉模型（PUSH/PULL)–1vNv1   管道模式或者叫并行流水线(ventilator/worker/sink)   3.1 原理      可同时执行多项任务的发送者ventilator、一组处理任务的工作者worker、从工作进程收集结果的接收者sink。发送者将任务分配给工人并行的处理，工人将各自的成果交给接收者。实质上是push和pull两种套接字上的操作！!本质是单向的套接字接口。   3.2 发送者   //  Task ventilator //  Binds PUSH socket to tcp://localhost:5557 //  Sends batch of tasks to workers via that socket  #include \"zhelpers.h\"  int main (void)  {     void *context = zmq_ctx_new ();      //  Socket to send messages on     void *sender = zmq_socket (context, ZMQ_PUSH);     zmq_bind (sender, \"tcp://*:5557\");      //  Socket to send start of batch message on     void *sink = zmq_socket (context, ZMQ_PUSH);     zmq_connect (sink, \"tcp://localhost:5558\");      printf (\"Press Enter when the workers are ready: \");     getchar ();     printf (\"Sending tasks to workers...\\n\");      //  The first message is \"0\" and signals start of batch     s_send (sink, \"0\");      //  Initialize random number generator     srandom ((unsigned) time (NULL));      //  Send 100 tasks     int task_nbr;     int total_msec = 0;     //  Total expected cost in msecs     for (task_nbr = 0; task_nbr &lt; 100; task_nbr++) {         int workload;         //  Random workload from 1 to 100msecs         workload = randof (100) + 1;         total_msec += workload;         char string [10];         sprintf (string, \"%d\", workload);         s_send (sender, string);     }     printf (\"Total expected cost: %d msec\\n\", total_msec);      zmq_close (sink);     zmq_close (sender);     zmq_ctx_destroy (context);     return 0; }   当工作者准备好时，发送者发送一个开始标志给sink让其准备好接收工人的成果。这么做的原因是和发布订阅模型一样可能存在丢失的信息，所以必须的先让接收者做好接收的准备，再让其得到工作者发出的信息。   3.3 工作者   //  Task worker //  Connects PULL socket to tcp://localhost:5557 //  Collects workloads from ventilator via that socket //  Connects PUSH socket to tcp://localhost:5558 //  Sends results to sink via that socket  #include \"zhelpers.h\"  int main (void)  {     //  Socket to receive messages on     void *context = zmq_ctx_new ();     void *receiver = zmq_socket (context, ZMQ_PULL);     zmq_connect (receiver, \"tcp://localhost:5557\");      //  Socket to send messages to     void *sender = zmq_socket (context, ZMQ_PUSH);     zmq_connect (sender, \"tcp://localhost:5558\");      //  Process tasks forever     while (1) {         char *string = s_recv (receiver);         printf (\"%s.\", string);     //  Show progress         fflush (stdout);         s_sleep (atoi (string));    //  Do the work         free (string);         s_send (sender, \"\");        //  Send results to sink     }     zmq_close (receiver);     zmq_close (sender);     zmq_ctx_destroy (context);     return 0; }   工作者得到发送者的任务后停止一段时间然后发出成果给接收者。但这里隐含一个需求——所有的工作者需要同步的开始工作。也就是说我们需要额外的操作实现同步的并行处理。   同时，发送者需要均匀的为每一位工作者分配任务，称为**负载均衡**。   3.4 接收者   //  Task sink //  Binds PULL socket to tcp://localhost:5558 //  Collects results from workers via that socket  #include \"zhelpers.h\"  int main (void)  {     //  Prepare our context and socket     void *context = zmq_ctx_new ();     void *receiver = zmq_socket (context, ZMQ_PULL);     zmq_bind (receiver, \"tcp://*:5558\");      //  Wait for start of batch     char *string = s_recv (receiver);     free (string);      //  Start our clock now     int64_t start_time = s_clock ();      //  Process 100 confirmations     int task_nbr;     for (task_nbr = 0; task_nbr &lt; 100; task_nbr++) {         char *string = s_recv (receiver);         free (string);         if (task_nbr % 10 == 0)             printf (\":\");         else             printf (\".\");         fflush (stdout);     }     //  Calculate and report duration of batch     printf (\"Total elapsed time: %d msec\\n\",          (int) (s_clock () - start_time));      zmq_close (receiver);     zmq_ctx_destroy (context);     return 0; }**   接收者需要均匀的从工作者处接收成果，也就是**公平排队**的接收机制。   3.5  负载均衡和公平排队      注意:不完全的负载均衡#      和发布/订阅模型一样，流水线模式也有着很严重的同步问题需要研究。     PUSH 套接字无法正确实现负载平衡。如果您同时使用 PUSH 和 PULL，并且您的一个工作进程收到的消息比其他工作进程多得多，这是因为该 PULL 套接字比其他工作进程加入得更快，并且在其他工作进程设法连接之前就获取了大量消息。     如果您想要正确的负载平衡，您可能需要查看 第 3 章 - 高级请求-回复模式中的负载平衡模式。    4 独占套接字对（Exclusive pair)–线程间通信   —-todo:   5 路由模式（Router/Dealer)–NvN   Router/Dealer模式是异步版的的REQ/REP模式。在实际的高访问量高并发性应用当中，往往有者多个服务器共同完成请求任务，甚至承载着不同的任务（微服务？）。此时可以通过一个消息中间人（message broker）（类似于Nginx的反向代理服务器？作用于不同的层次）实现请求应答。   router实际上在使用中更多的起到的是消息中间人的效果！   zeromq中两个dealer 通过一个router进行通信 - fengbohello - 博客园   6 有代理的发布/订阅模型（XPUB/XSUB）   —-todo:   二、ZMQ套接字机制   1 ZMQ上下文的创建和销毁：   在ＺＭＱ中，使用ZMQ上下文管理所有的套接字。ZMQ使用一个称为上下文的结构体管理套接字——一个zmq::ctx_t类型的结构体,用于管理单个进程的所有套接字。一般的我们在一个进程开始时使用zmq_ctx_new()去创建上下文，在进程结束时使用zmq_ctx_term() / zmq_ctx_destroy()去销毁上下文,释放所有资源。如果使用fork，则是在fork之后和子线程的开头创建上下文。一般来说在子线程进行具体的zmq操作，在父线程进行线程管理。      在之前的zmq版本中使用的是zmq_init()和zmq_term()去创建和销毁上下文。但这样并没有表现出zmq上下文的作用，为了强调这是上下文的创建和销毁而修改了接口。更主要的，这为了提示你还需要释放zmq_msg结构体和套接字才能实现完整的释放，不导致资源泄露。换句话说，实际上ZMQ就是ZMQ上下文。    在ZMQ当中，一个完整的资源释放过程被分为了三个部分：释放zmq_msg_t、释放套接字、释放zmq_ctx_t。           释放zmq_msg_t： 在使用时尽量使用zmq_send()和zmq_recv()，而不是zmq_msg_send()和zmq_msg_recv()。通过这种方法来避免zmq_msg_t结构体的使用。如果非要使用的话，需要在每次使用之后立刻调用zmq_msg_close()来关闭消息结构体，避免内存泄漏。            释放套接字： 在连接的套接字使用完毕后，需要及时的使用zmq_close()关闭套接字，因为上下文的释放仅能在其拥有的所有套接字都释放完毕后进行。此时需要为未关闭的套接字设置一个较小的LINGER值（等待时间，比如1s），然后关闭所有的套接字。            释放zmq_ctx_t：zmq_ctx_destroy()的过程是一个复杂而痛苦的过程，因为上下文释放时可能仍有着悬挂的连接和进行的发送，也就是上下文对应的套接字没有完全释放。此时zmq_ctx_destroy()会一直被挂起。              释放zmq上下文的zmq_ctx_term()的流程是：                             任何当前在“context”内打开的套接字上正在进行的阻塞操作应立即以错误代码 ETERM 返回。除了zmq_close()之外，在“context”内打开的套接字上的任何进一步操作都应因错误代码 ETERM 而失败。                              中断所有阻塞调用后，zmq_ctx_term()应阻塞，直到：                                         所有在“context”内打开的套接字都已使用zmq_close()关闭                                          zmq_send()发送的所有消息要么已实际传输到网络对等方，要么套接字的延迟时间已过期（由ZMQ_LINGER套接字选项设置）。                                                    2 ＺＭＱ上下文对于套接字的管理：   ZMQ上下文对于套接字的管理主要包括：           创建和销毁套接字，它们共同构成套接字生命的循环（参见zmq_socket()、zmq_close()）。            通过设置选项并在必要时检查它们来配置套接字（参见zmq_setsockopt()、zmq_getsockopt()）。            通过创建 ZeroMQ 连接将套接字插入网络拓扑（参见zmq_bind()、zmq_connect()）。            通过在套接字上写入和接收消息来使用套接字传输数据（参见zmq_msg_send()、zmq_msg_recv()）。       2.1 ZMQ套接字的创建：   —-todo:   2.2 ZMQ 的套接字选项：   —-todo:   2.3 ZMQ套接字绑定和连接：   ZMQ允许不严格的区分bind和connect，这使得其使用更加简单。但是正如之前在ZMQ模式中提到的，他们实际上有着微妙不同，但我们只需要按照标准的方法来使用它就可以避免。一般来说，执行zmq_bind()的节点是***“服务器”***，位于***众所周知的网络地址***上，而执行zmq_connect()的节点是***“客户端”***，具有***未知或任意的网络地址***。因此，我们说“将套接字绑定到端点”和“将套接字连接到端点”，端点是众所周知的网络地址。   2.4 ZMQ的发送和接收：   ＺＭＱ与TCP套接字的区别：           可以使用任意传输方式进行传输（ inproc、ipc、tcp、pgm或epgm）。zmq_inproc()、zmq_ipc()、zmq_tcp()、zmq_pgm()和zmq_epgm()。            一个套接字可能有许多传出连接和许多传入连接。            没有zmq_accept () 方法。当套接字绑定到端点时，它会自动开始接受连接。            网络连接由ZMQ自动管理，你无法直接处理这些连接。如果网络连接中断（例如，如果对等方消失然后又回来），ZeroMQ 将自动重新连接。            ZMQ不是一个能承载协议的中间载体，只能使用ZMQ_ROUTER_RAW套接字选项支持正确的读写HTTP等协议。这意味着他不能兼容现有的协议（like:HTTP，因为它们基于socket而ZMQ对socket进行了封装）。尽管可以使用ZMQ实现类似的协议但他们本质不同（取决于对端的协议，更广泛的设备使用的是普通的协议）。。            ZMQ使用一个I/O线程来处理所有的网络连接，处于不断轮询的poll/select之中。       三、ZMQ程序接口   void *zmq_ctx_new ();           返回值：                       成功: 返回ZMQ上下文content，是一个zmq_ctx_t的结构体                        失败: 返回NULL, 并设置errno                   void *zmq_ctx_term ();           返回值:                       成功: 返回0                        失败: 返回-1, 并设置errno                   三、ZMQ源码结构   https://www.iteye.com/blog/watter1985-1736023   zeromq源码分析笔记之架构（1） - zengzy - 博客园   zmq源代码分析 - mailbox_t_zmq代码-CSDN博客   ZMQ API reference   The Architecture of Open Source Applications (Volume 2)ZeroMQ  ","categories": ["笔记"],
        "tags": ["中间件","消息队列","异步通信"],
        "url": "/%E7%AC%94%E8%AE%B0/Zero-MQ/",
        "teaser": null
      },{
        "title": "锐华嵌入式操作系统",
        "excerpt":"锐华嵌入式操作系统   CH 1—ReDE   一、 ReDE介绍   ReDe是基于Eclipse开发的集成嵌入式系统开发平台。构建和项目管理依赖于GCC交叉编译工具链和make工具（但会操作简单点，自动生成Makefile）   二、ReDe使用   1. 建立工程   Reworks的项目是建立在一个拥有系统镜像的自引导工程之上的。   一般的，在项目文件中建立一个自引导工程和多个可下载工程和库工程。通过自引导工程引用别的工程的内容，将所有的文件写入elf的系统镜像之中。   也可以在运行好的Reworks系统上通过库工程L和可下载工程D动态的加卸载.o和.a文件。           自引导工程B： 生成可以直接在目标机上运行的目标代码。编译生成.bin和.elf文件。            库工程L: 生成可以被其他库引用的库文件。编译生成.a文件。            可下载工程D: 生成可以下载到目标机运行的文件。编译生成.o和.out文件。            BSP工程: 该工程提供了BSP工程建立、代码模板自动导入、BSP库构建与ReWorks自引导工程一体化调试、BSP资源组建配置与发布等功能。            自定义工程： 允许用户自定义包括makefile的工程。            资源组件工程： 对工程的一系列属性进行了配置。可在自引导工程、库工程、可下载工程的资源配置模块中应用。（资源配置模块就是资源组件工程？是的）            目标板资源工程：定义在目标系统上运行所需的最低资源集合       2. 配置系统资源   出于嵌入式系统的特性考虑（功耗、资源、性能、价格等…），需要对完整的系统根据需求进行定制裁剪。根据具体的调试和应用需要，各异的设置开发板上所需的系统资源。   ReDe中可以直接在.syscfg中勾选保存所需的功能。具体功能需要那些系统资源请看各自功能的文档。   常用的资源配置：   板级支持包–网卡驱动、控制台配置   开发和运行支持–运行时工具–任务调试支持   3. 构建工程   对工程中的文件进行编译，自引导工程、库工程、可下载工程具有默认的构建配置（自动生成的makefile) 。可以在工程属性中管理自动生成的makefile和make指令。   连接可下载/库工程到自引导工程（系统调试）：   右键–属性–C++构建–设置–GCC C++ linker–杂项–附加对象文件–选择   为项目添加依赖（先构建依赖）：   右键–属性–项目引用–选择   为make all 添加选项：   右键–属性–C/C++构建–构建器设置–去除勾选使用默认构建命令–添加选项。   例如：make -j10 all开启多线程编译。   4. 连接目标板   ReDe和开发板的Uboot通过USB串口和RJ45以太网接口连接。串口用于和开发板直接沟通配置Uboot。以太网接口用于进行FTP通信。   此时还没有拷贝镜像！更没有启动系统！和系统资源配置没关系！只是在和U-Boot交互   FTP方式下载系统镜像：      注意：网卡需要设置的IP地址。这次用的192.168.1.110，取决于板上写入的服务器地址（uboot tftp配置的地址，可以更改）     setenv ipaddr 192.168.1.1 setenv serverip 192.168.1.31 saveenv            更改前本机的ip地址，软件平台室服务器。    USB串口设置：左上角选择终端打开设备管理器选择对应的COM号，设置端口速度为115200。（这是USB连接的线用来和uboot的引导程序命令行进行交互）运行过程中不断敲击回车键（保证能中断他的自动引导，其实一下好像就行）   TFTP服务器设置：   右键存在需下载文件的项目目录–设置TFTP路径   或   打开窗口–显示视图–TFTP服务–启动TFTP 服务（依然是上次设置的路径）   5. Uboot启动系统镜像   在串口界面输入命令： tftpboot 0x80100000 reworks 使用TFTP服务从服务器获得reworks.elf放到地址0x80100000   go 0x80100000 从地址运行系统，进行uboot，启动reworks系统镜像      地址是根据不同开发板而不同的。    6. 调试   6.1 系统调试（本地调试）：   .o文件跟随系统镜像写入开发板。参见在自引导工程中引用可下载工程的.o文件部分。直接烧入镜像进行测试。      在自引导工程中引用可下载工程的.o文件：     右键属性–c++构建–设置–c++linker–杂项–附加对象文件–输入命令“${workspace_loc:/projectName/gnuXXX/boardName/projectName.out}”    6.2 任务调试（远程调试）：   .o文件在系统启动以后在写入并加载。首先需要通过TFTP等方式拷贝系统镜像，使用Uboot启动系统。使用的是GNU GDB工具进行测试。   0、系统资源配置：   运行时工具–任务调试支持、协同总线组件、远程接卸载 和 板级支持包–网卡驱动   1、运行系统镜像：   勾选任务调试支持后系统会暂停于usrInit处。   2、连接目标机：   左下角目标机系统管理器，第一个图标：添加连接。   目标机名填写系统资源配置中网卡的IP(和TFTP中的IP并不一定相同)      U-boot和Reworks是两个不同的系统。U-boot是引导系统的系统。     有bug，必须更改一次ip地址才可以使用！    3、调试配置：   右键项目–调试–调试配置–自引导应用程序–程序   右键项目–调试–调试配置–自引导应用程序–目标机   4、开始调试：   等同于GNU GDB，略   6.3 远程加卸载：   对非核心的.o文件在系统中动态的加载或者卸载。实质是把.out文件下载到 /clb/dynamicModuleFolder/路径下，然后运行ld unld指令,然后删除可执行文件。等价于TFTP获取文件+加载模块+删除文件。   与直接镜像link然后构建写入镜像不同。直接写入镜像的模块无法卸载，在/clb/dynamicModuleFolder/路径下没有.out文件      TFTP命令     tftp (\"ip\", \"path/remotefile\", \"get/put\",“ascii/netascii/binary/image/octet”, \"path/localfile\")     符号表命令     ld 加载.out/.o文件     unld 卸载已加载的.out/.o文件     unld_by_module_name 通过模块名称卸载已加载的.out/.o文件     unld_by_module_id 通过模块ID卸载已加载的.out/.o文件     reld 重新加载.out/.o文件     module_info 显示已加载的.out/.o文件     symbol_lkup 查找指定的符号信息     lkup 显示包括指定名称的所有符号信息    0、系统资源配置： 远程加卸载、符号表、网卡   1、目标及启动系统： 略   2、连接目标机： 略   3、加卸载： 左上角加载–加载配置–设置目标机、动态加载   4、符号表同步： 何意？   6.4 仿真调试：Qumu   CH 2—系统命令行Shell   一、Shell介绍   1.1 Reworks Shell命令   i   oi   stackuse   cpuuse   1.2 反汇编   在软件运行过程中只要有shell线程工作就可以使用pthread_show_stackframe命令获得任务运行的堆栈，再使用arrch64-objdump-elf -C -x -S可以查看反汇编的.elf源码，方便进行调试。   任务堆栈：   pthread_show_stackframe   objdump反汇编工具：  ","categories": ["笔记"],
        "tags": [],
        "url": "/%E7%AC%94%E8%AE%B0/%E9%94%90%E5%8D%8E%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",
        "teaser": null
      },{
        "title": "Cmake笔记",
        "excerpt":"Cmake笔记   Cmake介绍   Cmake是一种与平台无关的自动控制项目编译过程的工具（自动生成makefile文档）。只需要配置CMakeList.txt就可以自动的根据平台生成Makefile，方便的跨越多个平台进行编译。   Cmake说明文档   cmake是什么？cmake的特性和编译原理（cmake原理和cmake编译过程）   【C++】Cmake使用教程（看这一篇就够了）-CSDN博客      不是已经有了makefile去实现编译控制，为什么还需要Cmake?     Maybe:控制编译的对象范围不同？     Answer:Cmake为了方便的自动生成可以跨平台的makefile，直接写makefile可以实现但是复杂    Cmake的常用语法   初始化：       添加cmake版本要求, 添加project名称   cmake_minimum_required (VERSION 2.8) project (project_name)   使用变量：   指定头文件搜索路径：   include_directories (test_func test_func1)   编译可执行文件：       直接编译.c文件   add_executable(main main.c testFunc.c)       将目录中的所有源文件存在变量中   aux_source_directory(. SRC_LIST)       编译变量指定的文件   add_executable(main ${SRC_LIST})       设置二进制文件的输出位置：   set (EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)   添加库文件：    编译源代码归档成动态和静态库。   add_library (libname SHARED/STATIC ${SRC_LIST})   设置最终生成的库的名字   set_target_properties (libname PROPERTIES OUTPUT_NAME \"libname \")   设置库的输出路径   set (LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)   链接库和可执行文件：   在路径下查找库并把绝对路径存放在变量中   find_library(LIB_PATH libname HINTS ${PROJECT_SOURCE_DIR}/lib)   链接目标文件和库文件   target_link_libraries (target_file ${LIB_PATH})   添加编译选项：   add_compile_options(-std=c++11 -Wall)    部分编译：   添加编译子目录：   add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])           source_dir 源代码目录       指定一个具有cmakelist和源代码的目录，将其作为编译的子目录            binary_dir 二进制代码目录       指定cmake输出的二进制文件所在的目录            EXCLUDE_FROM_ALL标记       指定将添加的子目录从make all 中移除          添加编译子目录是为了让源码的编译结构更加清晰，可以更好的使用选项管理编译过程。       文件操作   file(MAKE_DIRECTORY path/to/directory)add_library (libname SHARED/STATIC ${SRC_LIST})      ","categories": ["笔记"],
        "tags": [],
        "url": "/%E7%AC%94%E8%AE%B0/Cmake%E7%AC%94%E8%AE%B0/",
        "teaser": null
      },{
        "title": "Gdb",
        "excerpt":"GDB（GNU Debugger）是一款强大的调试工具，主要用于调试 C、C++ 和其他编程语言编写的程序。以下是 GDB 的使用方法：   一、启动 GDB           编译程序时加上调试信息              在编译程序时，使用 -g 选项可以让编译器生成调试信息，以便 GDB 能够更好地进行调试。例如，对于 C 程序，可以使用以下命令进行编译：gcc -g program.c -o program。对于 C++ 程序，可以使用：g++ -g program.cpp -o program。                启动 GDB              启动 GDB 并加载要调试的程序。在命令行中输入 gdb program，其中 program 是要调试的程序的名称。           二、基本命令           run（或 r）              运行程序。在 GDB 中输入 run 命令后，程序将开始执行。如果程序需要命令行参数，可以在 run 命令后面加上参数，例如：run arg1 arg2。                break（或 b）              设置断点。可以在程序的特定行号、函数名或地址处设置断点。例如，要在第 10 行设置断点，可以输入 break 10。要在名为 main 的函数处设置断点，可以输入 break main。                next（或 n）              执行下一行代码，但不进入函数内部。                step（或 s）              执行下一行代码，如果是函数调用，则进入函数内部。                continue（或 c）              继续执行程序，直到遇到下一个断点或程序结束。                print（或 p）              打印变量的值。例如，要打印变量 x 的值，可以输入 print x。                backtrace（或 bt）              打印调用栈信息，显示当前程序的执行路径。                quit（或 q）              退出 GDB。           三、查看变量和内存           info locals              显示当前函数的局部变量及其值。                info args              显示当前函数的参数及其值。                x /&lt;format&gt; &lt;address&gt;              检查内存地址处的值。&lt;format&gt; 可以是不同的格式说明符，例如 x/d 表示以十进制格式显示整数，x/s 表示以字符串格式显示内存内容。           四、条件断点   可以设置条件断点，只有当满足特定条件时，断点才会生效。例如，要在变量 x 等于 10 时才中断程序，可以输入 break 10 if x == 10。   五、多线程调试           info threads              显示当前程序中的所有线程。                thread &lt;thread-id&gt;              切换到指定的线程进行调试。           六、远程调试   可以使用 GDB 进行远程调试，例如调试在另一台机器上运行的程序。这通常需要在目标机器上运行一个调试服务器，并在本地使用 GDB 连接到该服务器。  ","categories": ["笔记"],
        "tags": [],
        "url": "/%E7%AC%94%E8%AE%B0/GDB/",
        "teaser": null
      },{
        "title": "基于jekyll和github page的个人主页搭建经验",
        "excerpt":"基于Jekyll和Github Page的个人主页搭建经验   一、方案选择   大体上讲，搭建个人网站有几种常见的方案技术路线。一种是分为前端和后端，使用web服务器处理web请求的通用网页方案；另一种是使用静态网页生成器将所有网页内容预先生成为静态文件（如 HTML、CSS、JavaScript），然后部署到静态网页托管平台上。   前者是web网页的一般方法，由前端和后端两部分组成。前端负责提供网页的结构、布局和交互等可视化的直接和用户接触的部分，后端负责处理请求的业务逻辑、数据存储和安全性等涉及服务器端的部分。           前端的核心是HTML、CSS、JavaScript三个部分，分别对应了网页的结构、布局和交互处理。除此以外，还有其他基于JavaScript的前端的框架（如 React、Vue.js、Angular）用来简化网页交互的编写。            后端的核心是Web服务器、后端框架和数据库。              Web服务器主要用于连接用户的网页请求和用于处理请求的服务器。具体来说：主要负责处理用户HTTP/HTTPS请求、对后端的服务器进行反向代理和负载均衡。       后端框架则主要用于处理业务逻辑，负责对web服务器代理后的请求进行处理。常见的后端框架有：Python的Django,和Flask、JavaScript的Node.js、Java的Spring等。       数据库则是十分明了的用于存储和管理数据。常见的数据库包括：MySQL、Oracle（关系型数据库）、MongoDB、Redis（非关系型数据库）。           后者是用于生成静态网页的方法，即使用静态网页生成器（如Jekyll、Hugo、Hexo等）预先生成好网页，将之存为不需要服务器端处理的文件（如HTML、CSS、JavaScript）。静态网页可以直接使用静态网页托管平台直接进行部署，如Github Pages、Vercel、Netlify等。   动态网页的灵活性更高，可以处理更多的交互需求，但是需要服务器端的支持，部署较为复杂，需要额外的服务器;静态网页的灵活性较差，但是部署简单，可以直接使用Github Page进行部署（还省去了配置公网IP和网页备案的麻烦）。对比两种方案，静态网页的方案适合个人主页低更新频率，交互性较弱的应用需求。   因此，我最后选择了静态网页的方案，使用Jekyll的Minimal Mistakes主题和Github Pages静态网页托管平台组合的方案搭建了自己的个人主页。   首先，我在运行了ubuntu的虚拟机上下载Jekyll和其所需要的环境。然后，根据自己的使用需要，按照MInimal Mistakes的文档说明修改了_config.yml配置文件，调整了个人主页的一些常用设置。最后使用Github Page的部署功能来部署整个网页。      PS.除了使用模板以外，也可以根据自己需要的格式修改_layout文件夹中的模板。添加自己想要的内容。    二、Jekyll和Minimal Mistakes主题   Jekyll是一个基于 Ruby 语言开发的开源静态网页生成器。其核心原理是将包含文本内容（如 Markdown 文件）、布局模板（如 HTML 模板）和配置文件（如_config.yml）的源文件目录，通过一系列的转换和处理，生成最终的静态网站（HTML、CSS、JavaScript 等文件的集合）。Minimal Mistakes是一个Jekyll的主题，提供了丰富的功能和灵活的配置选项，可以方便地设置美观的网页的布局和样式。   1.部署Jekyll环境   这一步其实来说并不是必要的，只是在本地拥有可以使用Jekyll构建网页的环境对于修改个人主页的一些功能来说会更加的方便。你也不想每次对网页布局之类的细微修改的尝试都要push到github上然后重新等待他慢慢的生成网页吧，这实在是太麻烦了。   首先你需要确保的是你拥有一个Linux的虚拟机环境，不管是VMware或者WSL都可以。我使用的是WSL，可以直接在VScode中使用。非常的方便，用过都说豪用。具体怎么弄我这里就不赘述了，网上有很多教程。           安装 Ruby：       Jekyll 是基于 Ruby 构建的，所以首先需要安装 Ruby。通过以下命令安装 Ruby：       sudo apt - get update     sudo apt - get install ruby - full                安装 Jekyll 和 Bundler（RubyGems 包管理器）：       在安装好 Ruby 后，可以使用 RubyGems 来安装 Jekyll 和 Bundler。在终端（命令提示符或 PowerShell）中输入以下命令：       gem install jekyll bundler                创建项目       a. 新创建项目       jekyll new .           b. 从原有的模板复制一个项目       最简单的方法就是直接使用git clone直接复制这个项目的文件下来。        git clone https://github.com/HONEST-ZH/HONEST-ZH.github.io.git                修改网页       修改_config.yml或者_layout里的布局文件来达到你满意的网页效果。            本地运行尝试       执行以下命令来运行本地运行jekyll网页的服务器，工作的ip地址是127.0.0.1:4000       bundle install bundle exec jekyll serve                重复4-5直到网页满足你的需求。       三、设置Github Page   对于一般的静态网页而言，我们只需要将jekyll项目提交到名为username.github.io的仓库中（名字需要和github的账户名字一致，否则会无效），然后再选择Settings-Pages-Deploy From a Branch，branch-main。完成设置以后，就可以实现静态网页的部署了，Github会在Action中自动新建一个名为pages-build-deployment的工作流，每次选定的分支（main）上发生推送时会自动地构建和部署网页。      但是这里因为我使用了Minimal Mistakes模板的原因，网页是没有办法使用这种方法的直接生成的。网页在编译时会报错，找不到模板的Gem包。         这是因为默认的pages-build-deployment工作流没有去下载所需要的依赖，而缺少了Jekyll模板。解决这个问题的方法也很简单，就是自己创建一个工作流保证每一次都能把所需要的依赖装好。   1. 创建gh-pages.yml工作流文件   在项目的根目录下创建.github/workflows文件夹然后添加gh-pages.yml文件。   mkdir -p .github/workflows touch .github/workflows/gh-pages.yml   2. 编写gh-pages.yml   在gh-pages.yml文件中写入：   name: GitHub Pages on:   push:     branches:       - main  # 监听的分支 jobs:   build:     runs-on: ubuntu-latest     steps:     - uses: actions/checkout@v2     - name: Set up Ruby       uses: actions/setup-ruby@v1       with:         ruby-version: '3.2'  # 确保使用正确的 Ruby 版本     - name: Install dependencies       run: bundle install     - name: Build the site       run: bundle exec jekyll build     - name: Deploy to GitHub Pages       uses: peaceiris/actions-gh-pages@v3       with:         github_token: $         publish_dir: ./_site   这个工作流在每次检测到main分支上有推送时：下载所需要的Gem包依赖，构建静态网页，将静态网页的文件推送到一个专门用于存储静态网页的分支gh-pages。   3. Github pages从gh-pages分支部署   gh-pages分支被更新后，还没有完成网页的部署。此时需要把github page关注的分支换为gh-pages，根据每次推送到gh-pages上的文件部署静态网页。工作流的结果显示如下图所示，此时就可以在username.github.io中访问个人主页的页面了。      四、网页的使用   1.基本FrontMatter   ---  title: \"文章标题\"  date: 2023-10-20  last_modified_at: 2023-10-21    # 最后修改时间  categories:    - 技术    - ZMQ  tags:    - 消息队列    - 网络编程  toc: true                       # 显示目录  toc_sticky: true               # 固定目录  toc_label: \"目录\"              # 目录标题  toc_icon: \"cog\"               # 目录图标  #图片  header:    image: /assets/images/header.jpg           # 头部大图    teaser: /assets/images/teaser-image.jpg    # 预览图    overlay_image: /assets/images/banner.jpg   # 覆盖图    overlay_color: \"#333\"                      # 覆盖颜色    caption: \"图片来源: [**网站**](链接)\"      # 图片说明    excerpt: \"这是文章摘要，将显示在文章列表中\"    # 文章摘要  # 作者相关  author: Your Name  author_profile: true    # 显示作者信息  # 布局相关  layout: single  classes: wide          # 宽屏显示  # 评论相关  comments: true        # 启用评论  share: true           # 显示分享按钮  # 相关文章  related: true         # 显示相关文章  # 阅读时间  read_time: true       # 显示预计阅读时间  # 导航  sidebar:    nav: \"main\"        # 侧边栏导航  # SEO相关  description: \"这是一段用于SEO的描述\"  keywords: \"关键词1, 关键词2\"  ---   2.AI工具生成顶部配图   使用ChatGPT生成提示词，使用DALLE-3生成图片      3.Markdown文档编写   使用Marktext以方便的编写MarkDown笔记，可以直接粘贴图片。图片可能被以网络链接的方式引用，也可能保存在本地的C:\\Users\\HONEST\\AppData\\Roaming\\marktext\\images\\路径下，需要把图片的路径改成/assets/images/blog_header或者/assets/images/blog     linux路径使用/，windows路径使用\\   ","categories": ["笔记"],
        "tags": ["Github Pages","Jekyll","个人主页"],
        "url": "/%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EJekyll%E5%92%8CGithub-Page%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E6%90%AD%E5%BB%BA%E7%BB%8F%E9%AA%8C/",
        "teaser": null
      },{
        "title": "白色相簿2",
        "excerpt":"前言   不知不觉间，又到了白色相簿的季节。在第一次看动画，因为冬马雪菜春希三人的纠结关系胃疼时，我就早已有所耳闻了——游戏的CC和Coda部分才是白色相簿2的精华。但是直到多年后真正通关了这款被称为“脱宅神作”的Galgame以后，我才后悔我为什么没能早点玩到它。   -Introductory Chapter-     命运的开始,无法挽回的青春   为自己循规蹈矩的人生而不甘的，如同教科书一般的努力、负责、热心肠的模范三好学生——北原春希，想为自己的青春留下最后的回忆。至少要任性一次、至少要装帅一次，这样想着的春希加入了好兄弟武也的轻音乐部，期望着能在学院祭的舞台上大展手脚。尽管只是一个作为吉他候补的拙劣新手，春希也对能够真正参与到“青春”之中而满足。然而，轻音乐部因为坏女人主唱柳原朋而人际关系破裂，整个社团分崩离析，只剩下了武也和春希。跳脱的武也因此早早放弃了学院祭的事情，只剩下不甘心的北原在第三音乐室里独自弹着吉他，为了无谓的目标而努力。   非要压抑的度过这一段人生了吗？在人生中最绚丽的、最青春的时间段，只能把压抑了17年的情感继续压抑下去了吗，只能继续做一个古板、婆婆妈妈的前班长和兢兢业业的做题家了吗？春希这样想着，依然盲目的执拗的进行练习，直到他进行了命运的合奏、听到了天使的歌声——《White Album》。      春希听到了天籁更看到了天使——啊，我的青春就该是这样的！让她加入轻音乐部吧！——为了我贫瘠了17年的青春，为了我压抑了17年的心，为了我…   春希不知道的是，当他为在天台上高歌的小木曾雪菜而倾倒时，还有一个默默为他们伴奏的同桌——冬马和纱。      从这一首共演的《White Album》开始，三人命定一般的故事开始了。     春希的本质实际上是一个善良的努力者，用这边流行的话来就是做题家。对于学生时期的条条框框格外遵守，相信努力就有回报，近乎偏执的执着于帮助他人的白骑士情节持有者。   -Closing Chapter-   -Coda-  ","categories": ["随笔"],
        "tags": ["白色相簿","Galgame"],
        "url": "/%E9%9A%8F%E7%AC%94/%E7%99%BD%E8%89%B2%E7%9B%B8%E7%B0%BF2/",
        "teaser": null
      },{
    "title": "按时间归档",
    "excerpt":"","url": "https://honest.github.io/archive/posts/"
  },{
    "title": "按分类归档",
    "excerpt":"","url": "https://honest.github.io/archive/categories/"
  }]
