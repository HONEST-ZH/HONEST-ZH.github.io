<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://honest-zh.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://honest-zh.github.io/" rel="alternate" type="text/html" /><updated>2025-01-20T03:08:34+00:00</updated><id>https://honest-zh.github.io/feed.xml</id><title type="html">HONEST的个人主页</title><subtitle>这里是HONEST的个人主页，存放我的想法和学习的笔记</subtitle><author><name>HONEST</name><email>2260363172qq.com</email></author><entry><title type="html">使用ghpage分支配置jekyll网页的自定义域名问题</title><link href="https://honest-zh.github.io/%E9%97%AE%E9%A2%98/%E4%BD%BF%E7%94%A8ghpage%E5%88%86%E6%94%AF%E9%85%8D%E7%BD%AEjekyll%E7%BD%91%E9%A1%B5%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E9%97%AE%E9%A2%98/" rel="alternate" type="text/html" title="使用ghpage分支配置jekyll网页的自定义域名问题" /><published>2025-01-20T00:00:00+00:00</published><updated>2025-01-20T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E9%97%AE%E9%A2%98/%E4%BD%BF%E7%94%A8ghpage%E5%88%86%E6%94%AF%E9%85%8D%E7%BD%AEjekyll%E7%BD%91%E9%A1%B5%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E9%97%AE%E9%A2%98</id><content type="html" xml:base="https://honest-zh.github.io/%E9%97%AE%E9%A2%98/%E4%BD%BF%E7%94%A8ghpage%E5%88%86%E6%94%AF%E9%85%8D%E7%BD%AEjekyll%E7%BD%91%E9%A1%B5%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E9%97%AE%E9%A2%98/"><![CDATA[<h1 id="问题描述">问题描述</h1>
<p>最近在阿里云上为我的个人网页购买了一个域名<code class="language-plaintext highlighter-rouge">honest-zh.me</code>,我将<code class="language-plaintext highlighter-rouge">www.honest-zh.me</code>的链接重定向到了我之前在github page上托管的<a href="/笔记/基于Jekyll和Github-Page的个人主页搭建经验/">个人主页</a>。并在github的设置中的page选项的Custom domain里设置为了我的域名。很顺利的，域名可以跳转到我在github page上托管的个人网页网址<code class="language-plaintext highlighter-rouge">honest-zh.github.io</code>上。但当我更新我的博客，ghpage分支重新部署文件后，域名的重定向就失效了！</p>
<h1 id="解决方法">解决方法</h1>
<p>github page使用CNAME的文件管理自定义域名，观察到检测ghpage分支更新并进行部署的Github action工作流里面没有CNAME的设置项，添加<code class="language-plaintext highlighter-rouge">cname: www.honest-zh.me</code>
添加后的文件大致为：</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Deploy to GitHub Pages</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">peaceiris/actions-gh-pages@v3</span>
      <span class="na">with</span><span class="pi">:</span>
        <span class="na">github_token</span><span class="pi">:</span> <span class="s">$</span>
        <span class="na">publish_dir</span><span class="pi">:</span> <span class="s">./_site</span>
        <span class="na">cname</span><span class="pi">:</span> <span class="s">www.honest-zh.me</span>  <span class="c1"># 自定义域名www.honest-zh.me</span>
</code></pre></div></div>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="问题" /><category term="git" /><category term="jekll" /><category term="个人主页" /></entry><entry><title type="html">Systemd和systemctl</title><link href="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/systemd%E5%92%8Csystemctl/" rel="alternate" type="text/html" title="Systemd和systemctl" /><published>2025-01-16T00:00:00+00:00</published><updated>2025-01-16T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/systemd%E5%92%8Csystemctl</id><content type="html" xml:base="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/systemd%E5%92%8Csystemctl/"><![CDATA[<p>systemctl是一个在基于 systemd 的 Linux 系统中用于控制 systemd 系统和服务管理器的命令行工具。systemd 是一个系统和服务管理器，它提供了系统启动、服务管理、日志记录等一系列功能。systemctl命令是与 systemd 进行交互的主要方式，它非常强大且功能丰富。</p>
<h1 id="1-管理服务unit">1. 管理服务（Unit）</h1>
<h2 id="11-启动服务">1.1 启动服务：</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl start <span class="o">[</span>服务名称]
</code></pre></div></div>
<p>例如，启动httpd服务（假设已安装）：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash
sudo systemctl start httpd
</code></pre></div></div>
<h2 id="12-停止服务">1.2 停止服务：</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl stop <span class="o">[</span>服务名称]
</code></pre></div></div>
<p>例如，停止httpd服务：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl stop httpd
</code></pre></div></div>
<h2 id="13-重启服务">1.3 重启服务：</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl restart <span class="o">[</span>服务名称]
</code></pre></div></div>
<p>例如，重启httpd服务，常用于在修改服务配置文件后使其生效：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl restart httpd
</code></pre></div></div>
<h2 id="14-重新加载服务配置">1.4 重新加载服务配置：</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl reload <span class="o">[</span>服务名称]
</code></pre></div></div>
<p>此命令在不重启服务的情况下重新加载服务的配置文件，适用于某些服务可以在运行时重新加载配置而无需完全重启的情况，如nginx：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl reload nginx
</code></pre></div></div>
<h2 id="15-查看服务状态">1.5 查看服务状态：</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl status <span class="o">[</span>服务名称]
</code></pre></div></div>
<p>该命令显示服务当前的运行状态，包括是否正在运行、启动时间、最近一次启动或停止的结果等信息。例如查看vsftpd服务状态：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl status vsftpd
</code></pre></div></div>
<p>输出类似如下内容：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plaintext
● vsftpd.service - vsftpd FTP server
   Loaded: loaded (/lib/systemd/system/vsftpd.service; enabled; vendor preset: enabled)
   Active: active (running) since Mon 2024 - 01 - 01 10:00:00 UTC; 1h ago
  Process: 1234 ExecStart=/usr/sbin/vsftpd /etc/vsftpd.conf (code = exited, status = 0/SUCCESS)
 Main PID: 1234 (vsftpd)
    Tasks: 1 (limit: 4915)
   Memory: 1.2M
   CGroup: /system.slice/vsftpd.service
           └─1234 /usr/sbin/vsftpd /etc/vsftpd.conf
</code></pre></div></div>
<p>其中 “Active: active (running)” 表明服务正在运行。</p>
<h1 id="2-服务开机自启管理">2. 服务开机自启管理</h1>
<h2 id="21-设置服务开机自启">2.1 设置服务开机自启：</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl <span class="nb">enable</span> <span class="o">[</span>服务名称]
</code></pre></div></div>
<p>例如，设置httpd服务开机自启：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl <span class="nb">enable </span>httpd
</code></pre></div></div>
<p>执行后会创建或修改符号链接，将服务单元文件链接到系统启动相关的目录。</p>
<h2 id="22-取消服务开机自启">2.2 取消服务开机自启：</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl disable <span class="o">[</span>服务名称]
</code></pre></div></div>
<p>例如，取消httpd服务开机自启：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl disable httpd
</code></pre></div></div>
<p>此命令会删除相关的符号链接，使服务在系统启动时不再自动启动。</p>
<h2 id="23-查看服务是否开机自启">2.3 查看服务是否开机自启：</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl is - enabled <span class="o">[</span>服务名称]
</code></pre></div></div>
<p>例如，查看httpd服务是否开机自启，若输出为enabled则表示开机自启，若为disabled则表示未设置开机自启：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl is - enabled httpd
</code></pre></div></div>
<h1 id="3-系统管理相关">3. 系统管理相关</h1>
<h2 id="31-启动进入指定运行级别target">3.1 启动进入指定运行级别（target）：</h2>
<p>运行级别在 systemd 中被称为 target。例如，要启动到图形化界面（通常是graphical.target）：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl start graphical.target
</code></pre></div></div>
<p>若要启动到多用户文本界面（multi - user.target）：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl start multi - user.target
</code></pre></div></div>
<h2 id="32-查看当前运行级别target">3.2 查看当前运行级别（target）：</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl get - default
</code></pre></div></div>
<p>输出结果会显示当前默认的启动目标，例如graphical.target或multi - user.target。</p>
<h2 id="33-设置默认运行级别target">3.3 设置默认运行级别（target）：</h2>
<p>例如，将默认运行级别设置为多用户文本界面：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl <span class="nb">set</span> - default multi - user.target
</code></pre></div></div>
<p>若要恢复为图形化界面为默认：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl <span class="nb">set</span> - default graphical.target
</code></pre></div></div>
<h2 id="34-重启系统">3.4 重启系统：</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl reboot
</code></pre></div></div>
<h2 id="35-关闭系统">3.5 关闭系统：</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl poweroff
</code></pre></div></div>
<h2 id="36-挂起系统进入睡眠状态">3.6 挂起系统（进入睡眠状态）：</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl <span class="nb">suspend</span>
</code></pre></div></div>
<h2 id="37-使系统进入休眠状态">3.7 使系统进入休眠状态：</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl hibernate
</code></pre></div></div>
<h1 id="4-管理服务依赖关系">4. 管理服务依赖关系</h1>
<h2 id="41-查看服务依赖关系">4.1 查看服务依赖关系：</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl list - dependencies <span class="o">[</span>服务名称]
</code></pre></div></div>
<p>例如，查看httpd服务的依赖关系，会显示该服务所依赖的其他服务以及依赖它的服务：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl list - dependencies httpd
</code></pre></div></div>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="笔记" /></entry><entry><title type="html">使用vsftpd在阿里云ecs上建立一个ftp服务器</title><link href="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8vsftpd%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E4%B8%8A%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="alternate" type="text/html" title="使用vsftpd在阿里云ecs上建立一个ftp服务器" /><published>2025-01-16T00:00:00+00:00</published><updated>2025-01-16T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8vsftpd%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E4%B8%8A%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8</id><content type="html" xml:base="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8vsftpd%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E4%B8%8A%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8/"><![CDATA[<p>首先要做的就是在服务器上运行一个FTP server。现在已经十分的成熟了，可以直接使用apt工具下载一些常用的ftp工具软件包，例如<code class="language-plaintext highlighter-rouge">vsftpd</code>和<code class="language-plaintext highlighter-rouge">ProFTPD</code>等。这里我使用的是<code class="language-plaintext highlighter-rouge">vsftpd</code>。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt update
apt <span class="nb">install </span>vsftpd
systemctl start vsftpd
</code></pre></div></div>
<blockquote>
  <p>“vsftpd” 中，最后的 “d” 代表 “daemon”，即守护进程。守护进程是一种在后台持续运行的进程，它独立于控制终端，通常在系统启动时自动启动，并一直运行直至系统关闭，用于执行特定的系统任务或提供某种服务。
systemctl是一个在基于 systemd 的 Linux 系统中用于控制 systemd 系统和服务管理器的命令行工具。systemd 是一个系统和服务管理器，它提供了系统启动、服务管理、日志记录等一系列功能。systemctl命令是与systemd 进行交互的主要方式，具体参见<a href="/%E7%AC%94%E8%AE%B0/systemd%E5%92%8Csystemctl/">systemctl</a>。</p>
</blockquote>

<p>接下来要做的是对vsftpd的一些配置，最主要的是添加用户和用户组，设置用户的权限和工作目录。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adduser honest
</code></pre></div></div>

<p>完成了配置以后，还需要再阿里云的控制台里配置服务器的安全组，让ftp的端口开放出来。</p>

<p>登录阿里云控制台，找到对应的 ECS 实例，进入安全组设置页面。添加安全组规则，允许 FTP 服务相关端口的访问。如果是主动模式，需开放 21 端口（控制连接）；如果使用被动模式，除了 21 端口，还需开放配置的被动模式端口范围（例如 40000 - 40100）。方便起见，这里我把入方向和出方向都配置成了所有端口。</p>

<blockquote>
  <p>很有可能不安全，小孩子不要学</p>
</blockquote>

<p><img src="/assets/images/blog/2025-01-16%20103849.png" alt="" /></p>

<p>在想要连接FTP server的设备上运行FileZilla client这样的软件。建立连接时有如下提示，也就是没有做加密。</p>

<p><img src="/assets/images/blog/2025-01-16%20105225.png" alt="" /></p>

<p><strong>FTPS</strong>
一种方法是使用FTPS（FTP over SSL/TLS）的协议，使用SSl/tsl来实现安全传输。这需要依赖<code class="language-plaintext highlighter-rouge">openssl</code>这个软件包，一般的Linux发行版都会下载这个包，所以仅需要我们配置ssl的公钥然后让Vsftpd 支持 FTPS。
打开vsftpd.conf文件</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi /etc/vsftpd.conf
</code></pre></div></div>
<p>添加或修改以下配置参数：</p>
<pre><code class="language-plain">ssl_enable=YES
write_enable=YES
</code></pre>
<p>重启vsftpd服务</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart vsftpd
</code></pre></div></div>
<p><strong>SFTP</strong>
另一种方法是使用SFTP（SSH FTP），SFTP 是基于 SSH 协议的文件传输协议，使用 SSH 的安全通道来传输文件。SFTP将文件传输作为 SSH 协议的子系统，所以只需要支持ssh的设备就可以使用这种方式传输文件。因为使用 SSH 协议，所以继承了 SSH 的安全性，包括加密和用户认证。</p>
<blockquote>
  <p>更简单的情况下，我们可以直接使用SCP来复制文件。</p>
</blockquote>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="笔记" /><category term="ECS" /><category term="FTP" /><category term="vsftpd" /></entry><entry><title type="html">Git使用</title><link href="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/git%E4%BD%BF%E7%94%A8/" rel="alternate" type="text/html" title="Git使用" /><published>2025-01-15T00:00:00+00:00</published><updated>2025-01-15T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/git%E4%BD%BF%E7%94%A8</id><content type="html" xml:base="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/git%E4%BD%BF%E7%94%A8/"><![CDATA[<h1 id="github-公钥设置">github 公钥设置</h1>
<p>```bash
ssh-keygen -t rsa -b 4096 -C “your_email@example.com”
cat ~/.ssh/id_rsa.pub</p>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="笔记" /><category term="Github" /><category term="Git" /></entry><entry><title type="html">Bash脚本win Linux之间的换行符问题</title><link href="https://honest-zh.github.io/%E9%97%AE%E9%A2%98/bash%E8%84%9A%E6%9C%ACwin-linux%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98/" rel="alternate" type="text/html" title="Bash脚本win Linux之间的换行符问题" /><published>2025-01-03T00:00:00+00:00</published><updated>2025-01-03T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E9%97%AE%E9%A2%98/bash%E8%84%9A%E6%9C%ACwin-linux%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98</id><content type="html" xml:base="https://honest-zh.github.io/%E9%97%AE%E9%A2%98/bash%E8%84%9A%E6%9C%ACwin-linux%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98/"><![CDATA[<h1 id="问题描述">问题描述</h1>

<p>在嵌入式开发的过程当中，经常需要使用bash脚本进行批量的操作。编写bash脚本时，有时会出现报错，未找到xxx。使用Vi打开bash脚本以后发现在每行命令的行尾出现了<code class="language-plaintext highlighter-rouge">^M</code>这样的符号，导致指令未能被正确的识别和执行。</p>

<p>导致这种问题的原因是Windows和Linux系统下的换行符的不同。这种不同来源于传统电控打字机的兼容性带来的历史遗留问题。</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">\r</code>（Carriage Return，ASCII 码值为 13 ）：意思是 “回车”，起源于老式的打字机机械结构。打字机打印头在一行末尾打完字后，需要将整个打印托架移回本行开头的位置，为下一行的打字做准备，这个动作就叫 “回车” 。在电传打字机、早期计算机终端设备等场景下，当接收到\r字符时，设备的光标或者打印头就会回到本行起始坐标处，准备后续输入或者输出。</p>
</blockquote>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">\n</code>（Line Feed，ASCII 码值为 10）：意思是 “换行”，当电传打字机等设备接收到该字符时，会将纸张向上滚动一行，让打印位置垂直下移一行，这样后续内容就会打印到新的一行。Windows使用的换行符是<code class="language-plaintext highlighter-rouge">\r\n</code>,由两部分组成。</p>
</blockquote>

<p>windows为了更好的兼容性同时使用了<code class="language-plaintext highlighter-rouge">\r\n</code>一起作为换行符，称为CRLF换行符。</p>

<p>Linux（等类unix系统）则秉持着最小化的哲学仅使用<code class="language-plaintext highlighter-rouge">\n</code>，称为LF换行符。</p>

<p>Windows 风格换行符（CRLF，\r\n ）中的 “回车符（Carriage Return，ASCII 码值 13，对应 Ctrl + M，在文本显示中就呈现为^M ）” 。</p>

<h1 id="解决方法">解决方法</h1>
<ol>
  <li>
    <p>最简单直接的做法就是在IDE中直接设置好文件的换行符格式。例如，在vscode的右下角蓝色底部边框中可以修改文件的编码格式、换行符和缩进方式。</p>
  </li>
  <li>
    <p>在linux系统下,一种方法是使用对应的工具包<code class="language-plaintext highlighter-rouge">unix2dos</code>或<code class="language-plaintext highlighter-rouge">dos2unix</code>,但是需要下载。</p>
  </li>
  <li>另一种方法是使用tr命令和管道相结合的方式修改文件中的换行符。
 RF –&gt; CRLF
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> cat input.txt | tr '\n' '\t' | tr '\t' '\r\n' &gt; output.txt
</code></pre></div>    </div>
    <p>CRLF –&gt; LF</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> cat input.txt | tr '\r\n' '\t' | tr '\t' '\n' &gt; output.txt
</code></pre></div>    </div>
  </li>
  <li>还有一种方法是使用vim的<code class="language-plaintext highlighter-rouge">set fileformat</code>命令进行设置
 RF –&gt; CRLF
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> :set fileformat=dos
 :wq
</code></pre></div>    </div>
    <p>CRLF –&gt; LF</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> :set fileformat=unix
 :wq
</code></pre></div>    </div>
  </li>
</ol>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="问题" /><category term="shell" /><category term="git" /><category term="vim" /></entry><entry><title type="html">Git自动切换文件的换行符格式</title><link href="https://honest-zh.github.io/%E9%97%AE%E9%A2%98/git%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E6%96%87%E4%BB%B6%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E6%A0%BC%E5%BC%8F/" rel="alternate" type="text/html" title="Git自动切换文件的换行符格式" /><published>2025-01-03T00:00:00+00:00</published><updated>2025-01-03T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E9%97%AE%E9%A2%98/git%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E6%96%87%E4%BB%B6%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E6%A0%BC%E5%BC%8F</id><content type="html" xml:base="https://honest-zh.github.io/%E9%97%AE%E9%A2%98/git%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E6%96%87%E4%BB%B6%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E6%A0%BC%E5%BC%8F/"><![CDATA[<h1 id="问题描述">问题描述</h1>
<p>在进行嵌入式编程的时候，首先在vscode上将已经写好的测试脚本shell提交到gitlab上，然后在测试的电脑上使用git clone获得测试例源码。使用scp/ftp等方式传输文件到运行了linux系统的开发板上，运行shell的测试脚本，依然出现了换行符的报错。第一时间想到的是<a href="/%E9%97%AE%E9%A2%98/bash%E8%84%9A%E6%9C%ACwin-linux%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98/">bash换行符问题</a>。</p>

<p>但是已经明确确认过vscode上向gitlab提交的源码使用的是LF的换行方式的情况下，依然有这个问题那么问题仅能出在git上。</p>

<p>答案是git上存在一个默认的设置选项<code class="language-plaintext highlighter-rouge">autocrlf</code>，pull拉取文件的时候会将文件的换行符自动切换为当前设备的换行符。这种方法一般而言是十分方便的，但是对于嵌入式开发来说带来了额外的问题。</p>

<blockquote>
  <p>本质上问题还是偷懒了，开发板一定会接win的电脑，需要xterm之类的串口，还需要通过网口和电脑测试。所以就没有连开发板和gitlab的服务器，结果出现了这种和平台相关的问题。</p>
</blockquote>

<h1 id="解决方法">解决方法</h1>
<ol>
  <li>嵌入式设备允许的情况下，在设备的linux CLI使用git clone获得测试源码</li>
  <li>设置仓库中的autocrlf变量
 设置全局（在本地创建和克隆的都受到影响）
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> git config --global core.autocrlf true
</code></pre></div>    </div>
    <p>设置当前仓库</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> git config core.autocrlf false
</code></pre></div>    </div>
  </li>
</ol>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="问题" /><category term="git" /><category term="shell" /></entry><entry><title type="html">Cmake出来的可执行文件找不到库文件</title><link href="https://honest-zh.github.io/%E9%97%AE%E9%A2%98/Cmake%E5%87%BA%E6%9D%A5%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%BA%93%E6%96%87%E4%BB%B6/" rel="alternate" type="text/html" title="Cmake出来的可执行文件找不到库文件" /><published>2024-12-31T00:00:00+00:00</published><updated>2024-12-31T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E9%97%AE%E9%A2%98/Cmake%E5%87%BA%E6%9D%A5%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%BA%93%E6%96%87%E4%BB%B6</id><content type="html" xml:base="https://honest-zh.github.io/%E9%97%AE%E9%A2%98/Cmake%E5%87%BA%E6%9D%A5%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%BA%93%E6%96%87%E4%BB%B6/"><![CDATA[<h1 id="问题描述">问题描述</h1>

<p>项目中使用Cmake自动化构建，首先将源码生成动态库，然后编译测试用例，最后把编译好的动态库和测试例都转移到输出目录中方便部署。
出现的问题是输出目录中的测试用例可执行文件在运行时提示找不到对应的动态库，需要手动设置LD_LIBRARY_PATH</p>

<h1 id="解决方法">解决方法</h1>
<p><strong>使用 rpath 选项和make install</strong></p>

<p>在 CMakeLists.txt 中添加链接选项：在生成可执行文件（测试用例）的 add_executable 和 target_link_libraries 部分，通过 SET_TARGET_PROPERTIES 来设置 rpath。</p>

<p>示例如下：</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 生成动态库</span>
<span class="nb">add_library</span><span class="p">(</span>mylib SHARED mylib.cpp<span class="p">)</span>

<span class="c1"># 生成测试用例可执行文件</span>
<span class="nb">add_executable</span><span class="p">(</span>test_mylib test_mylib.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>test_mylib mylib<span class="p">)</span>

<span class="c1"># 设置 RPATH，假设动态库和可执行文件最终在同一输出目录下</span>
<span class="nf">SET_TARGET_PROPERTIES</span><span class="p">(</span>test_mylib PROPERTIES
    INSTALL_RPATH <span class="s2">"Path/of/mylib"</span>
<span class="p">)</span>

<span class="c1"># 安装动态库</span>
<span class="nb">install</span><span class="p">(</span>TARGETS mylib
    LIBRARY DESTINATION lib
<span class="p">)</span>

<span class="c1"># 安装可执行文件</span>
<span class="nb">install</span><span class="p">(</span>TARGETS test_mylib
    RUNTIME DESTINATION bin
<span class="p">)</span>

<span class="c1"># 安装头文件</span>
<span class="nb">install</span><span class="p">(</span>FILES myheader.h
    DESTINATION include
<span class="p">)</span>
</code></pre></div></div>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="问题" /><category term="Cmake" /></entry><entry><title type="html">白色相簿2</title><link href="https://honest-zh.github.io/%E9%9A%8F%E7%AC%94/%E7%99%BD%E8%89%B2%E7%9B%B8%E7%B0%BF2/" rel="alternate" type="text/html" title="白色相簿2" /><published>2024-12-19T00:00:00+00:00</published><updated>2024-12-24T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E9%9A%8F%E7%AC%94/%E7%99%BD%E8%89%B2%E7%9B%B8%E7%B0%BF2</id><content type="html" xml:base="https://honest-zh.github.io/%E9%9A%8F%E7%AC%94/%E7%99%BD%E8%89%B2%E7%9B%B8%E7%B0%BF2/"><![CDATA[<hr />

<center>白色相簿什么的已经无所谓了，</center>
<center>因为已经不再有歌，值得去唱了。</center>
<center>传达不了的恋情已经不需要了，</center>
<center>因为已经不再有人，值得去爱了。</center>

<hr />
<h1 id="前言">前言</h1>
<audio controls="" autoplay="">
    <source src="/assets/music/%E5%B0%8F%E6%9C%A8%E6%9B%BD%E9%9B%AA%E8%8F%9C%20-%20WHITE%20ALBUM%20Live%20at%20Campus%20Fes.mp3" type="audio/mpeg" />
    Your browser does not support the audio element.
</audio>

<p>不知不觉间，又到了白色相簿的季节。在第一次看动画，因为冬马雪菜春希三人的纠结关系胃疼时，我就早已有所耳闻了——游戏的CC和Coda部分才是白色相簿2的精华。但是直到多年后的今天，在通关了这款被称为“脱宅神作”的Galgame以后的此时此刻，我才明白我曾经错过了怎样优秀的作品，我才后悔为何没能更早的玩到他。</p>

<p>白色相簿整个故事的悲剧性就来源于IC时三人在青春期犯下的错误。相对的，CC讲述了春雪两人挣扎而痛苦的成长，到了Coda则是两种不同恋爱观念的选择。</p>

<h1 id="-introductory-chapter-">-Introductory Chapter-</h1>

<hr />

<center>命运的开始,无法挽回的青春</center>

<hr />
<p>为自己循规蹈矩的人生而不甘的，如同教科书一般的努力、负责、热心肠的模范三好学生<strong>北原春希</strong>，想为自己的青春留下最后的回忆。至少要任性一次、至少要装帅一次，这样想着的春希加入了好兄弟<strong>饭冢武也</strong>的轻音乐部，期望着能在学院祭的舞台上大展手脚。尽管只是一个作为吉他候补的拙劣新手，春希也对能够真正参与到“青春”之中而满足。然而，轻音乐部因为坏女人主唱柳原朋而人际关系破裂，整个社团分崩离析，只剩下了武也和春希。仅有两个吉他手无疑是无法构成乐队的，武也自然的放弃了在学院祭上演出的计划。只剩下不甘心的北原春希在第三音乐室里独自弹着吉他，为了无谓的目标而努力。</p>

<p>非要压抑的度过这一段人生了吗？只能把压抑了17年的情感继续压抑下去了吗？只能继续做一个古板、婆婆妈妈的前班长和兢兢业业的做题家了吗？在人生中本该最绚丽的、最青春的时间段…</p>

<p>伴着隔壁第二音乐室里与他共奏的钢琴，春希这样想着，依然盲目而执拗的练习。命运本该就这样结束——他将不得不放弃让自己最后闪耀的机会，徒劳的看着青春从琴头的指尖逝去。直到那一天到来、直到改变了一切的合奏开始、直到《White Album》命运的歌声响起，实现他愿望的天使降临了——<strong>小木曾雪菜</strong>。</p>

<p><img src="/assets/images/blog/white_album1.png" alt="" /></p>

<p>春希听到了天籁，更看到了天使——啊，我的青春就该是这样的！让她加入轻音乐部吧！为了我贫瘠了17年的青春，为了我压抑了17年的心，为了学院祭最后的绽放，稍微任性一些也无妨吧！</p>

<p>此时的春希不知道的是，在隔壁的音乐教室与他合奏钢琴的正是他早已暗生情愫的同桌——<strong>冬马和纱</strong>。<del>他更不会知道的是，和纱也早就喜欢上了他</del></p>
<blockquote>
  <p>梦里不觉秋意深，余情岂是为他人</p>
</blockquote>

<p><img src="/assets/images/blog/white_album3.png" alt="" /></p>

<p>从这一首共演的《White Album》开始，三人命定一般的故事开始了。</p>

<hr />

<p>白色相簿2的IC章节是没有选项的，在我的理解里这是丸户刻意制造的局面。在故事的早期，只要做出一点很小的选择就足以改变春冬雪三人这种复杂的感情局面。但是从故事的角度来说，这样子无疑会让整个故事变得乏善可陈，落入寻常的Galgame的窠臼。丸户在IC想要体现的其实是无法挽回的、伤害和被伤害已经成为既定事实的青春。</p>

<p>在青春里，你因为不懂女人心而错过了你最喜欢也最喜欢你的人；在青春里，你因为自卑和傲娇永远无法把心中的话说给最希望听的人；在青春里，你因为慌乱和懵懂的喜欢而抢先出手拿下了挚友也喜欢的男孩；在青春里，并不成熟三人笨拙的相处、青涩的相恋，然后又因为这份笨拙和青涩相互伤害——直到一人逃避远走，三人的故事变为两人与一人。</p>

<h2 id="北原春希">北原春希</h2>

<p>春希的本质实际上是一个善良的努力者，通俗一点的说是好心的做题家。他对于条条框框的规矩格外遵守，坚信努力就有回报，在过去的人生里一直压抑自己的青春换来秀才的名声，近乎偏执的执着于帮助他人，让人怀疑是否是具有白骑士情节。但是在另一面被这些形象所隐藏的，春希是一个无比渴望精彩热烈的校园生活，也无比渴望爱情的人。他是古板的班长，是兢兢业业努力的好学生，是乐于助人的里之委员长；他更是普通的高中生，是血气方刚的男孩，是懵懂的青春期少年。这种想法春希其实并不是到了临近毕业的高三才突然出现的，而是一直伴随在他尽力压抑的校园生活中的（实际上春希的欲望十分强烈，此事在雪菜TE亦有记载）。</p>

<p>加入轻音乐部、练习吉他、想要参加校园祭留下完美的青春回忆，这是春希最开始也最强烈的心愿。最开始他不曾幻想也不敢幻想自己竟然能拥有这样热烈而跌宕的青春。他只是执拗的坚持自己的梦想，不断地向前努力，命运的巧合和作弄就将春冬雪三人的线团紧紧的纠缠在一起。</p>

<p>他喜欢冬马，也喜欢雪菜（应该没有人能够不喜欢）。如果非要权衡，因为喜欢冬马的时间更长一些、所以更喜欢冬马一些。但是他不知道冬马也喜欢着自己，而且时哪样的喜欢自己，更觉得自己不配冬马喜欢<del>但是冬马也是这么想的</del>。所以在心满意足的学院祭后，面对雪菜的热情表白，他毫无抵抗能力的接受了。</p>

<p>在表白后的第一时间里，春希就找到了冬马和她说明了情况——自己和雪菜交往了，是我告白的。我曾经喜欢你，但是我选择了雪菜，抱歉——春希心中一定是这么想的吧。在之后的故事里，三人一起日常相处，和谐的背后隐藏着酝酿的爆发。冬马努力扮演夹在中间的好友身份却又痛苦不已。春希逐渐知道自己心中还喜欢着冬马，并努力地想要忘却她。他尽力地想扮演好雪菜地男友的角色，想要在雪菜的生日用带有雪菜名字的戒指推进关系，将两人紧紧绑在一起。雪菜尽力克制自己和春希在冬马面前的互动，想要维护三人共同好友的情景一直持续下去。</p>

<p>然而这种做法本身就是不对的，三人之间的话依然和最开始一样没有说开；春冬二人的心意没能相通；雪菜也因为自己的所作所为而陷入了深深的自责。如果春希在找冬马的时候就能大方的好好告诉她自己喜欢她，如果在三人相处逐渐意识到自己仍有对冬马的喜欢之后春希就和雪菜坦白一切，或许三人都会更幸福吧。</p>

<p>当春希知道冬马刚刚通过考验回国，即将远走欧洲留学时，努力压抑的感情爆发了。他爽约了雪菜的生日派对，跑到了机场迎接冬马。这是最重要的，最大的背叛，代表着春希的心向着与雪菜相反的方向前进。雪菜其实也和春希一样，为了推进二人的关系早已做好了准备，在圣诞夜这天支开了家人。此时如果两人能够心意相通知道对方想法的话，结果或许会不一样吧。只要春希叫上雪菜一起寻找冬马，见面的两人一定会互相吐露内心吧。但是春希鸽掉生日的原因其实是两部分组成的，一部分是对于自己和雪菜关系推进太快的惶恐，对关系进一步发展的巨大责任的逃避，另一部分是竭力让自己忘记冬马然后突然得知以后无法相见的痛苦和这么重要的事情冬马却一直不告诉自己的不甘。</p>

<p>落雪纷纷而下，冻结的心相互碰撞，在熟练街上，春希和冬马互相吐露了心声。春希终于意识到了自己是多么不懂女人心的愚钝的男人、冬马也终于意识到春希也喜欢着自己只是因为自卑而退缩了。如火山爆发般压抑不住的情绪让春希强吻了冬马，但是就连熟练的亲吻本身都是春雪二人关系的铁证——冬马再次崩溃选择了逃离。</p>

<p>无助的春希想雪菜求助，却又没有勇气说出实话，只能对雪菜撒谎。</p>

<h2 id="小木曾雪菜">小木曾雪菜</h2>

<p>在IC的故事中，小木曾雪菜从未掩饰自己对春希的喜欢。最开始总是拒绝，然后总是被春希打动改变主意。春希为在天台上高歌的小木曾雪菜而倾倒，按捺不住心中的躁动，主动邀请了雪菜参加学院祭的演出。然而早就因为自己超群的名声而深深苦恼的雪菜，并不想在大众面前抛头颅面，拒绝了春希的请求——一如之前一开始拒绝参与峰城大附属小姐一样。为了让雪菜加入，春希直接找到了雪菜打工的地方，见识到了雪菜高岭之花外表下亲切、平易近人、有些虚荣又逞强的一面。</p>

<blockquote>
  <p>这样一来，小木曾雪菜的秘密，就一个不剩了呢。因为，全部都被你知道了呢。</p>
</blockquote>

<p><img src="/assets/images/blog/white_album4.png" alt="" /></p>

<p>在春希的努力之下，雪菜改变了之前的想法——一如之前后来又改变主意决定参与峰城大附属小姐一样。而这两次转变的原因毫无疑问就是雪菜对春希的好感和喜欢。</p>

<h2 id="冬马和纱">冬马和纱</h2>
<p>冬马一开始很好的扮演了恋人的好友的角色，但是她实在是按捺不住对春希的喜欢，在这样的三人行游戏里倍感痛苦。</p>
<h1 id="-closing-chapter-">-Closing Chapter-</h1>
<hr />

<center>背叛的刺深植，无法前进更无法后退的二人</center>

<hr />

<p>为什么，为什么会变成现在这样子呢？你无数次的想，但是伤害已经造成，青春已经过去。或许比起那时现在的你有了更多成长，再来一次或许会有不同的选择，但事实的伤口早已横亘在心间，时针永不回转。现在能做的事情只有拼命的补救，纵然身心俱疲、纵然遍体鳞伤，这也是弥补过去的错误的唯一的方法。逃避或者心照不宣的隐瞒或许能得到一时的轻松，但是背叛的利刺将一直插在二人的心间——无论进退都只会带来更大的痛苦。唯一的方法是咬着牙坚强的面对它，无论多么痛苦也要携手将其拔除。当二人痛苦而幸福的紧紧相拥时，结痂的血液才会将二人相连，彼此的血才能愈合对方的伤口。</p>

<h1 id="-coda-">-Coda-</h1>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="随笔" /><category term="白色相簿" /><category term="Galgame" /></entry><entry><title type="html">基于jekyll和github page的个人主页搭建经验</title><link href="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EJekyll%E5%92%8CGithub-Page%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E6%90%AD%E5%BB%BA%E7%BB%8F%E9%AA%8C/" rel="alternate" type="text/html" title="基于jekyll和github page的个人主页搭建经验" /><published>2024-12-12T00:00:00+00:00</published><updated>2024-12-19T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EJekyll%E5%92%8CGithub%20Page%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E6%90%AD%E5%BB%BA%E7%BB%8F%E9%AA%8C</id><content type="html" xml:base="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EJekyll%E5%92%8CGithub-Page%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E6%90%AD%E5%BB%BA%E7%BB%8F%E9%AA%8C/"><![CDATA[<h1 id="基于jekyll和github-page的个人主页搭建经验">基于Jekyll和Github Page的个人主页搭建经验</h1>

<h2 id="一方案选择">一、方案选择</h2>

<p>大体上讲，搭建个人网站有几种常见的方案技术路线。一种是分为前端和后端，使用web服务器处理web请求的<strong>通用网页方案</strong>；另一种是使用<strong>静态网页生成器</strong>将所有网页内容预先生成为静态文件（如 HTML、CSS、JavaScript），然后部署到<strong>静态网页托管平台</strong>上。</p>

<p>前者是web网页的一般方法，由前端和后端两部分组成。前端负责提供网页的结构、布局和交互等可视化的直接和用户接触的部分，后端负责处理请求的业务逻辑、数据存储和安全性等涉及服务器端的部分。</p>

<ul>
  <li>
    <p>前端的核心是HTML、CSS、JavaScript三个部分，分别对应了网页的结构、布局和交互处理。除此以外，还有其他基于JavaScript的前端的框架（如 <code class="language-plaintext highlighter-rouge">React</code>、<code class="language-plaintext highlighter-rouge">Vue.js</code>、<code class="language-plaintext highlighter-rouge">Angular</code>）用来简化网页交互的编写。</p>
  </li>
  <li>
    <p>后端的核心是Web服务器、后端框架和数据库。</p>

    <ul>
      <li>Web服务器主要用于连接用户的网页请求和用于处理请求的服务器。具体来说：主要负责处理用户HTTP/HTTPS请求、对后端的服务器进行反向代理和负载均衡。</li>
      <li>后端框架则主要用于处理业务逻辑，负责对web服务器代理后的请求进行处理。常见的后端框架有：Python的<code class="language-plaintext highlighter-rouge">Django</code>,和<code class="language-plaintext highlighter-rouge">Flask</code>、JavaScript的<code class="language-plaintext highlighter-rouge">Node.js</code>、Java的<code class="language-plaintext highlighter-rouge">Spring</code>等。</li>
      <li>数据库则是十分明了的用于存储和管理数据。常见的数据库包括：<code class="language-plaintext highlighter-rouge">MySQL</code>、<code class="language-plaintext highlighter-rouge">Oracle</code>（关系型数据库）、<code class="language-plaintext highlighter-rouge">MongoDB</code>、<code class="language-plaintext highlighter-rouge">Redis</code>（非关系型数据库）。</li>
    </ul>
  </li>
</ul>

<p>后者是用于生成静态网页的方法，即使用静态网页生成器（如<code class="language-plaintext highlighter-rouge">Jekyll</code>、<code class="language-plaintext highlighter-rouge">Hugo</code>、<code class="language-plaintext highlighter-rouge">Hexo</code>等）预先生成好网页，将之存为不需要服务器端处理的文件（如<code class="language-plaintext highlighter-rouge">HTML</code>、<code class="language-plaintext highlighter-rouge">CSS</code>、<code class="language-plaintext highlighter-rouge">JavaScript</code>）。静态网页可以直接使用静态网页托管平台直接进行部署，如<code class="language-plaintext highlighter-rouge">Github Pages</code>、<code class="language-plaintext highlighter-rouge">Vercel</code>、<code class="language-plaintext highlighter-rouge">Netlify</code>等。</p>

<p>动态网页的灵活性更高，可以处理更多的交互需求，但是需要服务器端的支持，部署较为复杂，需要额外的服务器;静态网页的灵活性较差，但是部署简单，可以直接使用Github Page进行部署（还省去了配置公网IP和网页备案的麻烦）。对比两种方案，静态网页的方案适合个人主页低更新频率，交互性较弱的应用需求。</p>

<p>因此，我最后选择了静态网页的方案，使用<strong>Jekyll的Minimal Mistakes主题</strong>和<strong>Github Pages静态网页托管平台</strong>组合的方案搭建了自己的个人主页。</p>

<p>首先，我在运行了ubuntu的虚拟机上下载Jekyll和其所需要的环境。然后，根据自己的使用需要，按照MInimal Mistakes的文档说明修改了<code class="language-plaintext highlighter-rouge">_config.yml</code>配置文件，调整了个人主页的一些常用设置。最后使用Github Page的部署功能来部署整个网页。</p>

<blockquote>
  <p>PS.除了使用模板以外，也可以根据自己需要的格式修改<code class="language-plaintext highlighter-rouge">_layout</code>文件夹中的模板。添加自己想要的内容。</p>
</blockquote>

<h2 id="二jekyll和minimal-mistakes主题">二、Jekyll和Minimal Mistakes主题</h2>

<p><a href="https://jekyllrb.com/docs">Jekyll</a>是一个基于 Ruby 语言开发的开源静态网页生成器。其核心原理是将包含文本内容（如 Markdown 文件）、布局模板（如 HTML 模板）和配置文件（如<code class="language-plaintext highlighter-rouge">_config.yml</code>）的源文件目录，通过一系列的转换和处理，生成最终的静态网站（HTML、CSS、JavaScript 等文件的集合）。<a href="https://mmistakes.github.io/minimal-mistakes/docs">Minimal Mistakes</a>是一个Jekyll的主题，提供了丰富的功能和灵活的配置选项，可以方便地设置美观的网页的布局和样式。</p>

<h3 id="1部署jekyll环境">1.部署Jekyll环境</h3>

<p>这一步其实来说并不是必要的，只是在本地拥有可以使用Jekyll构建网页的环境对于修改个人主页的一些功能来说会更加的方便。<del>你也不想每次对网页布局之类的细微修改的尝试都要push到github上然后重新等待他慢慢的生成网页吧，这实在是太麻烦了</del>。</p>

<p>首先你需要确保的是你拥有一个Linux的虚拟机环境，不管是VMware或者WSL都可以。我使用的是WSL，可以直接在VScode中使用。<del>非常的方便，用过都说豪用</del>。具体怎么弄我这里就不赘述了，网上有很多教程。</p>

<ol>
  <li>
    <p>安装 Ruby：</p>

    <p>Jekyll 是基于 Ruby 构建的，所以首先需要安装 Ruby。通过以下命令安装 Ruby：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt - get update
   
<span class="nb">sudo </span>apt - get <span class="nb">install </span>ruby - full
</code></pre></div>    </div>
  </li>
  <li>
    <p>安装 Jekyll 和 Bundler（RubyGems 包管理器）：</p>

    <p>在安装好 Ruby 后，可以使用 RubyGems 来安装 Jekyll 和 Bundler。在终端（命令提示符或 PowerShell）中输入以下命令：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem <span class="nb">install </span>jekyll bundler
</code></pre></div>    </div>
  </li>
  <li>
    <p>创建项目</p>

    <p>a. 新创建项目</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jekyll new <span class="nb">.</span>
</code></pre></div>    </div>

    <p>b. 从原有的模板复制一个项目</p>

    <p>最简单的方法就是直接使用git clone直接复制这个项目的文件下来。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> git clone https://github.com/HONEST-ZH/HONEST-ZH.github.io.git
</code></pre></div>    </div>
  </li>
  <li>
    <p>修改网页</p>

    <p>修改<code class="language-plaintext highlighter-rouge">_config.yml</code>或者<code class="language-plaintext highlighter-rouge">_layout</code>里的布局文件来达到你满意的网页效果。</p>
  </li>
  <li>
    <p>本地运行尝试</p>

    <p>执行以下命令来运行本地运行jekyll网页的服务器，工作的ip地址是<code class="language-plaintext highlighter-rouge">127.0.0.1:4000</code></p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bundle <span class="nb">install
</span>bundle <span class="nb">exec </span>jekyll serve
</code></pre></div>    </div>
  </li>
  <li>
    <p>重复4-5直到网页满足你的需求。</p>
  </li>
</ol>

<h2 id="三设置github-page">三、设置Github Page</h2>

<p>对于一般的静态网页而言，我们只需要将jekyll项目提交到名为<code class="language-plaintext highlighter-rouge">username.github.io</code>的仓库中（名字需要和github的账户名字一致，否则会无效），然后再选择<code class="language-plaintext highlighter-rouge">Settings-Pages-Deploy From a Branch</code>，<code class="language-plaintext highlighter-rouge">branch-main</code>。完成设置以后，就可以实现静态网页的部署了，Github会在Action中自动新建一个名为<code class="language-plaintext highlighter-rouge">pages-build-deployment</code>的工作流，每次选定的分支（main）上发生推送时会自动地构建和部署网页。</p>

<p><img src="/assets/images/blog/2024-12-18-16-33-44-image.png" alt="" /></p>

<p>但是这里因为我使用了Minimal Mistakes模板的原因，网页是没有办法使用这种方法的直接生成的。网页在编译时会报错，找不到模板的Gem包。</p>

<p><img src="/assets/images/blog/2024-12-18-16-44-39-image.png" alt="" /></p>

<p><img src="/assets/images/blog/2024-12-18-16-44-56-image.png" alt="" /></p>

<p>这是因为默认的<code class="language-plaintext highlighter-rouge">pages-build-deployment</code>工作流没有去下载所需要的依赖，而缺少了Jekyll模板。解决这个问题的方法也很简单，就是自己创建一个工作流保证每一次都能把所需要的依赖装好。</p>

<h3 id="1-创建gh-pagesyml工作流文件">1. 创建gh-pages.yml工作流文件</h3>

<p>在项目的根目录下创建.github/workflows文件夹然后添加gh-pages.yml文件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> .github/workflows
<span class="nb">touch</span> .github/workflows/gh-pages.yml
</code></pre></div></div>

<h3 id="2-编写gh-pagesyml">2. 编写gh-pages.yml</h3>

<p>在gh-pages.yml文件中写入：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GitHub Pages</span>
<span class="na">on</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">main</span>  <span class="c1"># 监听的分支</span>
<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v2</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set up Ruby</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/setup-ruby@v1</span>
      <span class="na">with</span><span class="pi">:</span>
        <span class="na">ruby-version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.2'</span>  <span class="c1"># 确保使用正确的 Ruby 版本</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install dependencies</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">bundle install</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build the site</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">bundle exec jekyll build</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Deploy to GitHub Pages</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">peaceiris/actions-gh-pages@v3</span>
      <span class="na">with</span><span class="pi">:</span>
        <span class="na">github_token</span><span class="pi">:</span> <span class="s">$</span>
        <span class="na">publish_dir</span><span class="pi">:</span> <span class="s">./_site</span>
</code></pre></div></div>

<p>这个工作流在每次检测到<code class="language-plaintext highlighter-rouge">main</code>分支上有推送时：下载所需要的Gem包依赖，构建静态网页，将静态网页的文件推送到一个专门用于存储静态网页的分支<code class="language-plaintext highlighter-rouge">gh-pages</code>。</p>

<h3 id="3-github-pages从gh-pages分支部署">3. Github pages从gh-pages分支部署</h3>

<p><code class="language-plaintext highlighter-rouge">gh-pages</code>分支被更新后，还没有完成网页的部署。此时需要把github page关注的分支换为<code class="language-plaintext highlighter-rouge">gh-pages</code>，根据每次推送到<code class="language-plaintext highlighter-rouge">gh-pages</code>上的文件部署静态网页。工作流的结果显示如下图所示，此时就可以在<code class="language-plaintext highlighter-rouge">username.github.io</code>中访问个人主页的页面了。</p>

<p><img src="/assets/images/blog/2024-12-18-17-01-56-image.png" alt="" /></p>

<h2 id="四网页的使用">四、网页的使用</h2>

<h3 id="1基本frontmatter">1.基本FrontMatter</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>

<span class="na">title</span><span class="pi">:</span> <span class="s2">"</span><span class="s">文章标题"</span>

<span class="na">date</span><span class="pi">:</span> <span class="s">2023-10-20</span>

<span class="na">last_modified_at</span><span class="pi">:</span> <span class="s">2023-10-21    # 最后修改时间</span>

<span class="na">categories</span><span class="pi">:</span>

<span class="s">  - 技术</span>

<span class="s">  - ZMQ</span>

<span class="na">tags</span><span class="pi">:</span>

<span class="s">  - 消息队列</span>

<span class="s">  - 网络编程</span>

<span class="na">toc</span><span class="pi">:</span> <span class="no">true</span><span class="s">                      </span> <span class="c1"># 显示目录</span>

<span class="na">toc_sticky</span><span class="pi">:</span> <span class="no">true</span><span class="s">              </span> <span class="c1"># 固定目录</span>

<span class="na">toc_label</span><span class="pi">:</span> <span class="s2">"</span><span class="s">目录"</span> <span class="s">             # 目录标题</span>

<span class="na">toc_icon</span><span class="pi">:</span> <span class="s2">"</span><span class="s">cog"</span> <span class="s">             </span> <span class="c1"># 目录图标</span>

<span class="c1">#图片</span>

<span class="na">header</span><span class="pi">:</span>

<span class="na">  image</span><span class="pi">:</span> <span class="s">/assets/images/header.jpg          </span> <span class="c1"># 头部大图</span>

<span class="na">  teaser</span><span class="pi">:</span> <span class="s">/assets/images/teaser-image.jpg    # 预览图</span>

<span class="na">  overlay_image</span><span class="pi">:</span> <span class="s">/assets/images/banner.jpg  </span> <span class="c1"># 覆盖图</span>

<span class="na">  overlay_color</span><span class="pi">:</span> <span class="s2">"</span><span class="s">#333"</span> <span class="s">                     # 覆盖颜色</span>

<span class="na">  caption</span><span class="pi">:</span> <span class="s2">"</span><span class="s">图片来源:</span><span class="nv"> </span><span class="s">[**网站**](链接)"</span> <span class="s">     # 图片说明</span>



<span class="na">excerpt</span><span class="pi">:</span> <span class="s2">"</span><span class="s">这是文章摘要，将显示在文章列表中"</span> <span class="s">   # 文章摘要</span>

<span class="c1"># 作者相关</span>

<span class="na">author</span><span class="pi">:</span> <span class="s">Your Name</span>

<span class="na">author_profile</span><span class="pi">:</span> <span class="no">true</span><span class="s">    # 显示作者信息</span>

<span class="c1"># 布局相关</span>

<span class="na">layout</span><span class="pi">:</span> <span class="s">single</span>

<span class="na">classes</span><span class="pi">:</span> <span class="s">wide          # 宽屏显示</span>

<span class="c1"># 评论相关</span>

<span class="na">comments</span><span class="pi">:</span> <span class="no">true</span><span class="s">        # 启用评论</span>

<span class="na">share</span><span class="pi">:</span> <span class="no">true</span><span class="s">          </span> <span class="c1"># 显示分享按钮</span>

<span class="c1"># 相关文章</span>

<span class="na">related</span><span class="pi">:</span> <span class="no">true</span><span class="s">        </span> <span class="c1"># 显示相关文章</span>

<span class="c1"># 阅读时间</span>

<span class="na">read_time</span><span class="pi">:</span> <span class="no">true</span><span class="s">      </span> <span class="c1"># 显示预计阅读时间</span>

<span class="c1"># 导航</span>

<span class="na">sidebar</span><span class="pi">:</span>

<span class="na">  nav</span><span class="pi">:</span> <span class="s2">"</span><span class="s">main"</span> <span class="s">       # 侧边栏导航</span>

<span class="c1"># SEO相关</span>

<span class="na">description</span><span class="pi">:</span> <span class="s2">"</span><span class="s">这是一段用于SEO的描述"</span>

<span class="na">keywords</span><span class="pi">:</span> <span class="s2">"</span><span class="s">关键词1,</span><span class="nv"> </span><span class="s">关键词2"</span>

<span class="nn">---</span>
</code></pre></div></div>

<h3 id="2ai工具生成顶部配图">2.AI工具生成顶部配图</h3>

<p>使用ChatGPT生成提示词，然后使用DALLE-3生成图片</p>
<blockquote>
  <p>提示词应该具有的结构：</p>
  <ul>
    <li>主题描述
描述主要场景或元素，让 AI 理解你想要生成的内容是什么。</li>
    <li>细节补充
包括场景的颜色、灯光、材质等信息，增加细节丰富度。
*情感与氛围
指定图像的情感和氛围，如“宁静”、“温暖”、“科幻感”等。</li>
    <li>视觉风格
选择一种视觉呈现方式，如“水彩画风格”、“数字艺术”、“摄影级真实感”等。</li>
    <li>构图与比例
提到图像的布局与比例，如“宽屏横向构图”、“16:9比例”。</li>
    <li>特定要求（可选）
如果需要特别的元素，比如“背景模糊”或“有特定的道具”，也可以写明。</li>
  </ul>
</blockquote>

<p>例如：
提示词为</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A breathtaking sunset over a calm ocean, 
with soft waves reflecting the warm orange and pink hues of the sky, a few scattered clouds, and silhouetted palm trees framing the scene.
Cinematic wide-angle composition, 16:9 aspect ratio, high detail, serene and peaceful mood, digital painting style，1200px width
</code></pre></div></div>
<p>生成的图像为
<img src="/assets/images/blog/ai_generate.jpg" alt="" /></p>

<h3 id="3markdown文档编写">3.Markdown文档编写</h3>

<p>使用Marktext以方便的编写MarkDown笔记，可以直接粘贴图片。图片可能被以网络链接的方式引用，也可能保存在本地的<code class="language-plaintext highlighter-rouge">C:\Users\HONEST\AppData\Roaming\marktext\images\</code>路径下，需要把图片的路径改成<code class="language-plaintext highlighter-rouge">/assets/images/blog_header</code>或者<code class="language-plaintext highlighter-rouge">/assets/images/blog</code></p>
<blockquote>
  <p>linux路径使用/，windows路径使用<br />
要在使用jekyll构建好的网页之间进行链接的跳转，需要使用网页的永久链接跳转。手动输入<code class="language-plaintext highlighter-rouge">[](/url)</code>或者使用liquid的link标识获得文件的路径<code class="language-plaintext highlighter-rouge">[](\{\% link path/to/file \%\})</code>
手动输入URL时需要注意：1. 空格使用-代替 2.跳转的博客最后不带文件名,不带开头的日期 最简单的方法，从想要链接到的博客的浏览器抬头处复制URL
使用link标识时需要注意 1.开头的第一个文件没有 <code class="language-plaintext highlighter-rouge">/</code> 2. 使用空格取代%20 最简单的方法，复制想要链接到的博客的文件路径然后修改（大部分博客名称应该没有空格）</p>
</blockquote>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="笔记" /><category term="Github Pages" /><category term="Jekyll" /><category term="个人主页" /></entry><entry><title type="html">Gdb</title><link href="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/GDB/" rel="alternate" type="text/html" title="Gdb" /><published>2024-11-13T00:00:00+00:00</published><updated>2024-11-13T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/GDB</id><content type="html" xml:base="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/GDB/"><![CDATA[<p>GDB（GNU Debugger）是一款强大的调试工具，主要用于调试 C、C++ 和其他编程语言编写的程序。以下是 GDB 的使用方法：</p>

<p><strong>一、启动 GDB</strong></p>

<ol>
  <li>
    <p>编译程序时加上调试信息</p>

    <ul>
      <li>在编译程序时，使用 <code class="language-plaintext highlighter-rouge">-g</code> 选项可以让编译器生成调试信息，以便 GDB 能够更好地进行调试。例如，对于 C 程序，可以使用以下命令进行编译：<code class="language-plaintext highlighter-rouge">gcc -g program.c -o program</code>。对于 C++ 程序，可以使用：<code class="language-plaintext highlighter-rouge">g++ -g program.cpp -o program</code>。</li>
    </ul>
  </li>
  <li>
    <p>启动 GDB</p>

    <ul>
      <li>启动 GDB 并加载要调试的程序。在命令行中输入 <code class="language-plaintext highlighter-rouge">gdb program</code>，其中 <code class="language-plaintext highlighter-rouge">program</code> 是要调试的程序的名称。</li>
    </ul>
  </li>
</ol>

<p><strong>二、基本命令</strong></p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">run</code>（或 <code class="language-plaintext highlighter-rouge">r</code>）</p>

    <ul>
      <li>运行程序。在 GDB 中输入 <code class="language-plaintext highlighter-rouge">run</code> 命令后，程序将开始执行。如果程序需要命令行参数，可以在 <code class="language-plaintext highlighter-rouge">run</code> 命令后面加上参数，例如：<code class="language-plaintext highlighter-rouge">run arg1 arg2</code>。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">break</code>（或 <code class="language-plaintext highlighter-rouge">b</code>）</p>

    <ul>
      <li>设置断点。可以在程序的特定行号、函数名或地址处设置断点。例如，要在第 10 行设置断点，可以输入 <code class="language-plaintext highlighter-rouge">break 10</code>。要在名为 <code class="language-plaintext highlighter-rouge">main</code> 的函数处设置断点，可以输入 <code class="language-plaintext highlighter-rouge">break main</code>。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">next</code>（或 <code class="language-plaintext highlighter-rouge">n</code>）</p>

    <ul>
      <li>执行下一行代码，但不进入函数内部。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">step</code>（或 <code class="language-plaintext highlighter-rouge">s</code>）</p>

    <ul>
      <li>执行下一行代码，如果是函数调用，则进入函数内部。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">continue</code>（或 <code class="language-plaintext highlighter-rouge">c</code>）</p>

    <ul>
      <li>继续执行程序，直到遇到下一个断点或程序结束。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">print</code>（或 <code class="language-plaintext highlighter-rouge">p</code>）</p>

    <ul>
      <li>打印变量的值。例如，要打印变量 <code class="language-plaintext highlighter-rouge">x</code> 的值，可以输入 <code class="language-plaintext highlighter-rouge">print x</code>。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">backtrace</code>（或 <code class="language-plaintext highlighter-rouge">bt</code>）</p>

    <ul>
      <li>打印调用栈信息，显示当前程序的执行路径。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">quit</code>（或 <code class="language-plaintext highlighter-rouge">q</code>）</p>

    <ul>
      <li>退出 GDB。</li>
    </ul>
  </li>
</ol>

<p><strong>三、查看变量和内存</strong></p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">info locals</code></p>

    <ul>
      <li>显示当前函数的局部变量及其值。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">info args</code></p>

    <ul>
      <li>显示当前函数的参数及其值。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">x /&lt;format&gt; &lt;address&gt;</code></p>

    <ul>
      <li>检查内存地址处的值。<code class="language-plaintext highlighter-rouge">&lt;format&gt;</code> 可以是不同的格式说明符，例如 <code class="language-plaintext highlighter-rouge">x/d</code> 表示以十进制格式显示整数，<code class="language-plaintext highlighter-rouge">x/s</code> 表示以字符串格式显示内存内容。</li>
    </ul>
  </li>
</ol>

<p><strong>四、条件断点</strong></p>

<p>可以设置条件断点，只有当满足特定条件时，断点才会生效。例如，要在变量 <code class="language-plaintext highlighter-rouge">x</code> 等于 10 时才中断程序，可以输入 <code class="language-plaintext highlighter-rouge">break 10 if x == 10</code>。</p>

<p><strong>五、多线程调试</strong></p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">info threads</code></p>

    <ul>
      <li>显示当前程序中的所有线程。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">thread &lt;thread-id&gt;</code></p>

    <ul>
      <li>切换到指定的线程进行调试。</li>
    </ul>
  </li>
</ol>

<p><strong>六、远程调试</strong></p>

<p>可以使用 GDB 进行远程调试，例如调试在另一台机器上运行的程序。这通常需要在目标机器上运行一个调试服务器，并在本地使用 GDB 连接到该服务器。</p>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="笔记" /><category term="GDB" /></entry></feed>