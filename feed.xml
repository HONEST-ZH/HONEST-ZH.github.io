<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://honest-zh.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://honest-zh.github.io/" rel="alternate" type="text/html" /><updated>2025-01-15T07:34:36+00:00</updated><id>https://honest-zh.github.io/feed.xml</id><title type="html">HONEST的个人主页</title><subtitle>这里是HONEST的个人主页，存放我的想法和学习的笔记</subtitle><author><name>HONEST</name><email>2260363172qq.com</email></author><entry><title type="html">Bash脚本win Linux之间的换行符问题</title><link href="https://honest-zh.github.io/%E9%97%AE%E9%A2%98/bash%E8%84%9A%E6%9C%ACwin-linux%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98/" rel="alternate" type="text/html" title="Bash脚本win Linux之间的换行符问题" /><published>2025-01-03T00:00:00+00:00</published><updated>2025-01-03T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E9%97%AE%E9%A2%98/bash%E8%84%9A%E6%9C%ACwin-linux%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98</id><content type="html" xml:base="https://honest-zh.github.io/%E9%97%AE%E9%A2%98/bash%E8%84%9A%E6%9C%ACwin-linux%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E9%97%AE%E9%A2%98/"><![CDATA[<h1 id="问题描述">问题描述</h1>

<p>在嵌入式开发的过程当中，经常需要使用bash脚本进行批量的操作。编写bash脚本时，有时会出现报错，未找到xxx。使用Vi打开bash脚本以后发现在每行命令的行尾出现了<code class="language-plaintext highlighter-rouge">^M</code>这样的符号，导致指令未能被正确的识别和执行。</p>

<p>导致这种问题的原因是Windows和Linux系统下的换行符的不同。这种不同来源于传统电控打字机的兼容性带来的历史遗留问题。</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">\r</code>（Carriage Return，ASCII 码值为 13 ）：意思是 “回车”，起源于老式的打字机机械结构。打字机打印头在一行末尾打完字后，需要将整个打印托架移回本行开头的位置，为下一行的打字做准备，这个动作就叫 “回车” 。在电传打字机、早期计算机终端设备等场景下，当接收到\r字符时，设备的光标或者打印头就会回到本行起始坐标处，准备后续输入或者输出。</p>
</blockquote>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">\n</code>（Line Feed，ASCII 码值为 10）：意思是 “换行”，当电传打字机等设备接收到该字符时，会将纸张向上滚动一行，让打印位置垂直下移一行，这样后续内容就会打印到新的一行。Windows使用的换行符是<code class="language-plaintext highlighter-rouge">\r\n</code>,由两部分组成。</p>
</blockquote>

<p>windows为了更好的兼容性同时使用了<code class="language-plaintext highlighter-rouge">\r\n</code>一起作为换行符，称为CRLF换行符。</p>

<p>Linux（等类unix系统）则秉持着最小化的哲学仅使用<code class="language-plaintext highlighter-rouge">\n</code>，称为LF换行符。</p>

<p>Windows 风格换行符（CRLF，\r\n ）中的 “回车符（Carriage Return，ASCII 码值 13，对应 Ctrl + M，在文本显示中就呈现为^M ）” 。</p>

<h1 id="解决方法">解决方法</h1>
<ol>
  <li>
    <p>最简单直接的做法就是在IDE中直接设置好文件的换行符格式。例如，在vscode的右下角蓝色底部边框中可以修改文件的编码格式、换行符和缩进方式。</p>
  </li>
  <li>
    <p>在linux系统下,一种方法是使用对应的工具包<code class="language-plaintext highlighter-rouge">unix2dos</code>或<code class="language-plaintext highlighter-rouge">dos2unix</code>,但是需要下载。</p>
  </li>
  <li>另一种方法是使用tr命令和管道相结合的方式修改文件中的换行符。
 RF –&gt; CRLF
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> cat input.txt | tr '\n' '\t' | tr '\t' '\r\n' &gt; output.txt
</code></pre></div>    </div>
    <p>CRLF –&gt; LF</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> cat input.txt | tr '\r\n' '\t' | tr '\t' '\n' &gt; output.txt
</code></pre></div>    </div>
  </li>
  <li>还有一种方法是使用vim的<code class="language-plaintext highlighter-rouge">set fileformat</code>命令进行设置
 RF –&gt; CRLF
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> :set fileformat=dos
 :wq
</code></pre></div>    </div>
    <p>CRLF –&gt; LF</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> :set fileformat=unix
 :wq
</code></pre></div>    </div>
  </li>
</ol>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="问题" /><category term="shell" /><category term="git" /><category term="vim" /></entry><entry><title type="html">Git自动切换文件的换行符格式</title><link href="https://honest-zh.github.io/%E9%97%AE%E9%A2%98/git%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E6%96%87%E4%BB%B6%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E6%A0%BC%E5%BC%8F/" rel="alternate" type="text/html" title="Git自动切换文件的换行符格式" /><published>2025-01-03T00:00:00+00:00</published><updated>2025-01-03T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E9%97%AE%E9%A2%98/git%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E6%96%87%E4%BB%B6%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E6%A0%BC%E5%BC%8F</id><content type="html" xml:base="https://honest-zh.github.io/%E9%97%AE%E9%A2%98/git%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E6%96%87%E4%BB%B6%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6%E6%A0%BC%E5%BC%8F/"><![CDATA[<h1 id="问题描述">问题描述</h1>
<p>在进行嵌入式编程的时候，首先在vscode上将已经写好的测试脚本shell提交到gitlab上，然后在测试的电脑上使用git clone获得测试例源码。使用scp/ftp等方式传输文件到运行了linux系统的开发板上，运行shell的测试脚本，依然出现了换行符的报错。第一时间想到的是<a href="/_posts/snag/2025-1-3-bash脚本win-linux之间的换行符问题.md">bash换行符问题</a>。</p>

<p>但是已经明确确认过vscode上向gitlab提交的源码使用的是LF的换行方式的情况下，依然有这个问题那么问题仅能出在git上。</p>

<p>答案是git上存在一个默认的设置选项<code class="language-plaintext highlighter-rouge">autocrlf</code>，pull拉取文件的时候会将文件的换行符自动切换为当前设备的换行符。这种方法一般而言是十分方便的，但是对于嵌入式开发来说带来了额外的问题。</p>

<blockquote>
  <p>本质上问题还是偷懒了，开发板一定会接win的电脑，需要xterm之类的串口，还需要通过网口和电脑测试。所以就没有连开发板和gitlab的服务器，结果出现了这种和平台相关的问题。</p>
</blockquote>

<h1 id="解决方法">解决方法</h1>
<ol>
  <li>嵌入式设备允许的情况下，在设备的linux CLI使用git clone获得测试源码</li>
  <li>设置仓库中的autocrlf变量
 设置全局（在本地创建和克隆的都受到影响）
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> git config --global core.autocrlf true
</code></pre></div>    </div>
    <p>设置当前仓库</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> git config core.autocrlf false
</code></pre></div>    </div>
  </li>
</ol>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="问题" /><category term="git" /><category term="shell" /></entry><entry><title type="html">Cmake出来的可执行文件找不到库文件</title><link href="https://honest-zh.github.io/%E9%97%AE%E9%A2%98/Cmake%E5%87%BA%E6%9D%A5%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%BA%93%E6%96%87%E4%BB%B6/" rel="alternate" type="text/html" title="Cmake出来的可执行文件找不到库文件" /><published>2024-12-31T00:00:00+00:00</published><updated>2024-12-31T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E9%97%AE%E9%A2%98/Cmake%E5%87%BA%E6%9D%A5%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%BA%93%E6%96%87%E4%BB%B6</id><content type="html" xml:base="https://honest-zh.github.io/%E9%97%AE%E9%A2%98/Cmake%E5%87%BA%E6%9D%A5%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%BA%93%E6%96%87%E4%BB%B6/"><![CDATA[<h1 id="问题描述">问题描述</h1>

<p>项目中使用Cmake自动化构建，首先将源码生成动态库，然后编译测试用例，最后把编译好的动态库和测试例都转移到输出目录中方便部署。
出现的问题是输出目录中的测试用例可执行文件在运行时提示找不到对应的动态库，需要手动设置LD_LIBRARY_PATH</p>

<h1 id="解决方法">解决方法</h1>
<p><strong>使用 rpath 选项和make install</strong></p>

<p>在 CMakeLists.txt 中添加链接选项：在生成可执行文件（测试用例）的 add_executable 和 target_link_libraries 部分，通过 SET_TARGET_PROPERTIES 来设置 rpath。</p>

<p>示例如下：</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 生成动态库</span>
<span class="nb">add_library</span><span class="p">(</span>mylib SHARED mylib.cpp<span class="p">)</span>

<span class="c1"># 生成测试用例可执行文件</span>
<span class="nb">add_executable</span><span class="p">(</span>test_mylib test_mylib.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>test_mylib mylib<span class="p">)</span>

<span class="c1"># 设置 RPATH，假设动态库和可执行文件最终在同一输出目录下</span>
<span class="nf">SET_TARGET_PROPERTIES</span><span class="p">(</span>test_mylib PROPERTIES
    INSTALL_RPATH <span class="s2">"Path/of/mylib"</span>
<span class="p">)</span>

<span class="c1"># 安装动态库</span>
<span class="nb">install</span><span class="p">(</span>TARGETS mylib
    LIBRARY DESTINATION lib
<span class="p">)</span>

<span class="c1"># 安装可执行文件</span>
<span class="nb">install</span><span class="p">(</span>TARGETS test_mylib
    RUNTIME DESTINATION bin
<span class="p">)</span>

<span class="c1"># 安装头文件</span>
<span class="nb">install</span><span class="p">(</span>FILES myheader.h
    DESTINATION include
<span class="p">)</span>
</code></pre></div></div>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="问题" /><category term="Cmake" /></entry><entry><title type="html">白色相簿2</title><link href="https://honest-zh.github.io/%E9%9A%8F%E7%AC%94/%E7%99%BD%E8%89%B2%E7%9B%B8%E7%B0%BF2/" rel="alternate" type="text/html" title="白色相簿2" /><published>2024-12-19T00:00:00+00:00</published><updated>2024-12-24T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E9%9A%8F%E7%AC%94/%E7%99%BD%E8%89%B2%E7%9B%B8%E7%B0%BF2</id><content type="html" xml:base="https://honest-zh.github.io/%E9%9A%8F%E7%AC%94/%E7%99%BD%E8%89%B2%E7%9B%B8%E7%B0%BF2/"><![CDATA[<hr />

<center>白色相簿什么的已经无所谓了，</center>
<center>因为已经不再有歌，值得去唱了。</center>
<center>传达不了的恋情已经不需要了，</center>
<center>因为已经不再有人，值得去爱了。</center>

<hr />
<h1 id="前言">前言</h1>
<audio controls="" autoplay="">
    <source src="/assets/music/%E5%B0%8F%E6%9C%A8%E6%9B%BD%E9%9B%AA%E8%8F%9C%20-%20WHITE%20ALBUM%20Live%20at%20Campus%20Fes.mp3" type="audio/mpeg" />
    Your browser does not support the audio element.
</audio>

<p>不知不觉间，又到了白色相簿的季节。在第一次看动画，因为冬马雪菜春希三人的纠结关系胃疼时，我就早已有所耳闻了——游戏的CC和Coda部分才是白色相簿2的精华。但是直到多年后的今天，在通关了这款被称为“脱宅神作”的Galgame以后的此时此刻，我才明白我曾经错过了怎样优秀的作品，我才后悔为何没能更早的玩到他。</p>

<p>白色相簿整个故事的悲剧性就来源于IC时三人在青春期犯下的错误。相对的，CC讲述了春雪两人挣扎而痛苦的成长，到了Coda则是两种不同恋爱观念的选择。</p>

<h1 id="-introductory-chapter-">-Introductory Chapter-</h1>

<hr />

<center>命运的开始,无法挽回的青春</center>

<hr />
<p>为自己循规蹈矩的人生而不甘的，如同教科书一般的努力、负责、热心肠的模范三好学生<strong>北原春希</strong>，想为自己的青春留下最后的回忆。至少要任性一次、至少要装帅一次，这样想着的春希加入了好兄弟<strong>饭冢武也</strong>的轻音乐部，期望着能在学院祭的舞台上大展手脚。尽管只是一个作为吉他候补的拙劣新手，春希也对能够真正参与到“青春”之中而满足。然而，轻音乐部因为坏女人主唱柳原朋而人际关系破裂，整个社团分崩离析，只剩下了武也和春希。仅有两个吉他手无疑是无法构成乐队的，武也自然的放弃了在学院祭上演出的计划。只剩下不甘心的北原春希在第三音乐室里独自弹着吉他，为了无谓的目标而努力。</p>

<p>非要压抑的度过这一段人生了吗？只能把压抑了17年的情感继续压抑下去了吗？只能继续做一个古板、婆婆妈妈的前班长和兢兢业业的做题家了吗？在人生中本该最绚丽的、最青春的时间段…</p>

<p>伴着隔壁第二音乐室里与他共奏的钢琴，春希这样想着，依然盲目而执拗的练习。命运本该就这样结束——他将不得不放弃让自己最后闪耀的机会，徒劳的看着青春从琴头的指尖逝去。直到那一天到来、直到改变了一切的合奏开始、直到《White Album》命运的歌声响起，实现他愿望的天使降临了——<strong>小木曾雪菜</strong>。</p>

<p><img src="/assets/images/blog/white_album1.png" alt="" /></p>

<p>春希听到了天籁，更看到了天使——啊，我的青春就该是这样的！让她加入轻音乐部吧！为了我贫瘠了17年的青春，为了我压抑了17年的心，为了学院祭最后的绽放，稍微任性一些也无妨吧！</p>

<p>此时的春希不知道的是，在隔壁的音乐教室与他合奏钢琴的正是他早已暗生情愫的同桌——<strong>冬马和纱</strong>。<del>他更不会知道的是，和纱也早就喜欢上了他</del></p>
<blockquote>
  <p>梦里不觉秋意深，余情岂是为他人</p>
</blockquote>

<p><img src="/assets/images/blog/white_album3.png" alt="" /></p>

<p>从这一首共演的《White Album》开始，三人命定一般的故事开始了。</p>

<hr />

<p>白色相簿2的IC章节是没有选项的，在我的理解里这是丸户刻意制造的局面。在故事的早期，只要做出一点很小的选择就足以改变春冬雪三人这种复杂的感情局面。但是从故事的角度来说，这样子无疑会让整个故事变得乏善可陈，落入寻常的Galgame的窠臼。丸户在IC想要体现的其实是无法挽回的、伤害和被伤害已经成为既定事实的青春。</p>

<p>在青春里，你因为不懂女人心而错过了你最喜欢也最喜欢你的人；在青春里，你因为自卑和傲娇永远无法把心中的话说给最希望听的人；在青春里，你因为慌乱和懵懂的喜欢而抢先出手拿下了挚友也喜欢的男孩；在青春里，并不成熟三人笨拙的相处、青涩的相恋，然后又因为这份笨拙和青涩相互伤害——直到一人逃避远走，三人的故事变为两人与一人。</p>

<h2 id="北原春希">北原春希</h2>

<p>春希的本质实际上是一个善良的努力者，通俗一点的说是好心的做题家。他对于条条框框的规矩格外遵守，坚信努力就有回报，在过去的人生里一直压抑自己的青春换来秀才的名声，近乎偏执的执着于帮助他人，让人怀疑是否是具有白骑士情节。但是在另一面被这些形象所隐藏的，春希是一个无比渴望精彩热烈的校园生活，也无比渴望爱情的人。他是古板的班长，是兢兢业业努力的好学生，是乐于助人的里之委员长；他更是普通的高中生，是血气方刚的男孩，是懵懂的青春期少年。这种想法春希其实并不是到了临近毕业的高三才突然出现的，而是一直伴随在他尽力压抑的校园生活中的（实际上春希的欲望十分强烈，此事在雪菜TE亦有记载）。</p>

<p>加入轻音乐部、练习吉他、想要参加校园祭留下完美的青春回忆，这是春希最开始也最强烈的心愿。最开始他不曾幻想也不敢幻想自己竟然能拥有这样热烈而跌宕的青春。他只是执拗的坚持自己的梦想，不断地向前努力，命运的巧合和作弄就将春冬雪三人的线团紧紧的纠缠在一起。</p>

<p>他喜欢冬马，也喜欢雪菜（应该没有人能够不喜欢）。如果非要权衡，因为喜欢冬马的时间更长一些、所以更喜欢冬马一些。但是他不知道冬马也喜欢着自己，而且时哪样的喜欢自己，更觉得自己不配冬马喜欢<del>但是冬马也是这么想的</del>。所以在心满意足的学院祭后，面对雪菜的热情表白，他毫无抵抗能力的接受了。</p>

<p>在表白后的第一时间里，春希就找到了冬马和她说明了情况——自己和雪菜交往了，是我告白的。我曾经喜欢你，但是我选择了雪菜，抱歉——春希心中一定是这么想的吧。在之后的故事里，三人一起日常相处，和谐的背后隐藏着酝酿的爆发。冬马努力扮演夹在中间的好友身份却又痛苦不已。春希逐渐知道自己心中还喜欢着冬马，并努力地想要忘却她。他尽力地想扮演好雪菜地男友的角色，想要在雪菜的生日用带有雪菜名字的戒指推进关系，将两人紧紧绑在一起。雪菜尽力克制自己和春希在冬马面前的互动，想要维护三人共同好友的情景一直持续下去。</p>

<p>然而这种做法本身就是不对的，三人之间的话依然和最开始一样没有说开；春冬二人的心意没能相通；雪菜也因为自己的所作所为而陷入了深深的自责。如果春希在找冬马的时候就能大方的好好告诉她自己喜欢她，如果在三人相处逐渐意识到自己仍有对冬马的喜欢之后春希就和雪菜坦白一切，或许三人都会更幸福吧。</p>

<p>当春希知道冬马刚刚通过考验回国，即将远走欧洲留学时，努力压抑的感情爆发了。他爽约了雪菜的生日派对，跑到了机场迎接冬马。这是最重要的，最大的背叛，代表着春希的心向着与雪菜相反的方向前进。雪菜其实也和春希一样，为了推进二人的关系早已做好了准备，在圣诞夜这天支开了家人。此时如果两人能够心意相通知道对方想法的话，结果或许会不一样吧。只要春希叫上雪菜一起寻找冬马，见面的两人一定会互相吐露内心吧。但是春希鸽掉生日的原因其实是两部分组成的，一部分是对于自己和雪菜关系推进太快的惶恐，对关系进一步发展的巨大责任的逃避，另一部分是竭力让自己忘记冬马然后突然得知以后无法相见的痛苦和这么重要的事情冬马却一直不告诉自己的不甘。</p>

<p>落雪纷纷而下，冻结的心相互碰撞，在熟练街上，春希和冬马互相吐露了心声。春希终于意识到了自己是多么不懂女人心的愚钝的男人、冬马也终于意识到春希也喜欢着自己只是因为自卑而退缩了。如火山爆发般压抑不住的情绪让春希强吻了冬马，但是就连熟练的亲吻本身都是春雪二人关系的铁证——冬马再次崩溃选择了逃离。</p>

<p>无助的春希想雪菜求助，却又没有勇气说出实话，只能对雪菜撒谎。</p>

<h2 id="小木曾雪菜">小木曾雪菜</h2>

<p>在IC的故事中，小木曾雪菜从未掩饰自己对春希的喜欢。最开始总是拒绝，然后总是被春希打动改变主意。春希为在天台上高歌的小木曾雪菜而倾倒，按捺不住心中的躁动，主动邀请了雪菜参加学院祭的演出。然而早就因为自己超群的名声而深深苦恼的雪菜，并不想在大众面前抛头颅面，拒绝了春希的请求——一如之前一开始拒绝参与峰城大附属小姐一样。为了让雪菜加入，春希直接找到了雪菜打工的地方，见识到了雪菜高岭之花外表下亲切、平易近人、有些虚荣又逞强的一面。</p>

<blockquote>
  <p>这样一来，小木曾雪菜的秘密，就一个不剩了呢。因为，全部都被你知道了呢。</p>
</blockquote>

<p><img src="/assets/images/blog/white_album4.png" alt="" /></p>

<p>在春希的努力之下，雪菜改变了之前的想法——一如之前后来又改变主意决定参与峰城大附属小姐一样。而这两次转变的原因毫无疑问就是雪菜对春希的好感和喜欢。</p>

<h2 id="冬马和纱">冬马和纱</h2>
<p>冬马一开始很好的扮演了恋人的好友的角色，但是她实在是按捺不住对春希的喜欢，在这样的三人行游戏里倍感痛苦。</p>
<h1 id="-closing-chapter-">-Closing Chapter-</h1>
<hr />

<center>背叛的刺深植，无法前进更无法后退的二人</center>

<hr />

<p>为什么，为什么会变成现在这样子呢？你无数次的想，但是伤害已经造成，青春已经过去。或许比起那时现在的你有了更多成长，再来一次或许会有不同的选择，但事实的伤口早已横亘在心间，时针永不回转。现在能做的事情只有拼命的补救，纵然身心俱疲、纵然遍体鳞伤，这也是弥补过去的错误的唯一的方法。逃避或者心照不宣的隐瞒或许能得到一时的轻松，但是背叛的利刺将一直插在二人的心间——无论进退都只会带来更大的痛苦。唯一的方法是咬着牙坚强的面对它，无论多么痛苦也要携手将其拔除。当二人痛苦而幸福的紧紧相拥时，结痂的血液才会将二人相连，彼此的血才能愈合对方的伤口。</p>

<h1 id="-coda-">-Coda-</h1>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="随笔" /><category term="白色相簿" /><category term="Galgame" /></entry><entry><title type="html">基于jekyll和github page的个人主页搭建经验</title><link href="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EJekyll%E5%92%8CGithub-Page%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E6%90%AD%E5%BB%BA%E7%BB%8F%E9%AA%8C/" rel="alternate" type="text/html" title="基于jekyll和github page的个人主页搭建经验" /><published>2024-12-12T00:00:00+00:00</published><updated>2024-12-19T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EJekyll%E5%92%8CGithub%20Page%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E6%90%AD%E5%BB%BA%E7%BB%8F%E9%AA%8C</id><content type="html" xml:base="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EJekyll%E5%92%8CGithub-Page%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E6%90%AD%E5%BB%BA%E7%BB%8F%E9%AA%8C/"><![CDATA[<h1 id="基于jekyll和github-page的个人主页搭建经验">基于Jekyll和Github Page的个人主页搭建经验</h1>

<h2 id="一方案选择">一、方案选择</h2>

<p>大体上讲，搭建个人网站有几种常见的方案技术路线。一种是分为前端和后端，使用web服务器处理web请求的<strong>通用网页方案</strong>；另一种是使用<strong>静态网页生成器</strong>将所有网页内容预先生成为静态文件（如 HTML、CSS、JavaScript），然后部署到<strong>静态网页托管平台</strong>上。</p>

<p>前者是web网页的一般方法，由前端和后端两部分组成。前端负责提供网页的结构、布局和交互等可视化的直接和用户接触的部分，后端负责处理请求的业务逻辑、数据存储和安全性等涉及服务器端的部分。</p>

<ul>
  <li>
    <p>前端的核心是HTML、CSS、JavaScript三个部分，分别对应了网页的结构、布局和交互处理。除此以外，还有其他基于JavaScript的前端的框架（如 <code class="language-plaintext highlighter-rouge">React</code>、<code class="language-plaintext highlighter-rouge">Vue.js</code>、<code class="language-plaintext highlighter-rouge">Angular</code>）用来简化网页交互的编写。</p>
  </li>
  <li>
    <p>后端的核心是Web服务器、后端框架和数据库。</p>

    <ul>
      <li>Web服务器主要用于连接用户的网页请求和用于处理请求的服务器。具体来说：主要负责处理用户HTTP/HTTPS请求、对后端的服务器进行反向代理和负载均衡。</li>
      <li>后端框架则主要用于处理业务逻辑，负责对web服务器代理后的请求进行处理。常见的后端框架有：Python的<code class="language-plaintext highlighter-rouge">Django</code>,和<code class="language-plaintext highlighter-rouge">Flask</code>、JavaScript的<code class="language-plaintext highlighter-rouge">Node.js</code>、Java的<code class="language-plaintext highlighter-rouge">Spring</code>等。</li>
      <li>数据库则是十分明了的用于存储和管理数据。常见的数据库包括：<code class="language-plaintext highlighter-rouge">MySQL</code>、<code class="language-plaintext highlighter-rouge">Oracle</code>（关系型数据库）、<code class="language-plaintext highlighter-rouge">MongoDB</code>、<code class="language-plaintext highlighter-rouge">Redis</code>（非关系型数据库）。</li>
    </ul>
  </li>
</ul>

<p>后者是用于生成静态网页的方法，即使用静态网页生成器（如<code class="language-plaintext highlighter-rouge">Jekyll</code>、<code class="language-plaintext highlighter-rouge">Hugo</code>、<code class="language-plaintext highlighter-rouge">Hexo</code>等）预先生成好网页，将之存为不需要服务器端处理的文件（如<code class="language-plaintext highlighter-rouge">HTML</code>、<code class="language-plaintext highlighter-rouge">CSS</code>、<code class="language-plaintext highlighter-rouge">JavaScript</code>）。静态网页可以直接使用静态网页托管平台直接进行部署，如<code class="language-plaintext highlighter-rouge">Github Pages</code>、<code class="language-plaintext highlighter-rouge">Vercel</code>、<code class="language-plaintext highlighter-rouge">Netlify</code>等。</p>

<p>动态网页的灵活性更高，可以处理更多的交互需求，但是需要服务器端的支持，部署较为复杂，需要额外的服务器;静态网页的灵活性较差，但是部署简单，可以直接使用Github Page进行部署（还省去了配置公网IP和网页备案的麻烦）。对比两种方案，静态网页的方案适合个人主页低更新频率，交互性较弱的应用需求。</p>

<p>因此，我最后选择了静态网页的方案，使用<strong>Jekyll的Minimal Mistakes主题</strong>和<strong>Github Pages静态网页托管平台</strong>组合的方案搭建了自己的个人主页。</p>

<p>首先，我在运行了ubuntu的虚拟机上下载Jekyll和其所需要的环境。然后，根据自己的使用需要，按照MInimal Mistakes的文档说明修改了<code class="language-plaintext highlighter-rouge">_config.yml</code>配置文件，调整了个人主页的一些常用设置。最后使用Github Page的部署功能来部署整个网页。</p>

<blockquote>
  <p>PS.除了使用模板以外，也可以根据自己需要的格式修改<code class="language-plaintext highlighter-rouge">_layout</code>文件夹中的模板。添加自己想要的内容。</p>
</blockquote>

<h2 id="二jekyll和minimal-mistakes主题">二、Jekyll和Minimal Mistakes主题</h2>

<p><a href="https://jekyllrb.com/docs">Jekyll</a>是一个基于 Ruby 语言开发的开源静态网页生成器。其核心原理是将包含文本内容（如 Markdown 文件）、布局模板（如 HTML 模板）和配置文件（如<code class="language-plaintext highlighter-rouge">_config.yml</code>）的源文件目录，通过一系列的转换和处理，生成最终的静态网站（HTML、CSS、JavaScript 等文件的集合）。<a href="https://mmistakes.github.io/minimal-mistakes/docs">Minimal Mistakes</a>是一个Jekyll的主题，提供了丰富的功能和灵活的配置选项，可以方便地设置美观的网页的布局和样式。</p>

<h3 id="1部署jekyll环境">1.部署Jekyll环境</h3>

<p>这一步其实来说并不是必要的，只是在本地拥有可以使用Jekyll构建网页的环境对于修改个人主页的一些功能来说会更加的方便。<del>你也不想每次对网页布局之类的细微修改的尝试都要push到github上然后重新等待他慢慢的生成网页吧，这实在是太麻烦了</del>。</p>

<p>首先你需要确保的是你拥有一个Linux的虚拟机环境，不管是VMware或者WSL都可以。我使用的是WSL，可以直接在VScode中使用。<del>非常的方便，用过都说豪用</del>。具体怎么弄我这里就不赘述了，网上有很多教程。</p>

<ol>
  <li>
    <p>安装 Ruby：</p>

    <p>Jekyll 是基于 Ruby 构建的，所以首先需要安装 Ruby。通过以下命令安装 Ruby：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt - get update
   
<span class="nb">sudo </span>apt - get <span class="nb">install </span>ruby - full
</code></pre></div>    </div>
  </li>
  <li>
    <p>安装 Jekyll 和 Bundler（RubyGems 包管理器）：</p>

    <p>在安装好 Ruby 后，可以使用 RubyGems 来安装 Jekyll 和 Bundler。在终端（命令提示符或 PowerShell）中输入以下命令：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem <span class="nb">install </span>jekyll bundler
</code></pre></div>    </div>
  </li>
  <li>
    <p>创建项目</p>

    <p>a. 新创建项目</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jekyll new <span class="nb">.</span>
</code></pre></div>    </div>

    <p>b. 从原有的模板复制一个项目</p>

    <p>最简单的方法就是直接使用git clone直接复制这个项目的文件下来。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> git clone https://github.com/HONEST-ZH/HONEST-ZH.github.io.git
</code></pre></div>    </div>
  </li>
  <li>
    <p>修改网页</p>

    <p>修改<code class="language-plaintext highlighter-rouge">_config.yml</code>或者<code class="language-plaintext highlighter-rouge">_layout</code>里的布局文件来达到你满意的网页效果。</p>
  </li>
  <li>
    <p>本地运行尝试</p>

    <p>执行以下命令来运行本地运行jekyll网页的服务器，工作的ip地址是<code class="language-plaintext highlighter-rouge">127.0.0.1:4000</code></p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bundle <span class="nb">install
</span>bundle <span class="nb">exec </span>jekyll serve
</code></pre></div>    </div>
  </li>
  <li>
    <p>重复4-5直到网页满足你的需求。</p>
  </li>
</ol>

<h2 id="三设置github-page">三、设置Github Page</h2>

<p>对于一般的静态网页而言，我们只需要将jekyll项目提交到名为<code class="language-plaintext highlighter-rouge">username.github.io</code>的仓库中（名字需要和github的账户名字一致，否则会无效），然后再选择<code class="language-plaintext highlighter-rouge">Settings-Pages-Deploy From a Branch</code>，<code class="language-plaintext highlighter-rouge">branch-main</code>。完成设置以后，就可以实现静态网页的部署了，Github会在Action中自动新建一个名为<code class="language-plaintext highlighter-rouge">pages-build-deployment</code>的工作流，每次选定的分支（main）上发生推送时会自动地构建和部署网页。</p>

<p><img src="/assets/images/blog/2024-12-18-16-33-44-image.png" alt="" /></p>

<p>但是这里因为我使用了Minimal Mistakes模板的原因，网页是没有办法使用这种方法的直接生成的。网页在编译时会报错，找不到模板的Gem包。</p>

<p><img src="/assets/images/blog/2024-12-18-16-44-39-image.png" alt="" /></p>

<p><img src="/assets/images/blog/2024-12-18-16-44-56-image.png" alt="" /></p>

<p>这是因为默认的<code class="language-plaintext highlighter-rouge">pages-build-deployment</code>工作流没有去下载所需要的依赖，而缺少了Jekyll模板。解决这个问题的方法也很简单，就是自己创建一个工作流保证每一次都能把所需要的依赖装好。</p>

<h3 id="1-创建gh-pagesyml工作流文件">1. 创建gh-pages.yml工作流文件</h3>

<p>在项目的根目录下创建.github/workflows文件夹然后添加gh-pages.yml文件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> .github/workflows
<span class="nb">touch</span> .github/workflows/gh-pages.yml
</code></pre></div></div>

<h3 id="2-编写gh-pagesyml">2. 编写gh-pages.yml</h3>

<p>在gh-pages.yml文件中写入：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">GitHub Pages</span>
<span class="na">on</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">main</span>  <span class="c1"># 监听的分支</span>
<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v2</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set up Ruby</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/setup-ruby@v1</span>
      <span class="na">with</span><span class="pi">:</span>
        <span class="na">ruby-version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.2'</span>  <span class="c1"># 确保使用正确的 Ruby 版本</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install dependencies</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">bundle install</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build the site</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">bundle exec jekyll build</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Deploy to GitHub Pages</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">peaceiris/actions-gh-pages@v3</span>
      <span class="na">with</span><span class="pi">:</span>
        <span class="na">github_token</span><span class="pi">:</span> <span class="s">$</span>
        <span class="na">publish_dir</span><span class="pi">:</span> <span class="s">./_site</span>
</code></pre></div></div>

<p>这个工作流在每次检测到<code class="language-plaintext highlighter-rouge">main</code>分支上有推送时：下载所需要的Gem包依赖，构建静态网页，将静态网页的文件推送到一个专门用于存储静态网页的分支<code class="language-plaintext highlighter-rouge">gh-pages</code>。</p>

<h3 id="3-github-pages从gh-pages分支部署">3. Github pages从gh-pages分支部署</h3>

<p><code class="language-plaintext highlighter-rouge">gh-pages</code>分支被更新后，还没有完成网页的部署。此时需要把github page关注的分支换为<code class="language-plaintext highlighter-rouge">gh-pages</code>，根据每次推送到<code class="language-plaintext highlighter-rouge">gh-pages</code>上的文件部署静态网页。工作流的结果显示如下图所示，此时就可以在<code class="language-plaintext highlighter-rouge">username.github.io</code>中访问个人主页的页面了。</p>

<p><img src="/assets/images/blog/2024-12-18-17-01-56-image.png" alt="" /></p>

<h2 id="四网页的使用">四、网页的使用</h2>

<h3 id="1基本frontmatter">1.基本FrontMatter</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>

<span class="na">title</span><span class="pi">:</span> <span class="s2">"</span><span class="s">文章标题"</span>

<span class="na">date</span><span class="pi">:</span> <span class="s">2023-10-20</span>

<span class="na">last_modified_at</span><span class="pi">:</span> <span class="s">2023-10-21    # 最后修改时间</span>

<span class="na">categories</span><span class="pi">:</span>

<span class="s">  - 技术</span>

<span class="s">  - ZMQ</span>

<span class="na">tags</span><span class="pi">:</span>

<span class="s">  - 消息队列</span>

<span class="s">  - 网络编程</span>

<span class="na">toc</span><span class="pi">:</span> <span class="no">true</span><span class="s">                      </span> <span class="c1"># 显示目录</span>

<span class="na">toc_sticky</span><span class="pi">:</span> <span class="no">true</span><span class="s">              </span> <span class="c1"># 固定目录</span>

<span class="na">toc_label</span><span class="pi">:</span> <span class="s2">"</span><span class="s">目录"</span> <span class="s">             # 目录标题</span>

<span class="na">toc_icon</span><span class="pi">:</span> <span class="s2">"</span><span class="s">cog"</span> <span class="s">             </span> <span class="c1"># 目录图标</span>

<span class="c1">#图片</span>

<span class="na">header</span><span class="pi">:</span>

<span class="na">  image</span><span class="pi">:</span> <span class="s">/assets/images/header.jpg          </span> <span class="c1"># 头部大图</span>

<span class="na">  teaser</span><span class="pi">:</span> <span class="s">/assets/images/teaser-image.jpg    # 预览图</span>

<span class="na">  overlay_image</span><span class="pi">:</span> <span class="s">/assets/images/banner.jpg  </span> <span class="c1"># 覆盖图</span>

<span class="na">  overlay_color</span><span class="pi">:</span> <span class="s2">"</span><span class="s">#333"</span> <span class="s">                     # 覆盖颜色</span>

<span class="na">  caption</span><span class="pi">:</span> <span class="s2">"</span><span class="s">图片来源:</span><span class="nv"> </span><span class="s">[**网站**](链接)"</span> <span class="s">     # 图片说明</span>



<span class="na">excerpt</span><span class="pi">:</span> <span class="s2">"</span><span class="s">这是文章摘要，将显示在文章列表中"</span> <span class="s">   # 文章摘要</span>

<span class="c1"># 作者相关</span>

<span class="na">author</span><span class="pi">:</span> <span class="s">Your Name</span>

<span class="na">author_profile</span><span class="pi">:</span> <span class="no">true</span><span class="s">    # 显示作者信息</span>

<span class="c1"># 布局相关</span>

<span class="na">layout</span><span class="pi">:</span> <span class="s">single</span>

<span class="na">classes</span><span class="pi">:</span> <span class="s">wide          # 宽屏显示</span>

<span class="c1"># 评论相关</span>

<span class="na">comments</span><span class="pi">:</span> <span class="no">true</span><span class="s">        # 启用评论</span>

<span class="na">share</span><span class="pi">:</span> <span class="no">true</span><span class="s">          </span> <span class="c1"># 显示分享按钮</span>

<span class="c1"># 相关文章</span>

<span class="na">related</span><span class="pi">:</span> <span class="no">true</span><span class="s">        </span> <span class="c1"># 显示相关文章</span>

<span class="c1"># 阅读时间</span>

<span class="na">read_time</span><span class="pi">:</span> <span class="no">true</span><span class="s">      </span> <span class="c1"># 显示预计阅读时间</span>

<span class="c1"># 导航</span>

<span class="na">sidebar</span><span class="pi">:</span>

<span class="na">  nav</span><span class="pi">:</span> <span class="s2">"</span><span class="s">main"</span> <span class="s">       # 侧边栏导航</span>

<span class="c1"># SEO相关</span>

<span class="na">description</span><span class="pi">:</span> <span class="s2">"</span><span class="s">这是一段用于SEO的描述"</span>

<span class="na">keywords</span><span class="pi">:</span> <span class="s2">"</span><span class="s">关键词1,</span><span class="nv"> </span><span class="s">关键词2"</span>

<span class="nn">---</span>
</code></pre></div></div>

<h3 id="2ai工具生成顶部配图">2.AI工具生成顶部配图</h3>

<p>使用ChatGPT生成提示词，然后使用DALLE-3生成图片</p>
<blockquote>
  <p>提示词应该具有的结构：</p>
  <ul>
    <li>主题描述
描述主要场景或元素，让 AI 理解你想要生成的内容是什么。</li>
    <li>细节补充
包括场景的颜色、灯光、材质等信息，增加细节丰富度。
*情感与氛围
指定图像的情感和氛围，如“宁静”、“温暖”、“科幻感”等。</li>
    <li>视觉风格
选择一种视觉呈现方式，如“水彩画风格”、“数字艺术”、“摄影级真实感”等。</li>
    <li>构图与比例
提到图像的布局与比例，如“宽屏横向构图”、“16:9比例”。</li>
    <li>特定要求（可选）
如果需要特别的元素，比如“背景模糊”或“有特定的道具”，也可以写明。</li>
  </ul>
</blockquote>

<p>例如：
提示词为</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A breathtaking sunset over a calm ocean, 
with soft waves reflecting the warm orange and pink hues of the sky, a few scattered clouds, and silhouetted palm trees framing the scene.
Cinematic wide-angle composition, 16:9 aspect ratio, high detail, serene and peaceful mood, digital painting style，1200px width
</code></pre></div></div>
<p>生成的图像为
<img src="/assets/images/blog/ai_generate.jpg" alt="" /></p>

<h3 id="3markdown文档编写">3.Markdown文档编写</h3>

<p>使用Marktext以方便的编写MarkDown笔记，可以直接粘贴图片。图片可能被以网络链接的方式引用，也可能保存在本地的<code class="language-plaintext highlighter-rouge">C:\Users\HONEST\AppData\Roaming\marktext\images\</code>路径下，需要把图片的路径改成<code class="language-plaintext highlighter-rouge">/assets/images/blog_header</code>或者<code class="language-plaintext highlighter-rouge">/assets/images/blog</code></p>
<blockquote>
  <p>linux路径使用/，windows路径使用\</p>
</blockquote>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="笔记" /><category term="Github Pages" /><category term="Jekyll" /><category term="个人主页" /></entry><entry><title type="html">Gdb</title><link href="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/GDB/" rel="alternate" type="text/html" title="Gdb" /><published>2024-11-13T00:00:00+00:00</published><updated>2024-11-13T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/GDB</id><content type="html" xml:base="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/GDB/"><![CDATA[<p>GDB（GNU Debugger）是一款强大的调试工具，主要用于调试 C、C++ 和其他编程语言编写的程序。以下是 GDB 的使用方法：</p>

<p><strong>一、启动 GDB</strong></p>

<ol>
  <li>
    <p>编译程序时加上调试信息</p>

    <ul>
      <li>在编译程序时，使用 <code class="language-plaintext highlighter-rouge">-g</code> 选项可以让编译器生成调试信息，以便 GDB 能够更好地进行调试。例如，对于 C 程序，可以使用以下命令进行编译：<code class="language-plaintext highlighter-rouge">gcc -g program.c -o program</code>。对于 C++ 程序，可以使用：<code class="language-plaintext highlighter-rouge">g++ -g program.cpp -o program</code>。</li>
    </ul>
  </li>
  <li>
    <p>启动 GDB</p>

    <ul>
      <li>启动 GDB 并加载要调试的程序。在命令行中输入 <code class="language-plaintext highlighter-rouge">gdb program</code>，其中 <code class="language-plaintext highlighter-rouge">program</code> 是要调试的程序的名称。</li>
    </ul>
  </li>
</ol>

<p><strong>二、基本命令</strong></p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">run</code>（或 <code class="language-plaintext highlighter-rouge">r</code>）</p>

    <ul>
      <li>运行程序。在 GDB 中输入 <code class="language-plaintext highlighter-rouge">run</code> 命令后，程序将开始执行。如果程序需要命令行参数，可以在 <code class="language-plaintext highlighter-rouge">run</code> 命令后面加上参数，例如：<code class="language-plaintext highlighter-rouge">run arg1 arg2</code>。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">break</code>（或 <code class="language-plaintext highlighter-rouge">b</code>）</p>

    <ul>
      <li>设置断点。可以在程序的特定行号、函数名或地址处设置断点。例如，要在第 10 行设置断点，可以输入 <code class="language-plaintext highlighter-rouge">break 10</code>。要在名为 <code class="language-plaintext highlighter-rouge">main</code> 的函数处设置断点，可以输入 <code class="language-plaintext highlighter-rouge">break main</code>。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">next</code>（或 <code class="language-plaintext highlighter-rouge">n</code>）</p>

    <ul>
      <li>执行下一行代码，但不进入函数内部。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">step</code>（或 <code class="language-plaintext highlighter-rouge">s</code>）</p>

    <ul>
      <li>执行下一行代码，如果是函数调用，则进入函数内部。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">continue</code>（或 <code class="language-plaintext highlighter-rouge">c</code>）</p>

    <ul>
      <li>继续执行程序，直到遇到下一个断点或程序结束。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">print</code>（或 <code class="language-plaintext highlighter-rouge">p</code>）</p>

    <ul>
      <li>打印变量的值。例如，要打印变量 <code class="language-plaintext highlighter-rouge">x</code> 的值，可以输入 <code class="language-plaintext highlighter-rouge">print x</code>。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">backtrace</code>（或 <code class="language-plaintext highlighter-rouge">bt</code>）</p>

    <ul>
      <li>打印调用栈信息，显示当前程序的执行路径。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">quit</code>（或 <code class="language-plaintext highlighter-rouge">q</code>）</p>

    <ul>
      <li>退出 GDB。</li>
    </ul>
  </li>
</ol>

<p><strong>三、查看变量和内存</strong></p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">info locals</code></p>

    <ul>
      <li>显示当前函数的局部变量及其值。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">info args</code></p>

    <ul>
      <li>显示当前函数的参数及其值。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">x /&lt;format&gt; &lt;address&gt;</code></p>

    <ul>
      <li>检查内存地址处的值。<code class="language-plaintext highlighter-rouge">&lt;format&gt;</code> 可以是不同的格式说明符，例如 <code class="language-plaintext highlighter-rouge">x/d</code> 表示以十进制格式显示整数，<code class="language-plaintext highlighter-rouge">x/s</code> 表示以字符串格式显示内存内容。</li>
    </ul>
  </li>
</ol>

<p><strong>四、条件断点</strong></p>

<p>可以设置条件断点，只有当满足特定条件时，断点才会生效。例如，要在变量 <code class="language-plaintext highlighter-rouge">x</code> 等于 10 时才中断程序，可以输入 <code class="language-plaintext highlighter-rouge">break 10 if x == 10</code>。</p>

<p><strong>五、多线程调试</strong></p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">info threads</code></p>

    <ul>
      <li>显示当前程序中的所有线程。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">thread &lt;thread-id&gt;</code></p>

    <ul>
      <li>切换到指定的线程进行调试。</li>
    </ul>
  </li>
</ol>

<p><strong>六、远程调试</strong></p>

<p>可以使用 GDB 进行远程调试，例如调试在另一台机器上运行的程序。这通常需要在目标机器上运行一个调试服务器，并在本地使用 GDB 连接到该服务器。</p>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="笔记" /><category term="GDB" /></entry><entry><title type="html">Cmake笔记</title><link href="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/Cmake%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="Cmake笔记" /><published>2024-11-06T00:00:00+00:00</published><updated>2025-01-14T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/Cmake%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/Cmake%E7%AC%94%E8%AE%B0/"><![CDATA[<h1 id="cmake笔记">Cmake笔记</h1>

<h2 id="一-cmake介绍">一、 Cmake介绍</h2>

<p>Cmake是一种<strong>与平台无关</strong>的自动控制项目编译过程的工具（自动生成makefile文档）。只需要配置CMakeList.txt就可以自动的根据平台生成Makefile，方便的跨越多个平台进行编译。</p>

<blockquote>
  <p>CMakeList.txt注意大小写和s不然识别不成功</p>
</blockquote>

<p><a href="https://cmake.org/cmake/help/latest/">Cmake说明文档</a></p>

<p><a href="https://www.elecfans.com/d/2186049.html">cmake是什么？cmake的特性和编译原理（cmake原理和cmake编译过程）</a></p>

<p><a href="https://blog.csdn.net/weixin_43717839/article/details/128032486?spm=1001.2101.3001.6650.14&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-14-128032486-blog-113787870.235%5Ev43%5Epc_blog_bottom_relevance_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-14-128032486-blog-113787870.235%5Ev43%5Epc_blog_bottom_relevance_base3&amp;utm_relevant_index=22">【C++】Cmake使用教程（看这一篇就够了）-CSDN博客</a></p>

<blockquote>
  <p>不是已经有了makefile去实现编译控制，为什么还需要Cmake?</p>

  <p>Maybe:控制编译的对象范围不同？</p>

  <p>Answer:Cmake为了方便的自动生成可以跨平台的makefile，直接写makefile可以实现但是复杂。<strong><em>最重要的，Makefile不像人读的</em></strong>。</p>
</blockquote>

<h2 id="二-cmake的常用语法">二、 Cmake的常用语法</h2>

<p>一般的，Cmake的编写分为几个部分：初始化、</p>

<h3 id="1-初始化">1. 初始化：</h3>

<p>添加cmake版本要求, 添加project名称和版本号</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span> <span class="p">(</span>VERSION 2.8<span class="p">)</span>
<span class="nb">project</span> <span class="p">(</span>project_name VERSION 1.0<span class="p">)</span>
</code></pre></div></div>

<h3 id="2-设置头文件路径">2. 设置头文件路径：</h3>

<p>指定头文件搜索路径：</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">include_directories</span> <span class="p">(</span>test_func test_func1<span class="p">)</span>
</code></pre></div></div>

<h3 id="3-添加编译选项">3. 添加编译选项：</h3>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_compile_options</span><span class="p">(</span>-std=c++11 -Wall<span class="p">)</span> 
</code></pre></div></div>

<p>或者使用set设置变量<code class="language-plaintext highlighter-rouge">CMAKE_CXX_FLAGS</code>或<code class="language-plaintext highlighter-rouge">CMAKE_C_FLAGS</code></p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span><span class="p">(</span>CMAKE_CXX_FLAGS <span class="s2">"-Wall"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="4-编译可执行文件">4. 编译可执行文件：</h3>

<h4 id="41-直接编译c文件"><em>4.1 直接编译.c文件</em></h4>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_executable</span><span class="p">(</span>main main.c testFunc.c<span class="p">)</span>
</code></pre></div></div>

<h4 id="42-将目录中的所有源文件存在变量中"><em>4.2 将目录中的所有源文件存在变量中</em></h4>

<blockquote>
  <p>一般的，Cmake中变量名称使用大写字符表示，<code class="language-plaintext highlighter-rouge">${VAR}</code>取出变量的值</p>
</blockquote>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">aux_source_directory</span><span class="p">(</span>. SRC_LIST<span class="p">)</span>
<span class="nb">add_executable</span><span class="p">(</span>main <span class="si">${</span><span class="nv">SRC_LIST</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="43-设置二进制文件的输出位置"><em>4.3 设置二进制文件的输出位置：</em></h4>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span> <span class="p">(</span>EXECUTABLE_OUTPUT_PATH <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/bin<span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>还可以使用<code class="language-plaintext highlighter-rouge">SET_TARGET_PROPERTIES</code>设置单个编译对象的输出路径，路径更精细。设置输出路径的颗粒度可以精细到每个编译的对象</p>
</blockquote>

<h3 id="5-编译库文件">5. 编译库文件：</h3>

<h4 id="51-编译源代码归档成动态库shared或静态库static"><em>5.1 编译源代码归档成动态库（SHARED）或静态库(STATIC)</em></h4>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_library</span> <span class="p">(</span>libname SHARED <span class="si">${</span><span class="nv">SRC_LIST</span><span class="si">}</span><span class="p">)</span>
<span class="nb">add_library</span> <span class="p">(</span>libname STATIC <span class="si">${</span><span class="nv">SRC_LIST</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="52-设置最终生成的库的名字"><em>5.2 设置最终生成的库的名字</em></h4>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set_target_properties</span> <span class="p">(</span>libname PROPERTIES OUTPUT_NAME <span class="s2">"libname "</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="53-设置库的输出路径"><em>5.3 设置库的输出路径</em></h4>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span> <span class="p">(</span>LIBRARY_OUTPUT_PATH <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/lib<span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>同样可以使用<code class="language-plaintext highlighter-rouge">SET_TARGET_PROPERTIES</code>设置输出路径</p>
</blockquote>

<h3 id="6-链接库">6. 链接库：</h3>

<h4 id="61-在路径下查找库并把绝对路径存放在变量中"><em>6.1 在路径下查找库并把绝对路径存放在变量中</em></h4>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">find_library</span><span class="p">(</span>LIB_PATH libname HINTS <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/lib<span class="p">)</span>
</code></pre></div></div>

<h4 id="62-链接目标文件和库文件"><em>6.2 链接目标文件和库文件</em></h4>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">target_link_libraries</span> <span class="p">(</span>target_file <span class="si">${</span><span class="nv">LIB_PATH</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="7-添加编译子目录可选">7. 添加编译子目录（可选）：</h3>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_subdirectory</span><span class="p">(</span>source_dir [binary_dir] [EXCLUDE_FROM_ALL]<span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>
    <p><strong>source_dir 源代码目录</strong>
指定一个具有cmakelist和源代码的目录，将其作为编译的子目录</p>
  </li>
  <li>
    <p><strong>binary_dir 二进制代码目录</strong>
指定cmake输出的二进制文件所在的目录</p>
  </li>
  <li>
    <p><strong>EXCLUDE_FROM_ALL标记</strong>
指定将添加的子目录从make all 中移除</p>
  </li>
</ul>

<blockquote>
  <p>添加编译子目录是为了让源码的编译结构更加清晰，可以更好的使用选项管理编译过程。新的目录路径下建立一个新的CMakeLists。</p>
</blockquote>

<h3 id="8-安装规则可选">8. 安装规则（可选）：</h3>

<p>在编译完成之后，可以使用以下命令将编译好的源文件、头文件、测试用例等资源安装到Cmake指定的位置。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nb">install</span>
</code></pre></div></div>

<h4 id="81-安装动态库"><em>8.1 安装动态库</em></h4>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">install</span><span class="p">(</span>TARGETS mylib
    LIBRARY DESTINATION lib
<span class="p">)</span>
</code></pre></div></div>

<h4 id="82-安装可执行文件"><em>8.2 安装可执行文件</em></h4>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">install</span><span class="p">(</span>TARGETS test_mylib
    RUNTIME DESTINATION bin
<span class="p">)</span>
</code></pre></div></div>

<h4 id="83-安装头文件"><em>8.3 安装头文件</em></h4>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">install</span><span class="p">(</span>FILES myheader.h
    DESTINATION include
<span class="p">)</span>
</code></pre></div></div>

<h3 id="9-测试可选">9. 测试（可选）</h3>

<p>CMake 提供了内建的测试功能，可以帮助开发者验证项目是否正确构建以及是否通过了各种测试。CMake 的测试功能依赖于 CTest，这是一个 CMake 的测试驱动工具，通常用于执行项目中的单元测试、集成测试等。以下是关于 CMake 测试的主要概念和使用方法。</p>

<h4 id="91-启用测试"><em>9.1 启用测试</em></h4>

<p>要启用 CMake 测试功能，首先需要在 CMakeLists.txt 文件中调用 enable_testing()。这将启用 ctest 测试命令。一旦启用测试，您就可以通过 add_test() 命令定义具体的测试。</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">enable_testing</span><span class="p">()</span>
</code></pre></div></div>

<h4 id="92-添加测试"><em>9.2 添加测试</em></h4>

<p>使用 add_test() 命令来定义测试。该命令接受两个参数：测试名称和要执行的命令。</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_test</span><span class="p">(</span>NAME MyTest COMMAND MyExecutable<span class="p">)</span>
</code></pre></div></div>

<p>这个命令将会添加一个名为 MyTest 的测试，它会运行 MyExecutable 可执行文件。如果 MyExecutable 执行成功，测试将通过。</p>

<h4 id="93-测试命令的参数"><em>9.3 测试命令的参数</em></h4>

<p>在 add_test() 命令中，您可以传递多个参数，供测试命令使用。例如，如果您的程序需要一些命令行参数，您可以这样做：</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_test</span><span class="p">(</span>NAME TestWithArguments COMMAND MyExecutable arg1 arg2<span class="p">)</span>
</code></pre></div></div>

<p>这样在运行测试时，MyExecutable 将以 arg1 和 arg2 作为参数执行。</p>

<h4 id="94-测试期望的返回值"><em>9.4 测试期望的返回值</em></h4>

<p>默认情况下，CMake 假定测试程序成功执行时返回 0，如果返回非 0 值，则认为测试失败。如果您的测试需要特定的返回值来表示成功，可以使用 add_test() 的第三个参数指定期望的返回值：</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_test</span><span class="p">(</span>NAME TestWithExpectedReturnValue COMMAND MyExecutable<span class="p">)</span>
<span class="nb">set_tests_properties</span><span class="p">(</span>TestWithExpectedReturnValue PROPERTIES WILL_FAIL TRUE<span class="p">)</span>
</code></pre></div></div>

<h4 id="95-测试输出"><em>9.5 测试输出</em></h4>

<p>CTest 会捕获测试的标准输出（stdout）和标准错误（stderr）。如果您希望在测试中检查输出内容，可以使用 add_test() 的 –output-on-failure 标志来显示失败的输出。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctest <span class="nt">--output-on-failure</span>
</code></pre></div></div>

<p>这样，如果测试失败，你将看到每个失败测试的详细输出。</p>

<h4 id="96-测试属性"><em>9.6 测试属性</em></h4>

<p>使用 set_tests_properties() 可以设置测试的额外属性。例如，您可以将某个测试标记为“预期失败”（WILL_FAIL），或者设置测试的超时时间（TIMEOUT）等。</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set_tests_properties</span><span class="p">(</span>MyTest PROPERTIES TIMEOUT 30<span class="p">)</span>
<span class="nb">set_tests_properties</span><span class="p">(</span>MyTest PROPERTIES WILL_FAIL TRUE<span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>TIMEOUT：指定测试的超时时间（以秒为单位）。如果测试在此时间内没有结束，将被视为失败。</li>
  <li>WILL_FAIL：标记该测试为预期失败。</li>
</ul>

<h3 id="10cmake其他操作">10.Cmake其他操作</h3>

<h4 id="101-文件操作file"><em>10.1 文件操作file</em></h4>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file MAKE_DIRECTORY path/to/directory<span class="p">)</span>
</code></pre></div></div>

<h4 id="102-判断语句-if"><em>10.2 判断语句 if</em></h4>

<h4 id="103-循环语句-foreach"><em>10.3 循环语句 foreach</em></h4>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">foreach</span><span class="p">(</span>ITEM <span class="si">${</span><span class="nv">LIST</span><span class="si">}</span><span class="p">)</span>
    dosomething
<span class="nb">endforeach</span><span class="p">()</span>
</code></pre></div></div>

<h4 id="104-设置目标属性-set_target_properties"><em>10.4 设置目标属性 SET_TARGET_PROPERTIES</em></h4>

<p><code class="language-plaintext highlighter-rouge">SET_TARGET_PROPERTIES</code>是 CMake 中的一个重要指令，用于设置目标（target）的各种属性，这里的目标可以是库（静态库、动态库），也可以是可执行文件。其基本语法如下：</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">SET_TARGET_PROPERTIES</span><span class="p">(</span>target1 target2... PROPERTIES
    property1 value1
    property2 value2
   ...
<span class="p">)</span>
</code></pre></div></div>

<p>常见属性及用途：</p>

<ol>
  <li>
    <p>ARCHIVE_OUTPUT_DIRECTORY：
设置静态库的输出目录。例如：</p>

    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">SET_TARGET_PROPERTIES</span><span class="p">(</span>mylib PROPERTIES
ARCHIVE_OUTPUT_DIRECTORY <span class="si">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="si">}</span>/lib
<span class="p">)</span>
</code></pre></div>    </div>

    <p>这会将名为 mylib 的静态库输出到<code class="language-plaintext highlighter-rouge">${CMAKE_BINARY_DIR}/lib</code>目录下。</p>
  </li>
  <li>
    <p>LIBRARY_OUTPUT_DIRECTORY：
用于指定动态库的输出目录，用法和静态库类似：</p>

    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">SET_TARGET_PROPERTIES</span><span class="p">(</span>mylib PROPERTIES
LIBRARY_OUTPUT_DIRECTORY <span class="si">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="si">}</span>/lib
<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>RUNTIME_OUTPUT_DIRECTORY：
设定可执行文件的输出目录。比如：</p>

    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">SET_TARGET_PROPERTIES</span><span class="p">(</span>myapp PROPERTIES
RUNTIME_OUTPUT_DIRECTORY <span class="si">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="si">}</span>/bin
<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>POSITION_INDEPENDENT_CODE：
对于生成动态库或者希望被动态链接的目标很有用，设置为 ON 表示生成位置无关代码（PIC）。这是共享库编译时的常见需求，因为共享库需要能被加载到内存的不同位置，代码必须是位置无关的：</p>

    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">SET_TARGET_PROPERTIES</span><span class="p">(</span>mylib PROPERTIES
POSITION_INDEPENDENT_CODE ON
<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>INSTALL_RPATH：
正如前面提到的，和运行时库路径相关，用于设置安装后的可执行文件搜索动态库的路径。”$ORIGIN” 是一个常用值，表示可执行文件所在目录：</p>

    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">SET_TARGET_PROPERTIES</span><span class="p">(</span>test_mylib PROPERTIES
INSTALL_RPATH <span class="s2">"$ORIGIN"</span>
<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>INTERFACE_INCLUDE_DIRECTORIES：
在创建库时，用于指定库的使用者需要包含的头文件目录，方便其他项目链接该库时能正确找到头文件：</p>

    <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">SET_TARGET_PROPERTIES</span><span class="p">(</span>mylib PROPERTIES
INTERFACE_INCLUDE_DIRECTORIES <span class="si">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="si">}</span>/include
<span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="三cmake使用">三、Cmake使用</h2>

<p>使用cmakelist宏变量和make的命令选项显示make的详细内容</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake <span class="nt">-DCMAKE_VERBOSE_MAKEFILE</span><span class="o">=</span>ON ..
make <span class="nv">VERBOSE</span><span class="o">=</span>1
</code></pre></div></div>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="笔记" /><category term="Cmake" /></entry><entry><title type="html">锐华嵌入式操作系统</title><link href="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E9%94%90%E5%8D%8E%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="alternate" type="text/html" title="锐华嵌入式操作系统" /><published>2024-10-30T00:00:00+00:00</published><updated>2024-10-30T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E9%94%90%E5%8D%8E%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F</id><content type="html" xml:base="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E9%94%90%E5%8D%8E%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><![CDATA[<h1 id="锐华嵌入式操作系统">锐华嵌入式操作系统</h1>

<h1 id="ch-1rede">CH 1—ReDE</h1>

<h2 id="一-rede介绍">一、 ReDE介绍</h2>

<p>ReDe是基于Eclipse开发的集成嵌入式系统开发平台。构建和项目管理依赖于GCC交叉编译工具链和make工具（但会操作简单点，自动生成Makefile）</p>

<h2 id="二rede使用">二、ReDe使用</h2>

<h3 id="1-建立工程">1. 建立工程</h3>

<p>Reworks的项目是建立在一个拥有系统镜像的自引导工程之上的。</p>

<p>一般的，在项目文件中建立一个自引导工程和多个可下载工程和库工程。通过自引导工程引用别的工程的内容，将所有的文件写入elf的系统镜像之中。</p>

<p>也可以在运行好的Reworks系统上通过库工程L和可下载工程D动态的加卸载.o和.a文件。</p>

<ol>
  <li>
    <p><strong>自引导工程B：</strong> 生成可以直接在目标机上运行的目标代码。编译生成.bin和.elf文件。</p>
  </li>
  <li>
    <p><strong>库工程L:</strong> 生成可以被其他库引用的库文件。编译生成.a文件。</p>
  </li>
  <li>
    <p><strong>可下载工程D:</strong> 生成可以下载到目标机运行的文件。编译生成.o和.out文件。</p>
  </li>
  <li>
    <p><strong>BSP工程:</strong> 该工程提供了BSP工程建立、代码模板自动导入、BSP库构建与ReWorks自引导工程一体化调试、BSP资源组建配置与发布等功能。</p>
  </li>
  <li>
    <p><strong>自定义工程：</strong> 允许用户自定义包括makefile的工程。</p>
  </li>
  <li>
    <p><strong>资源组件工程：</strong> 对工程的一系列属性进行了配置。<u>可在自引导工程、库工程、可下载工程的资源配置模块中应用。</u>（资源配置模块就是资源组件工程？是的）</p>
  </li>
  <li>
    <p><strong>目标板资源工程</strong>：定义在目标系统上运行所需的最低资源集合</p>
  </li>
</ol>

<h3 id="2-配置系统资源">2. 配置系统资源</h3>

<p>出于嵌入式系统的特性考虑（功耗、资源、性能、价格等…），需要对完整的系统根据需求进行定制裁剪。根据具体的调试和应用需要，各异的设置开发板上所需的系统资源。</p>

<p>ReDe中可以直接在.syscfg中勾选保存所需的功能。具体功能需要那些系统资源请看各自功能的文档。</p>

<p><strong>常用的资源配置：</strong></p>

<p>板级支持包–网卡驱动、控制台配置</p>

<p>开发和运行支持–运行时工具–任务调试支持</p>

<h3 id="3-构建工程">3. 构建工程</h3>

<p>对工程中的文件进行编译，自引导工程、库工程、可下载工程具有默认的构建配置（自动生成的makefile) 。可以在工程属性中管理自动生成的makefile和make指令。</p>

<p><strong>连接可下载/库工程到自引导工程（系统调试）：</strong></p>

<p>右键–属性–C++构建–设置–GCC C++ linker–杂项–附加对象文件–选择</p>

<p><strong>为项目添加依赖（先构建依赖）：</strong></p>

<p>右键–属性–项目引用–选择</p>

<p><strong>为make all 添加选项：</strong></p>

<p>右键–属性–C/C++构建–构建器设置–去除勾选使用默认构建命令–添加选项。</p>

<p>例如：<code class="language-plaintext highlighter-rouge">make -j10 all</code>开启多线程编译。</p>

<h3 id="4-连接目标板">4. 连接目标板</h3>

<p>ReDe和开发板的Uboot通过USB串口和RJ45以太网接口连接。串口用于和开发板直接沟通配置Uboot。以太网接口用于进行FTP通信。</p>

<p><em>此时还没有拷贝镜像！更没有启动系统！和系统资源配置没关系！只是在和U-Boot交互</em></p>

<p><strong>FTP方式下载系统镜像：</strong></p>

<blockquote>
  <p>注意：网卡需要设置的IP地址。这次用的192.168.1.110，取决于板上写入的服务器地址（uboot tftp配置的地址，可以更改）</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setenv ipaddr 192.168.1.1
setenv serverip 192.168.1.31
saveenv
</code></pre></div>  </div>

  <p><img src="/assets/images/blog/2024-08-09-11-17-41-image.png" alt="" /></p>

  <p>更改前本机的ip地址，软件平台室服务器。</p>
</blockquote>

<p><strong>USB串口设置</strong>：左上角选择终端打开设备管理器选择对应的COM号，设置端口速度为115200。（这是USB连接的线用来和uboot的引导程序命令行进行交互）运行过程中不断敲击回车键（保证能中断他的自动引导，其实一下好像就行）</p>

<p><strong>TFTP服务器设置</strong>：</p>

<p>右键存在需下载文件的项目目录–设置TFTP路径</p>

<p>或</p>

<p>打开窗口–显示视图–TFTP服务–启动TFTP 服务（依然是上次设置的路径）</p>

<h3 id="5-uboot启动系统镜像">5. Uboot启动系统镜像</h3>

<p><strong>在串口界面输入命令：</strong>
<code class="language-plaintext highlighter-rouge">tftpboot 0x80100000 reworks</code>
使用TFTP服务从服务器获得reworks.elf放到地址0x80100000</p>

<p><code class="language-plaintext highlighter-rouge">go 0x80100000</code>
从地址运行系统，进行uboot，启动reworks系统镜像</p>

<blockquote>
  <p>地址是根据不同开发板而不同的。</p>
</blockquote>

<h3 id="6-调试">6. 调试</h3>

<h4 id="61-系统调试本地调试">6.1 系统调试（本地调试）：</h4>

<p>.o文件跟随系统镜像写入开发板。参见在自引导工程中引用可下载工程的.o文件部分。直接烧入镜像进行测试。</p>

<blockquote>
  <p><strong>在自引导工程中引用可下载工程的.o文件：</strong></p>

  <p>右键属性–c++构建–设置–c++linker–杂项–附加对象文件–输入命令<code class="language-plaintext highlighter-rouge">“${workspace_loc:/projectName/gnuXXX/boardName/projectName.out}”</code></p>
</blockquote>

<h4 id="62-任务调试远程调试">6.2 任务调试（远程调试）：</h4>

<p>.o文件在系统启动以后在写入并加载。首先需要通过TFTP等方式拷贝系统镜像，使用Uboot启动系统。使用的是GNU GDB工具进行测试。</p>

<p><strong>0、系统资源配置：</strong></p>

<p>运行时工具–任务调试支持、协同总线组件、远程接卸载 和 板级支持包–网卡驱动</p>

<p><strong>1、运行系统镜像：</strong></p>

<p>勾选任务调试支持后系统会暂停于usrInit处。</p>

<p><strong>2、连接目标机：</strong></p>

<p>左下角目标机系统管理器，第一个图标：添加连接。</p>

<p>目标机名填写系统资源配置中网卡的IP(和TFTP中的IP并不一定相同)</p>

<blockquote>
  <p>U-boot和Reworks是两个不同的系统。U-boot是引导系统的系统。</p>

  <p>有bug，必须更改一次ip地址才可以使用！</p>
</blockquote>

<p><strong>3、调试配置：</strong></p>

<p>右键项目–调试–调试配置–自引导应用程序–程序</p>

<p>右键项目–调试–调试配置–自引导应用程序–目标机</p>

<p><strong>4、开始调试：</strong></p>

<p>等同于GNU GDB，略</p>

<h4 id="63-远程加卸载">6.3 远程加卸载：</h4>

<p>对非核心的.o文件在系统中动态的加载或者卸载。实质是把.out文件下载到 <code class="language-plaintext highlighter-rouge">/clb/dynamicModuleFolder/</code>路径下，然后运行<code class="language-plaintext highlighter-rouge">ld unld</code>指令,然后删除可执行文件。等价于TFTP获取文件+加载模块+删除文件。</p>

<p>与直接镜像link然后构建写入镜像不同。直接写入镜像的模块无法卸载，在<code class="language-plaintext highlighter-rouge">/clb/dynamicModuleFolder/</code>路径下没有.out文件</p>

<blockquote>
  <p>TFTP命令</p>

  <p><code class="language-plaintext highlighter-rouge">tftp ("ip", "path/remotefile", "get/put",“ascii/netascii/binary/image/octet”, "path/localfile")</code></p>

  <p>符号表命令</p>

  <p><strong>ld</strong> 加载.out/.o文件</p>

  <p><strong>unld</strong> 卸载已加载的.out/.o文件</p>

  <p><strong>unld_by_module_name</strong> 通过模块名称卸载已加载的.out/.o文件</p>

  <p><strong>unld_by_module_id</strong> 通过模块ID卸载已加载的.out/.o文件</p>

  <p><strong>reld</strong> 重新加载.out/.o文件</p>

  <p><strong>module_info</strong> 显示已加载的.out/.o文件</p>

  <p><strong>symbol_lkup</strong> 查找指定的符号信息</p>

  <p><strong>lkup</strong> 显示包括指定名称的所有符号信息</p>
</blockquote>

<p><strong>0、系统资源配置：</strong> 远程加卸载、符号表、网卡</p>

<p><strong>1、目标及启动系统：</strong> 略</p>

<p><strong>2、连接目标机：</strong> 略</p>

<p><strong>3、加卸载：</strong> 左上角加载–加载配置–设置目标机、动态加载</p>

<p><strong>4、符号表同步：</strong> 何意？</p>

<h4 id="64-仿真调试qumu">6.4 仿真调试：Qumu</h4>

<h1 id="ch-2系统命令行shell">CH 2—系统命令行Shell</h1>

<h2 id="一shell介绍">一、Shell介绍</h2>

<h2 id="11-reworks-shell命令">1.1 Reworks Shell命令</h2>

<p>i</p>

<p>oi</p>

<p>stackuse</p>

<p>cpuuse</p>

<h3 id="12-反汇编">1.2 反汇编</h3>

<p>在软件运行过程中只要有shell线程工作就可以使用pthread_show_stackframe命令获得任务运行的堆栈，再使用arrch64-objdump-elf -C -x -S可以查看反汇编的.elf源码，方便进行调试。</p>

<h4 id="任务堆栈">任务堆栈：</h4>

<p>pthread_show_stackframe</p>

<h4 id="objdump反汇编工具">objdump反汇编工具：</h4>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="笔记" /><category term="Reworks" /><category term="RTOS" /></entry><entry><title type="html">Zero mq</title><link href="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/Zero-MQ/" rel="alternate" type="text/html" title="Zero mq" /><published>2024-10-09T00:00:00+00:00</published><updated>2024-12-12T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/Zero%20MQ</id><content type="html" xml:base="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/Zero-MQ/"><![CDATA[<h1 id="zero-mq">Zero MQ</h1>

<hr />

<p><strong>We took a normal TCP socket, injected it with a mix of radioactive isotopes stolen from a secret Soviet atomic research project, bombarded it with 1950-era cosmic rays, and put it into the hands of a drug-addled comic book author with a badly-disguised fetish for bulging muscles clad in spandex.</strong>        </p>

<p>                                                                                                <strong><em>—-Pieter Hintjens, CEO of iMatix</em></strong></p>

<p>精简版：人们受够了套接字！他实在太混乱了！ZMQ就是这个混乱网络世界的救主。</p>

<p>                                                                                                —-笔者</p>

<hr />

<p> ZMQ是一个高性能的异步消息传递库，提供了一个无需消息代理的消息队列（MQ）。ZMQ通过多种传输方式（TCP, in-process, inter-process, multicast, WebSocket and more）实现了常见的消息传递模式（pub/sub, request/reply, client/server and others）从而使进程间消息传递变得与线程间消息传递一样简单。这样可以保持代码清晰、模块化，并且非常易于扩展。</p>

<p>本质上ZMQ和Redis、RabbitMQ、RocketMQ、Kafka这类的消息中间件并不相同。ZMQ更类似于一个对socket的封装，包含了网络层协议。因此他更快速也无需消息代理（message broker)。当然，这也意味着更底层更复杂（这就是力量的代价：MQ +4/+4，当发生底层错误时消灭程序员）。</p>

<p><a href="https://github.com/anjuke/zguide-cn?tab=readme-ov-file">中文zguide</a></p>

<h1 id="一-zmq模型">一、 ZMQ模型</h1>

<table>
  <tbody>
    <tr>
      <td>[1. Basics</td>
      <td>ØMQ - The Guide](https://zguide.zeromq.org/docs/chapter1/#Why-We-Needed-ZeroMQ)</td>
    </tr>
  </tbody>
</table>

<p><a href="https://blog.csdn.net/qq_41453285/article/details/105984928">一文带你入门了解“零之禅“消息队列ZeroMQ-CSDN博客</a></p>

<p><a href="https://dongshao.blog.csdn.net/article/details/106922554?ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1L2FydGljbGUvZGV0YWlscy8xMDU5ODQ5Mjg%3D">重头戏！ZeroMQ的管道模式详解：ZMQ_PUSH、ZMQ_PULL_zmq push pull-CSDN博客</a></p>

<h2 id="1-请求应答模型reqrep1v1">1 请求/应答模型(REQ/REP)–1v1</h2>

<h3 id="11-原理">1.1 原理</h3>

<p><img src="https://zguide.zeromq.org/images/fig2.png" title="" alt="" data-align="center" /></p>

<p>REQ-REP 套接字的步调一致。客户端循环发出zmq_send()，然后发出 zmq_recv()（如果仅此而已，则只发出一次）。执行任何其他顺序（例如，连续发送两条消息）将导致 send或recv调用返回 -1 代码。同样，服务会根据需要按顺序发出zmq_recv()，然后发出 zmq_send() 。</p>

<h3 id="12-服务器端">1.2 服务器端</h3>

<p>服务器创建一个响应类型的套接字（稍后您将了解有关请求-响应的更多信息），将其绑定到端口 5555，然后等待消息。您还可以看到我们没有任何配置，我们只是发送字符串。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  Hello World server</span>
<span class="cp">#include</span> <span class="cpf">&lt;zmq.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//  Socket to talk to clients</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">zmq_ctx_new</span> <span class="p">();</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">responder</span> <span class="o">=</span> <span class="n">zmq_socket</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ZMQ_REP</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">zmq_bind</span> <span class="p">(</span><span class="n">responder</span><span class="p">,</span> <span class="s">"tcp://*:5555"</span><span class="p">);</span>
    <span class="n">assert</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">buffer</span> <span class="p">[</span><span class="mi">10</span><span class="p">];</span>
        <span class="n">zmq_recv</span> <span class="p">(</span><span class="n">responder</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"Received Hello</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">sleep</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>          <span class="c1">//  Do some 'work'</span>
        <span class="n">zmq_send</span> <span class="p">(</span><span class="n">responder</span><span class="p">,</span> <span class="s">"World"</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="13-客户端">1.3 客户端</h3>

<p>客户端创建一个请求类型的套接字，连接并开始发送消息。<code class="language-plaintext highlighter-rouge">send</code>和方法<code class="language-plaintext highlighter-rouge">receive</code>都是阻塞的（默认情况下）。对于接收来说很简单：如果没有消息，该方法将阻塞。对于发送来说，它更复杂，并且取决于套接字类型。对于请求套接字，如果达到高水位或没有连接对等点，该方法将阻塞。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  Hello World client</span>
<span class="cp">#include</span> <span class="cpf">&lt;zmq.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">"Connecting to hello world server…</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">zmq_ctx_new</span> <span class="p">();</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">requester</span> <span class="o">=</span> <span class="n">zmq_socket</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ZMQ_REQ</span><span class="p">);</span>
    <span class="n">zmq_connect</span> <span class="p">(</span><span class="n">requester</span><span class="p">,</span> <span class="s">"tcp://localhost:5555"</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">request_nbr</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">request_nbr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">request_nbr</span> <span class="o">!=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">request_nbr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">buffer</span> <span class="p">[</span><span class="mi">10</span><span class="p">];</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"Sending Hello %d…</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">request_nbr</span><span class="p">);</span>
        <span class="n">zmq_send</span> <span class="p">(</span><span class="n">requester</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">zmq_recv</span> <span class="p">(</span><span class="n">requester</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"Received World %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">request_nbr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">zmq_close</span> <span class="p">(</span><span class="n">requester</span><span class="p">);</span>
    <span class="n">zmq_ctx_destroy</span> <span class="p">(</span><span class="n">context</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="注意字符串安全性">#注意:字符串安全性#</h3>

<blockquote>
  <p>C语言中的字符串并不安全！</p>

  <p>zmq_send只关注会发送的字符的数量，这意味着它是可以发送带有空字节的字符串的。这会导致不正确的字符串格式—没有安全的终止。如果接收方的buffer中剩余的位置不是空字符（尽管大部分情况下是这样），将会导致字符串读写的错误</p>

  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">zmq_send</span> <span class="p">(</span><span class="n">requester</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>  </div>

  <p>一般默认的我们认为zmq_send使用的<strong>字符串的长度是不带终止符的长度，也就是strlen得到的长度</strong>。也就是说，<strong>网络中传输的字符串不是C语言中的字符串</strong>，需要额外的格式化处理。</p>

  <p>我们选择在接收端对接收的字符进行处理。在实际的使用之中，有两种方法：1.每次memset接收缓存为0；2.需要对接收缓存的字符串多读一位然后使用空字符截取，好消息是我们从0开始，所以recv的返回值就是那个多一位，该赋值为空字符的位置。两种方法的思路其实是一样的，<strong>为recv到的网络字符添加空字符结尾，使他结束在应该有的位置</strong>。</p>

  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  Receive ZeroMQ string from socket and convert into C string</span>
<span class="c1">//  Chops string at 255 chars, if it's longer</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">s_recv</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">socket</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span> <span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">zmq_recv</span> <span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
    <span class="n">buffer</span> <span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="cm">/* use strndup(buffer, sizeof(buffer)-1) in *nix */</span>
    <span class="k">return</span> <span class="n">strdup</span> <span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>  </div>

  <p>可以使用<code class="language-plaintext highlighter-rouge">zhelpers.h</code>头文件对c语言进行安全的收发。<a href="https://github.com/booksbyus/zguide/blob/master/examples/C/zhelpers.h">点击此处</a>查看具体源码。</p>

  <p>ps. 不正确的使用send，在router中会导致身份识别的错误<strong>请务必注意</strong>！</p>
</blockquote>

<h2 id="2--发布订阅模型pubsub1vn">2  发布/订阅模型(PUB/SUB)–1vN</h2>

<h3 id="21-原理">2.1 原理</h3>

<p><img title="" src="https://zguide.zeromq.org/images/fig4.png" alt="" data-align="center" /></p>

<p>单向数据分发即服务器将更新流推送到一组客户端。这股更新流可以理解为无始无终永不结束的广播。</p>

<h3 id="22-发布者生产者">2.2 发布者（生产者）</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  Weather update server</span>
<span class="c1">//  Binds PUB socket to tcp://*:5556</span>
<span class="c1">//  Publishes random weather updates</span>

<span class="cp">#include</span> <span class="cpf">"zhelpers.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//  Prepare our context and publisher</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">zmq_ctx_new</span> <span class="p">();</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">publisher</span> <span class="o">=</span> <span class="n">zmq_socket</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ZMQ_PUB</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">zmq_bind</span> <span class="p">(</span><span class="n">publisher</span><span class="p">,</span> <span class="s">"tcp://*:5556"</span><span class="p">);</span>
    <span class="n">assert</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">//  Initialize random number generator</span>
    <span class="n">srandom</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">time</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//  Get values that will fool the boss</span>
        <span class="kt">int</span> <span class="n">zipcode</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">relhumidity</span><span class="p">;</span>
        <span class="n">zipcode</span>     <span class="o">=</span> <span class="n">randof</span> <span class="p">(</span><span class="mi">100000</span><span class="p">);</span>
        <span class="n">temperature</span> <span class="o">=</span> <span class="n">randof</span> <span class="p">(</span><span class="mi">215</span><span class="p">)</span> <span class="o">-</span> <span class="mi">80</span><span class="p">;</span>
        <span class="n">relhumidity</span> <span class="o">=</span> <span class="n">randof</span> <span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>

        <span class="c1">//  Send message to all subscribers</span>
        <span class="kt">char</span> <span class="n">update</span> <span class="p">[</span><span class="mi">20</span><span class="p">];</span>
        <span class="n">sprintf</span> <span class="p">(</span><span class="n">update</span><span class="p">,</span> <span class="s">"%05d %d %d"</span><span class="p">,</span> <span class="n">zipcode</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">relhumidity</span><span class="p">);</span>
        <span class="n">s_send</span> <span class="p">(</span><span class="n">publisher</span><span class="p">,</span> <span class="n">update</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">zmq_close</span> <span class="p">(</span><span class="n">publisher</span><span class="p">);</span>
    <span class="n">zmq_ctx_destroy</span> <span class="p">(</span><span class="n">context</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="23-订阅者消费者">2.3 订阅者（消费者）</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  Weather update client</span>
<span class="c1">//  Connects SUB socket to tcp://localhost:5556</span>
<span class="c1">//  Collects weather updates and finds avg temp in zipcode</span>

<span class="cp">#include</span> <span class="cpf">"zhelpers.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span> <span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">//  Socket to talk to server</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">"Collecting updates from weather server...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">zmq_ctx_new</span> <span class="p">();</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">subscriber</span> <span class="o">=</span> <span class="n">zmq_socket</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ZMQ_SUB</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">zmq_connect</span> <span class="p">(</span><span class="n">subscriber</span><span class="p">,</span> <span class="s">"tcp://localhost:5556"</span><span class="p">);</span>
    <span class="n">assert</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">//  Subscribe to zipcode, default is NYC, 10001</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filter</span> <span class="o">=</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span> <span class="n">argv</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">:</span> <span class="s">"10001 "</span><span class="p">;</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="n">zmq_setsockopt</span> <span class="p">(</span><span class="n">subscriber</span><span class="p">,</span> <span class="n">ZMQ_SUBSCRIBE</span><span class="p">,</span>
                         <span class="n">filter</span><span class="p">,</span> <span class="n">strlen</span> <span class="p">(</span><span class="n">filter</span><span class="p">));</span>
    <span class="n">assert</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">//  Process 100 updates</span>
    <span class="kt">int</span> <span class="n">update_nbr</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">total_temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">update_nbr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">update_nbr</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">update_nbr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="n">s_recv</span> <span class="p">(</span><span class="n">subscriber</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">zipcode</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">relhumidity</span><span class="p">;</span>
        <span class="n">sscanf</span> <span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="s">"%d %d %d"</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="n">zipcode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temperature</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">relhumidity</span><span class="p">);</span>
        <span class="n">total_temp</span> <span class="o">+=</span> <span class="n">temperature</span><span class="p">;</span>
        <span class="n">free</span> <span class="p">(</span><span class="n">string</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">"Average temperature for zipcode '%s' was %dF</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">filter</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">total_temp</span> <span class="o">/</span> <span class="n">update_nbr</span><span class="p">));</span>

    <span class="n">zmq_close</span> <span class="p">(</span><span class="n">subscriber</span><span class="p">);</span>
    <span class="n">zmq_ctx_destroy</span> <span class="p">(</span><span class="n">context</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>关键在于 <code class="language-plaintext highlighter-rouge">zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE,filter, strlen (filter)); </code>一步为subscriber设置订阅。PUB-SUB 套接字对是异步的。客户端循环执行zmq_recv()（如zmq_hello_world_client果仅此而已，则执行一次）。尝试向 SUB 套接字发送消息将导致错误。同样，服务会根据需要尽可能频繁地执行 zmq_send()，但不得在 PUB 套接字上执行zmq_recv() 。</p>

<p>理论上，对于 ZeroMQ 套接字，哪一端连接和哪一端绑定并不重要。然而，在实践中存在一些未记录的差异。一般的，在PUB端bind在SUB端connect。</p>

<blockquote>
  <p>在通常的套接字编程中，bind 和conect一般分别用于服务器端和客户端。bind用于服务器监听指定的地址和端口，connect用于客户端连接到指定地址的服务器。</p>

  <p>在ZMQ中,在那一段bind或connect并无影响（为什么？）但实际上还是有差异的（毕竟底层的套接字不同）</p>
</blockquote>

<h3 id="注意缓慢加入问题">#注意:缓慢加入问题#</h3>

<blockquote>
  <p>”缓慢加入“问题会导致SUB永远没办法接收到PUB发送的最开始的信息（建立连接需要时间，这段时间中PUB很可能已发出很多信息！）需要对发布者和订阅者的同步。</p>
</blockquote>

<h2 id="3-推拉模型pushpull1vnv1">3 推拉模型（PUSH/PULL)–1vNv1</h2>

<p><del>管道模式或者叫并行流水线(ventilator/worker/sink)</del></p>

<h3 id="31-原理">3.1 原理</h3>

<p><img src="https://zguide.zeromq.org/images/fig5.png" title="" alt="" data-align="center" /></p>

<p>可同时执行多项任务的发送者ventilator、一组处理任务的工作者worker、从工作进程收集结果的接收者sink。发送者将任务分配给工人并行的处理，工人将各自的成果交给接收者。实质上是push和pull两种套接字上的操作！!本质是单向的套接字接口。</p>

<h3 id="32-发送者">3.2 发送者</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  Task ventilator</span>
<span class="c1">//  Binds PUSH socket to tcp://localhost:5557</span>
<span class="c1">//  Sends batch of tasks to workers via that socket</span>

<span class="cp">#include</span> <span class="cpf">"zhelpers.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">zmq_ctx_new</span> <span class="p">();</span>

    <span class="c1">//  Socket to send messages on</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sender</span> <span class="o">=</span> <span class="n">zmq_socket</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ZMQ_PUSH</span><span class="p">);</span>
    <span class="n">zmq_bind</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="s">"tcp://*:5557"</span><span class="p">);</span>

    <span class="c1">//  Socket to send start of batch message on</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sink</span> <span class="o">=</span> <span class="n">zmq_socket</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ZMQ_PUSH</span><span class="p">);</span>
    <span class="n">zmq_connect</span> <span class="p">(</span><span class="n">sink</span><span class="p">,</span> <span class="s">"tcp://localhost:5558"</span><span class="p">);</span>

    <span class="n">printf</span> <span class="p">(</span><span class="s">"Press Enter when the workers are ready: "</span><span class="p">);</span>
    <span class="n">getchar</span> <span class="p">();</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">"Sending tasks to workers...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">//  The first message is "0" and signals start of batch</span>
    <span class="n">s_send</span> <span class="p">(</span><span class="n">sink</span><span class="p">,</span> <span class="s">"0"</span><span class="p">);</span>

    <span class="c1">//  Initialize random number generator</span>
    <span class="n">srandom</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">time</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>

    <span class="c1">//  Send 100 tasks</span>
    <span class="kt">int</span> <span class="n">task_nbr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">total_msec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">//  Total expected cost in msecs</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">task_nbr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">task_nbr</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">task_nbr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">workload</span><span class="p">;</span>
        <span class="c1">//  Random workload from 1 to 100msecs</span>
        <span class="n">workload</span> <span class="o">=</span> <span class="n">randof</span> <span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">total_msec</span> <span class="o">+=</span> <span class="n">workload</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">string</span> <span class="p">[</span><span class="mi">10</span><span class="p">];</span>
        <span class="n">sprintf</span> <span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="n">workload</span><span class="p">);</span>
        <span class="n">s_send</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">"Total expected cost: %d msec</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">total_msec</span><span class="p">);</span>

    <span class="n">zmq_close</span> <span class="p">(</span><span class="n">sink</span><span class="p">);</span>
    <span class="n">zmq_close</span> <span class="p">(</span><span class="n">sender</span><span class="p">);</span>
    <span class="n">zmq_ctx_destroy</span> <span class="p">(</span><span class="n">context</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当工作者准备好时，发送者发送一个开始标志给sink让其准备好接收工人的成果。这么做的原因是和发布订阅模型一样可能存在丢失的信息，所以必须的先让接收者做好接收的准备，再让其得到工作者发出的信息。</p>

<h3 id="33-工作者">3.3 工作者</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  Task worker</span>
<span class="c1">//  Connects PULL socket to tcp://localhost:5557</span>
<span class="c1">//  Collects workloads from ventilator via that socket</span>
<span class="c1">//  Connects PUSH socket to tcp://localhost:5558</span>
<span class="c1">//  Sends results to sink via that socket</span>

<span class="cp">#include</span> <span class="cpf">"zhelpers.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="c1">//  Socket to receive messages on</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">zmq_ctx_new</span> <span class="p">();</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">receiver</span> <span class="o">=</span> <span class="n">zmq_socket</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ZMQ_PULL</span><span class="p">);</span>
    <span class="n">zmq_connect</span> <span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="s">"tcp://localhost:5557"</span><span class="p">);</span>

    <span class="c1">//  Socket to send messages to</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sender</span> <span class="o">=</span> <span class="n">zmq_socket</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ZMQ_PUSH</span><span class="p">);</span>
    <span class="n">zmq_connect</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="s">"tcp://localhost:5558"</span><span class="p">);</span>

    <span class="c1">//  Process tasks forever</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="n">s_recv</span> <span class="p">(</span><span class="n">receiver</span><span class="p">);</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"%s."</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>     <span class="c1">//  Show progress</span>
        <span class="n">fflush</span> <span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
        <span class="n">s_sleep</span> <span class="p">(</span><span class="n">atoi</span> <span class="p">(</span><span class="n">string</span><span class="p">));</span>    <span class="c1">//  Do the work</span>
        <span class="n">free</span> <span class="p">(</span><span class="n">string</span><span class="p">);</span>
        <span class="n">s_send</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>        <span class="c1">//  Send results to sink</span>
    <span class="p">}</span>
    <span class="n">zmq_close</span> <span class="p">(</span><span class="n">receiver</span><span class="p">);</span>
    <span class="n">zmq_close</span> <span class="p">(</span><span class="n">sender</span><span class="p">);</span>
    <span class="n">zmq_ctx_destroy</span> <span class="p">(</span><span class="n">context</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>工作者得到发送者的任务后停止一段时间然后发出成果给接收者。但这里隐含一个需求——所有的工作者需要同步的开始工作。也就是说我们需要额外的操作实现同步的并行处理。</p>

<p>同时，发送者需要均匀的为每一位工作者分配任务，称为<u>**负载均衡**</u>。</p>

<h3 id="34-接收者">3.4 接收者</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  Task sink</span>
<span class="c1">//  Binds PULL socket to tcp://localhost:5558</span>
<span class="c1">//  Collects results from workers via that socket</span>

<span class="cp">#include</span> <span class="cpf">"zhelpers.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="c1">//  Prepare our context and socket</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">zmq_ctx_new</span> <span class="p">();</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">receiver</span> <span class="o">=</span> <span class="n">zmq_socket</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ZMQ_PULL</span><span class="p">);</span>
    <span class="n">zmq_bind</span> <span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="s">"tcp://*:5558"</span><span class="p">);</span>

    <span class="c1">//  Wait for start of batch</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="n">s_recv</span> <span class="p">(</span><span class="n">receiver</span><span class="p">);</span>
    <span class="n">free</span> <span class="p">(</span><span class="n">string</span><span class="p">);</span>

    <span class="c1">//  Start our clock now</span>
    <span class="kt">int64_t</span> <span class="n">start_time</span> <span class="o">=</span> <span class="n">s_clock</span> <span class="p">();</span>

    <span class="c1">//  Process 100 confirmations</span>
    <span class="kt">int</span> <span class="n">task_nbr</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">task_nbr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">task_nbr</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">task_nbr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="n">s_recv</span> <span class="p">(</span><span class="n">receiver</span><span class="p">);</span>
        <span class="n">free</span> <span class="p">(</span><span class="n">string</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">task_nbr</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">printf</span> <span class="p">(</span><span class="s">":"</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">printf</span> <span class="p">(</span><span class="s">"."</span><span class="p">);</span>
        <span class="n">fflush</span> <span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//  Calculate and report duration of batch</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">"Total elapsed time: %d msec</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> 
        <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">s_clock</span> <span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">));</span>

    <span class="n">zmq_close</span> <span class="p">(</span><span class="n">receiver</span><span class="p">);</span>
    <span class="n">zmq_ctx_destroy</span> <span class="p">(</span><span class="n">context</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="o">**</span>
</code></pre></div></div>

<p>接收者需要均匀的从工作者处接收成果，也就是<u>**公平排队**</u>的接收机制。</p>

<h3 id="35-负载均衡和公平排队">3.5  负载均衡和公平排队</h3>

<p><img title="" src="https://zguide.zeromq.org/images/fig6.png" alt="" data-align="center" /></p>

<h3 id="注意不完全的负载均衡">注意:不完全的负载均衡#</h3>

<blockquote>
  <p>和发布/订阅模型一样，流水线模式也有着很严重的同步问题需要研究。</p>

  <p>PUSH 套接字无法正确实现负载平衡。如果您同时使用 PUSH 和 PULL，并且您的一个工作进程收到的消息比其他工作进程多得多，这是因为该 PULL 套接字比其他工作进程加入得更快，并且在其他工作进程设法连接之前就获取了大量消息。</p>

  <p>如果您想要正确的负载平衡，您可能需要查看 <a href="https://zguide.zeromq.org/docs/chapter3/#advanced-request-reply">第 3 章 - 高级请求-回复模式</a>中的负载平衡模式。</p>
</blockquote>

<h2 id="4-独占套接字对exclusive-pair线程间通信">4 独占套接字对（Exclusive pair)–线程间通信</h2>

<p>—-todo:</p>

<h2 id="5-路由模式routerdealernvn">5 路由模式（Router/Dealer)–NvN</h2>

<p>Router/Dealer模式是异步版的的REQ/REP模式。在实际的高访问量高并发性应用当中，往往有者多个服务器共同完成请求任务，甚至承载着不同的任务（微服务？）。此时可以通过一个消息中间人（message broker）（类似于Nginx的反向代理服务器？作用于不同的层次）实现请求应答。</p>

<p>router实际上在使用中更多的起到的是消息中间人的效果！</p>

<p><a href="https://www.cnblogs.com/fengbohello/p/4743868.html">zeromq中两个dealer 通过一个router进行通信 - fengbohello - 博客园</a></p>

<h2 id="6-有代理的发布订阅模型xpubxsub">6 有代理的发布/订阅模型（XPUB/XSUB）</h2>

<p>—-todo:</p>

<h1 id="二zmq套接字机制">二、ZMQ套接字机制</h1>

<h2 id="1-zmq上下文的创建和销毁">1 ZMQ上下文的创建和销毁：</h2>

<p>在ＺＭＱ中，使用ZMQ上下文管理所有的套接字。ZMQ使用一个称为上下文的结构体管理套接字——一个<code class="language-plaintext highlighter-rouge">zmq::ctx_t</code>类型的结构体,用于管理单个进程的所有套接字。一般的我们在一个进程开始时使用<code class="language-plaintext highlighter-rouge">zmq_ctx_new()</code>去创建上下文，在进程结束时使用<code class="language-plaintext highlighter-rouge">zmq_ctx_term() / zmq_ctx_destroy()</code>去销毁上下文,释放所有资源。如果使用fork，则是在fork之后和子线程的开头创建上下文。一般来说在子线程进行具体的zmq操作，在父线程进行线程管理。</p>

<blockquote>
  <p>在之前的zmq版本中使用的是<code class="language-plaintext highlighter-rouge">zmq_init()</code>和<code class="language-plaintext highlighter-rouge">zmq_term()</code>去创建和销毁上下文。但这样并没有表现出zmq上下文的作用，为了强调这是上下文的创建和销毁而修改了接口。更主要的，这为了提示你还需要释放zmq_msg结构体和套接字才能实现完整的释放，不导致资源泄露。换句话说，实际上ZMQ就是ZMQ上下文。</p>
</blockquote>

<p>在ZMQ当中，一个完整的资源释放过程被分为了三个部分：释放<code class="language-plaintext highlighter-rouge">zmq_msg_t</code>、释放套接字、释放zmq_ctx_t。</p>

<ol>
  <li>
    <p><strong>释放zmq_msg_t：</strong> 在使用时尽量使用<code class="language-plaintext highlighter-rouge">zmq_send()</code>和<code class="language-plaintext highlighter-rouge">zmq_recv()</code>，而不是<code class="language-plaintext highlighter-rouge">zmq_msg_send()</code>和<code class="language-plaintext highlighter-rouge">zmq_msg_recv()</code>。通过这种方法来避免<code class="language-plaintext highlighter-rouge">zmq_msg_t</code>结构体的使用。如果非要使用的话，需要在每次使用之后立刻调用<code class="language-plaintext highlighter-rouge">zmq_msg_close()</code>来关闭消息结构体，避免内存泄漏。</p>
  </li>
  <li>
    <p><strong>释放套接字：</strong> 在连接的套接字使用完毕后，需要及时的使用<code class="language-plaintext highlighter-rouge">zmq_close()</code>关闭套接字，因为上下文的释放仅能在其拥有的所有套接字都释放完毕后进行。此时需要为未关闭的套接字设置一个较小的LINGER值（等待时间，比如1s），然后关闭所有的套接字。</p>
  </li>
  <li>
    <p><strong>释放zmq_ctx_t：</strong><code class="language-plaintext highlighter-rouge">zmq_ctx_destroy()</code>的过程是一个复杂而痛苦的过程，因为上下文释放时可能仍有着悬挂的连接和进行的发送，也就是上下文对应的套接字没有完全释放。此时<code class="language-plaintext highlighter-rouge">zmq_ctx_destroy()</code>会一直被挂起。</p>

    <blockquote>
      <p>释放zmq上下文的<code class="language-plaintext highlighter-rouge">zmq_ctx_term()</code>的流程是：</p>

      <ul>
        <li>
          <p>任何当前在“context”内打开的套接字上正在进行的阻塞操作应立即以错误代码 <code class="language-plaintext highlighter-rouge">ETERM</code> 返回。除了<code class="language-plaintext highlighter-rouge">zmq_close()</code>之外，在“context”内打开的套接字上的任何进一步操作都应因错误代码 <code class="language-plaintext highlighter-rouge">ETERM</code> 而失败。</p>
        </li>
        <li>
          <p>中断所有阻塞调用后，<code class="language-plaintext highlighter-rouge">zmq_ctx_term()</code>应阻塞，直到：</p>

          <ul>
            <li>
              <p>所有在“context”内打开的套接字都已使用<code class="language-plaintext highlighter-rouge">zmq_close()</code>关闭</p>
            </li>
            <li>
              <p><code class="language-plaintext highlighter-rouge">zmq_send()</code>发送的所有消息要么已实际传输到网络对等方，要么套接字的延迟时间已过期（由ZMQ_LINGER套接字选项设置）。</p>
            </li>
          </ul>
        </li>
      </ul>
    </blockquote>
  </li>
</ol>

<h2 id="2-ｚｍｑ上下文对于套接字的管理">2 ＺＭＱ上下文对于套接字的管理：</h2>

<p>ZMQ上下文对于套接字的管理主要包括：</p>

<ul>
  <li>
    <p>创建和销毁套接字，它们共同构成套接字生命的循环（参见<a href="http://api.zeromq.org/master:zmq_socket">zmq_socket()</a>、<a href="http://api.zeromq.org/master:zmq_close">zmq_close()</a>）。</p>
  </li>
  <li>
    <p>通过设置选项并在必要时检查它们来配置套接字（参见<a href="http://api.zeromq.org/master:zmq_setsockopt">zmq_setsockopt()</a>、<a href="http://api.zeromq.org/master:zmq_getsockopt">zmq_getsockopt()</a>）。</p>
  </li>
  <li>
    <p>通过创建 ZeroMQ 连接将套接字插入网络拓扑（参见<a href="http://api.zeromq.org/master:zmq_bind">zmq_bind()</a>、<a href="http://api.zeromq.org/master:zmq_connect">zmq_connect()</a>）。</p>
  </li>
  <li>
    <p>通过在套接字上写入和接收消息来使用套接字传输数据（参见<a href="http://api.zeromq.org/master:zmq_msg_send">zmq_msg_send()</a>、<a href="http://api.zeromq.org/master:zmq_msg_recv">zmq_msg_recv()</a>）。</p>
  </li>
</ul>

<h3 id="21-zmq套接字的创建">2.1 ZMQ套接字的创建：</h3>

<p>—-todo:</p>

<h3 id="22-zmq-的套接字选项">2.2 ZMQ 的套接字选项：</h3>

<p>—-todo:</p>

<h3 id="23-zmq套接字绑定和连接">2.3 ZMQ套接字绑定和连接：</h3>

<p>ZMQ允许不严格的区分bind和connect，这使得其使用更加简单。但是正如之前在ZMQ模式中提到的，他们实际上有着微妙不同，但我们只需要按照标准的方法来使用它就可以避免。一般来说，执行<a href="http://api.zeromq.org/master:zmq_bind">zmq_bind()</a>的节点是<u>***“服务器”***</u>，位于<u>***众所周知的网络地址***</u>上，而执行<a href="http://api.zeromq.org/master:zmq_connect">zmq_connect()</a>的节点是<u>***“客户端”***</u>，具有<u>***未知或任意的网络地址***</u>。因此，我们说“将套接字绑定到端点”和“将套接字连接到端点”，端点是众所周知的网络地址。</p>

<h3 id="24-zmq的发送和接收">2.4 ZMQ的发送和接收：</h3>

<p><strong>ＺＭＱ与TCP套接字的区别：</strong></p>

<ul>
  <li>
    <p><strong>可以使用任意传输方式进行传输</strong>（ inproc、ipc、tcp、pgm或epgm）。<a href="http://api.zeromq.org/master:zmq_inproc">zmq_inproc()</a>、<a href="http://api.zeromq.org/master:zmq_ipc">zmq_ipc()</a>、<a href="http://api.zeromq.org/master:zmq_tcp">zmq_tcp()</a>、<a href="http://api.zeromq.org/master:zmq_pgm">zmq_pgm()</a>和<a href="http://api.zeromq.org/master:zmq_epgm">zmq_epgm()</a>。</p>
  </li>
  <li>
    <p><strong>一个套接字可能有许多传出连接和许多传入连接</strong>。</p>
  </li>
  <li>
    <p><strong>没有zmq_accept () 方法</strong>。当套接字绑定到端点时，它会自动开始接受连接。</p>
  </li>
  <li>
    <p><strong>网络连接由ZMQ自动管理，你无法直接处理这些连接</strong>。如果网络连接中断（例如，如果对等方消失然后又回来），ZeroMQ 将自动重新连接。</p>
  </li>
  <li>
    <p><strong>ZMQ不是一个能承载协议的中间载体，只能使用ZMQ_ROUTER_RAW套接字选项支持正确的读写HTTP等协议</strong>。这意味着他不能兼容现有的协议（like:HTTP，因为它们基于socket而ZMQ对socket进行了封装）。尽管可以使用ZMQ实现类似的协议但他们本质不同（取决于对端的协议，更广泛的设备使用的是普通的协议）。<strong>。</strong></p>
  </li>
  <li>
    <p><strong>ZMQ使用一个I/O线程来处理所有的网络连接</strong>，处于不断轮询的poll/select之中。</p>
  </li>
</ul>

<h3 id="三zmq程序接口">三、ZMQ程序接口</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">zmq_ctx_new</span> <span class="p">();</span>
</code></pre></div></div>

<ul>
  <li>
    <p>返回值：</p>

    <ul>
      <li>
        <p>成功: 返回ZMQ上下文content，是一个zmq_ctx_t的结构体</p>
      </li>
      <li>
        <p>失败: 返回NULL, 并设置errno</p>
      </li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">zmq_ctx_term</span> <span class="p">();</span>
</code></pre></div></div>

<ul>
  <li>
    <p>返回值:</p>

    <ul>
      <li>
        <p>成功: 返回0</p>
      </li>
      <li>
        <p>失败: 返回-1, 并设置errno</p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="三zmq源码结构">三、ZMQ源码结构</h1>

<p>https://www.iteye.com/blog/watter1985-1736023</p>

<p><a href="https://www.cnblogs.com/zengzy/p/5122634.html">zeromq源码分析笔记之架构（1） - zengzy - 博客园</a></p>

<p><a href="https://blog.csdn.net/gx_1983/article/details/70243824">zmq源代码分析 - mailbox_t_zmq代码-CSDN博客</a></p>

<p><a href="https://libzmq.readthedocs.io/en/latest/">ZMQ API reference</a></p>

<p><a href="https://aosabook.org/en/v2/zeromq.html">The Architecture of Open Source Applications (Volume 2)ZeroMQ</a></p>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="笔记" /><category term="中间件" /><category term="消息队列" /></entry><entry><title type="html">套接字编程</title><link href="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/" rel="alternate" type="text/html" title="套接字编程" /><published>2024-10-01T00:00:00+00:00</published><updated>2024-10-01T00:00:00+00:00</updated><id>https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B</id><content type="html" xml:base="https://honest-zh.github.io/%E7%AC%94%E8%AE%B0/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/"><![CDATA[<h1 id="套接字编程笔记">套接字编程笔记</h1>

<h2 id="1套接字网络通信">1、套接字网络通信</h2>

<p><a href="https://www.cnblogs.com/liyuanhong/articles/10591069.html">socket函数的domain、type、protocol解析 - 远洪 - 博客园 (cnblogs.com)</a></p>

<p><a href="https://www.jianshu.com/p/01018fcb5fbc">socket编程主要的API函数介绍(某马） - 简书 (jianshu.com)</a></p>

<p><a href="https://blog.csdn.net/m0_56510407/article/details/125351638">套接字编程-CSDN博客</a></p>

<p>套接字本质上是内核借助缓冲区形成的伪文件，用于表示进程间网络通信的特殊文件类型。在Linux环境下，套接字被视为一种特殊的文件描述符，它允许应用程序通过网络与其它计算机上的程序进行通信。一方面为了向上方的应用层屏蔽网络通信的协议的诸多细节，另一方面是为了统一接口。</p>

<p>然而在这屏蔽协议这点套接字做的并不好，甚至说是混乱不堪。封装了但是没有完全封装，而且还没有封装好（当然这和网络通信的复杂性不可分割），导致使用套接字的每个程序员都如坠云里雾里。最后还是要用户好好了解套接字的机制，背离了设计的本意。</p>

<p>但是长期以来在应用领域的巨大影响力早已让socket成为了事实上的标准，我们只能学习并了解它。对套接字的不满和分布式的应用需求催生了一系列的网络中间件（eg RabitMQ、Nginx、gRPC等），用于弥补套接字在功能和易用性上的空白，当然这是后话不谈。</p>

<h2 id="2-地址">2、 地址</h2>

<p>在套接字编程当中，网络的地址五元组（发送方IP地址、端口号、网络协议、接收方端口号、地址）和套接字标识符（句柄）是解耦的。由系统对套接字标识符进行管理。IP地址和端口号构成了一个套接字地址socket，欲建立连接的两方构成了一个套接字对（满足五元组），唯一确定了连接。</p>

<p><strong>2.1 地址转换系列函数：</strong></p>

<p>问题的本质是网络字节序和主机字节序。这来源于历史遗留问题，不同系统的数据存放方式有所不同（大端和小端）。相关内容网上很多就不再赘述。解决方法就是规定统一的网络字节序，然后在不同存放方式的主机上进行字节序的转换。</p>

<p>除此以外就是一些转换字符串、点分十进制转换到地址结构体中实际保存的long int中的函数。</p>

<p><strong>htonl/ntohl:</strong> 本地序转网络序，网络序转本地序（长，32位，四个8bit的点分十进制数）</p>

<p><strong>htons/ntohs:</strong> 本地序转网络序，网络序转本地序（短，16位，）</p>

<p><strong>忘了：</strong></p>

<p><strong>2.2 地址结构体：</strong></p>

<p><img title="" src="https://i-blog.csdnimg.cn/blog_migrate/b3307c85bcc34758930808786ccd3aa7.png" alt="" width="491" data-align="center" /></p>

<p><strong>struct sockaddr / struck sockaddr_in:</strong> 用来存放套接字地址的结构体，保证上层应用仅需知道套接字标识符就能进行通信（如同套接字socket的本意一样，像一个插座)。</p>

<p>设置三个成员：地址族、地址、端口号。例如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sockAdd</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
<span class="n">sockAdd</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>
<span class="n">sockAdd</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">8888</span><span class="p">);</span>
</code></pre></div></div>

<p><strong><em>注意记得加stuct</em></strong></p>

<blockquote>
  <p>私以为翻译成网络插口之类的名字更好。但是和鲁棒性一样，这一类的莫名的名称误导了了太多人。</p>
</blockquote>

<h2 id="3tcp和udp">3、TCP和UDP:</h2>

<h2 id="4套接字函数">4、套接字函数：</h2>

<p><strong>socket():</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">domain</code>: 协议版本</p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">AF_INET</code>： IPV4</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">AF_INET6</code>： IPV6</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">AF_UNIX </code>&amp; <code class="language-plaintext highlighter-rouge">AF_LOCAL</code>：本地通信</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">AF_PACKET</code>:链路层通信</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">type</code>:协议类型</p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">SOCK_STREAM </code>流式, 默认使用的协议是TCP协议</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">SOCK_DGRAM </code>报式, 默认使用的是UDP协议</p>
      </li>
    </ul>

    <blockquote>
      <p>也就是说流式不一定是TCP，报式也不一定是UDP。</p>
    </blockquote>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">protocal</code>:</p>

    <ul>
      <li>一般填0, 表示使用对应类型的默认协议.</li>
    </ul>
  </li>
  <li>
    <p>返回值:</p>

    <ul>
      <li>
        <p>成功: 返回一个大于0的文件描述符</p>
      </li>
      <li>
        <p>失败: 返回-1, 并设置errno</p>
      </li>
    </ul>
  </li>
</ul>

<p>套接字socket实际上是对内核中网络相关的代码的抽象。套接字的三个参数domain、type、protocol实质上都是用于从抽象的套接字到具体的网络代码的分类。domain参数决定了图中所示的第二层通信域，type决定了第三层的通信模式，protocol决定了第四层真正的通信协议。</p>

<p><img src="/assets/images/blog/2024-08-15-10-06-20-image.png" alt="" /></p>

<p><strong>setsockopt</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">setsockopt</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">optlen</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sockfd</code>：套接字描述符。</li>
  <li><code class="language-plaintext highlighter-rouge">level</code>：选项级别，这里使用<code class="language-plaintext highlighter-rouge">IPPROTO_TCP</code>表示 TCP 协议级别。</li>
  <li><code class="language-plaintext highlighter-rouge">optname</code>：具体的选项名称。</li>
  <li><code class="language-plaintext highlighter-rouge">optval</code>：指向包含选项值的缓冲区。</li>
  <li><code class="language-plaintext highlighter-rouge">optlen</code>：选项值的长度。</li>
</ul>

<p><strong>bind:</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">bind</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sockfd</code>：
    <ul>
      <li>参数说明：由 <code class="language-plaintext highlighter-rouge">socket()</code> 函数返回的套接字描述符。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">addr</code>：
    <ul>
      <li>参数说明：指向一个特定地址结构的指针，该结构包含要绑定的地址和端口信息。具体结构类型取决于 <code class="language-plaintext highlighter-rouge">domain</code> 参数，如 <code class="language-plaintext highlighter-rouge">struct sockaddr_in</code>（IPv4）或 <code class="language-plaintext highlighter-rouge">struct sockaddr_in6</code>（IPv6）。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">addrlen</code>：
    <ul>
      <li>参数说明：地址结构的长度。</li>
    </ul>
  </li>
</ul>

<p>bind用于把被系统当作文件标识符的套接字标识符和套接字地址绑定起来。上层只需要知道套接字的标识符（当作文件的标识符来使用），不用在意通信中的细节（两端的地址，通信协议等）。</p>

<p><strong>getsockname:</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">getsockname</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sockfd</code>：
    <ul>
      <li>参数说明：套接字描述符。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">addr</code>：
    <ul>
      <li>参数说明：指向一个地址结构的指针，用于存储获取到的本地地址信息。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">addrlen</code>：
    <ul>
      <li>参数说明：一个指向 <code class="language-plaintext highlighter-rouge">socklen_t</code> 类型变量的指针，输入时表示 <code class="language-plaintext highlighter-rouge">addr</code> 所指向的地址结构的长度，输出时被修改为实际存储的地址长度。</li>
    </ul>
  </li>
</ul>

<p><strong>listen</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">listen</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sockfd</code>：
    <ul>
      <li>参数说明：由 <code class="language-plaintext highlighter-rouge">socket()</code> 函数返回且已绑定地址的套接字描述符。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">backlog</code>：
    <ul>
      <li>参数说明：指定在拒绝连接之前，可以排队等待的最大连接数。</li>
    </ul>
  </li>
</ul>

<p><strong>connnect:</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sockfd</code>：
    <ul>
      <li>参数说明：由 <code class="language-plaintext highlighter-rouge">socket()</code> 函数返回的套接字描述符。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">addr</code>：
    <ul>
      <li>参数说明：指向一个地址结构的指针，包含了要连接的服务器的地址和端口信息。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">addrlen</code>：
    <ul>
      <li>参数说明：地址结构的长度。   </li>
    </ul>
  </li>
</ul>

<p><strong>accept:</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sockfd</code>：
    <ul>
      <li>参数说明：由 <code class="language-plaintext highlighter-rouge">socket()</code> 和 <code class="language-plaintext highlighter-rouge">listen()</code> 函数设置为监听状态的套接字描述符。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">addr</code>：
    <ul>
      <li>参数说明：指向一个地址结构的指针，用于存储客户端的地址信息。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">addrlen</code>：
    <ul>
      <li>参数说明：一个指向 <code class="language-plaintext highlighter-rouge">socklen_t</code> 类型变量的指针，输入时表示 <code class="language-plaintext highlighter-rouge">addr</code> 所指向的地址结构的长度，输出时被修改为实际存储的地址长度。</li>
    </ul>
  </li>
</ul>

<p><strong>recv</strong></p>

<p><strong>send</strong></p>

<p><strong>select:</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">select</span><span class="p">(</span><span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">nfds</code>：
    <ul>
      <li>参数说明：要监视的文件描述符的最大值加 1。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">readfds</code>：
    <ul>
      <li>参数说明：指向一个文件描述符集合的指针，用于监视可读的文件描述符。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">writefds</code>：
    <ul>
      <li>参数说明：指向一个文件描述符集合的指针，用于监视可写的文件描述符。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">exceptfds</code>：
    <ul>
      <li>参数说明：指向一个文件描述符集合的指针，用于监视异常情况的文件描述符。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">timeout</code>：
    <ul>
      <li>参数说明：指定等待的时间限制。如果为 <code class="language-plaintext highlighter-rouge">NULL</code>，则表示无限等待。是一个指向 <code class="language-plaintext highlighter-rouge">struct timeval</code> 结构的指针，该结构定义了等待的时间（秒和微秒）。</li>
    </ul>
  </li>
</ul>

<p><a href="https://blog.csdn.net/zhuxiaoping54532/article/details/51701549">Linux Poll 使用方法和实现_linux poll怎么写-CSDN博客</a></p>

<h2 id="进程间通信socketpair">进程间通信–socketpair</h2>

<p>socketpair 用于在进程之间创建两个套接字使两个线程可以跨进程通信。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">socketpair</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">domain</code>:协议族。例如，<code class="language-plaintext highlighter-rouge">AF_UNIX</code>用于本地通信，<code class="language-plaintext highlighter-rouge">AF_INET</code>用于IPV4，<code class="language-plaintext highlighter-rouge">AF_INET6</code>于IPV6</p>

<p><code class="language-plaintext highlighter-rouge">type</code>:套接字类型，对应TCP和UDP。例如，<code class="language-plaintext highlighter-rouge">SOCK_STREAM</code>、<code class="language-plaintext highlighter-rouge">SOCK_DGRAM</code>和SOCK_RAW</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">SOCK_CLOEXEC</code>:执行exec时自动关闭,用于多线程使用中避免内存泄漏，避免竞态。socketpair中使用这个类别的套接字保证父子进程的套接字同时关闭。</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">protocol</code>：用于确定协议，一般为0</p>

<p><code class="language-plaintext highlighter-rouge">sv[2]</code>：用于储存套接字的标识符，这两个套接字是socketpair创建出的用于全双工跨进程线程间通信的。</p>]]></content><author><name>HONEST</name><email>2260363172qq.com</email></author><category term="笔记" /><category term="Socket" /></entry></feed>